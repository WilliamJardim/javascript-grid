
// Conteúdo do arquivo: C:\Users\Meu Computador\Desktop\Projetos Pessoais Github\Deep Learning\javascript-grid\libs\Analise-builded.js

/*
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

/* COMPILADO: 7/1/2025 - 18:19:50*//* ARQUIVO: ../libs/Vectorization-builded.js*/

/*
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/
if(typeof window === 'undefined'){
    global.VECTORIZATION_BUILD = true;
    global.VECTORIZATION_BUILD_TYPE = 'node';
}else{
    window.VECTORIZATION_BUILD = true;
    window.VECTORIZATION_BUILD_TYPE = 'navegador';
}

/* COMPILADO: 2/1/2025 - 22:55:02*//* ARQUIVO VECTORIZATION: ../src/Root.js*/
/*
 * File Name: Root.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }

    globalThis.require = function(){};
}

if(!window.Vectorization){ window.Vectorization = {} };

/**
 * Base class for all other components.
 * @param {Object} config;
 * @returns {Vectorization.Base}
 */
window.Vectorization.Base = function(config){
    const context = {};
    context._config = config;
    context.objectName = 'Base';
    context.extendedFrom = 'Base';
    context.namespace = 'window.Vectorization';
    context.path = 'Vectorization.Base';
    context.autoGeneratedGetters = [];
    context.autoGeneratedSetters = [];
    context._translations = config.translations;
    context._pai = null;

    /**
    * Obtém o objeto pai deste objeto
    * Se existir 
    */
    context.getPai = function(){
        return context._pai;
    }

    /**
    * Obtém o objeto pai deste objeto
    * Se existir 
    */
    context.getFather = context.getPai;

    /**
    * Verifica se o valor deste objeto está presente em um Vectorization.Vector ou Vectorization.Matrix
    */
    context.in = function( objetoVerificar ){
        //Se este objeto for um Vector ou Matrix
        if( Vectorization.Matrix.isVectorizationMatrix( context ) == true ||
            Vectorization.Vector.isVectorizationVector( context ) == true 
        ){
            throw 'Ainda não implementado para verificar se Vetores e Matrizes estão presentes em outros Vetores e Matrizes!';
            
            //Se 'objetoVerificar' for um Vector ou Matrix
            if( Vectorization.Matrix.isVectorizationMatrix( objetoVerificar ) ||
                Vectorization.Vector.isVectorizationVector( objetoVerificar )
            ){
                
            }else{

            }

        //Se o este objeto for um Scalar ou Text
        }else{
            if( context.getTipo && 
                (context.getTipo() == 'Scalar' || context.getTipo() == 'Text')
            ){
                //Se 'objetoVerificar' for um Vector ou Matrix
                if( Vectorization.Matrix.isVectorizationMatrix( objetoVerificar ) == true ||
                    Vectorization.Vector.isVectorizationVector( objetoVerificar ) == true
                ){
                    return objetoVerificar.have( context.obterValor() );
                }
            }
        }
    }

    /**
    * Retorna o tipo do objeto
    * @returns {String}
    */
    context.getTipo = function(){
        return context.objectName;
    }

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    context.copyArgs = function(config){
        //Copia os argumentos
        let configKeys = Object.keys(config);
        for( let i = 0 ; i < configKeys.length ; i++){
            context[ configKeys[i] ] = config[ configKeys[i] ];
        }
    }

    context.copyArgsSeNaoExistir = function(config, aplicarBind=true){
        //Copia os argumentos
        let configKeys = Object.keys(config);

        for( let i = 0 ; i < configKeys.length ; i++){

            if( context[ configKeys[i] ] == undefined )
            {
                context[ configKeys[i] ] = config[ configKeys[i] ];
                if(aplicarBind == true && context[ configKeys[i] ].bind != undefined){
                    context[ configKeys[i] ].bind(context);
                }
            }

        }
    }

    context._doDefaultBaseAfterCreate = function(){
        context.createGettersFromOriginalProperties();
        context.createSettersFromOriginalProperties();
    }

    context.createGettersFromOriginalProperties = function(){
        //Getters
        Object.keys( context ).forEach( function(attrib){
            const nameOfGetter = `get${String( String(attrib[0]).replace('_','').toUpperCase() + String(attrib.slice(1, attrib.length) )).replace('_','').replace('get', '').replace('getGet', '').replace('Get', '') }`;
            
            if( typeof context[attrib] != 'function' && !context[nameOfGetter] ){
                context[nameOfGetter] = function(){
                    return context[attrib];
                }
                context.autoGeneratedGetters.push(nameOfGetter);
            }
        });
    }

    context.createSettersFromOriginalProperties = function(){
        //Setters
        Object.keys( context ).forEach( function(attrib){
            const nameOfSetter = `set${String( String(attrib[0]).replace('_','').toUpperCase() + String(attrib.slice(1, attrib.length) )).replace('_','').replace('get', '').replace('getGet', '').replace('Get', '') }`;
            
            if( typeof context[attrib] != 'function' && !context[nameOfSetter] ){
                context[nameOfSetter] = function(valueToDefine){
                    context[attrib] = valueToDefine; 
                }
                context.autoGeneratedSetters.push(nameOfSetter);
            }
        });
    }

    //Métodos responsavel por fazer as traduções dos métodos
    context.translateMethods = function(translations) {
        let translationsKeys;

        //Traduz os métodos
        translationsKeys = Object.keys(translations.translatedMethods);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedMethods[nomeMetodoTraduzido];

           //Aplica a tradução
           if(typeof context[nomeOriginal] === 'function'){
               context[nomeMetodoTraduzido] = context[nomeOriginal].bind(context);
           }
        }
    }

    //Métodos responsavel por fazer as traduções dos atributos
    context.translateAttributes = function(translations) {
        let translationsKeys;

        //Traduz os atributos
        translationsKeys = Object.keys(translations.translatedAttributes);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

           //Aplica a tradução no atributo
           if(context[nomeOriginal] != undefined && typeof context[nomeOriginal] != 'function' && !context[nomeMetodoTraduzido] ){
              context[nomeMetodoTraduzido] = context[nomeOriginal];
           }
        }
    }

    //Parecido com a função translateAttributes, porém ele faz essa tradução e retorna um objeto com as traduções aplicadas
    //No caso o translationsDicionario pode ser um objeto ja pronto que só precisa ser traduzido
    //Isso vai ser usado na inicialização de algumas classes como Vectorization.Matrix e Vectorization.Vector
    context.translateAttributes_andReturn = function(propioDicionario, translations){
        let translationsKeys;
        let novoObjeto = {... propioDicionario};

        //Traduz os atributos
        translationsKeys = Object.keys(propioDicionario);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

           if( nomeOriginal != undefined && !propioDicionario[nomeOriginal] ){
               novoObjeto[nomeOriginal] = propioDicionario[nomeMetodoTraduzido];
           }
        }

        return novoObjeto;
    }

    //Para não ter problemas com atributos desatualizados
    context.atualizarAtributosTraduzidos = function(translations=context._internal_translations){
        let translationsKeys;

        //Pegar os atributos traduzidos
        translationsKeys = Object.keys(translations.translatedAttributes);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
            const nomeMetodoTraduzido = translationsKeys[i];
            const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

            if( nomeOriginal != undefined && 
                typeof context[nomeMetodoTraduzido] != 'function' && 
                typeof context[nomeOriginal] != 'function' &&
                context[nomeOriginal] != undefined &&
                context[nomeMetodoTraduzido] != undefined
            ){
                context[nomeMetodoTraduzido] = context[nomeOriginal];
            }
        }
    }

    //Start class
    context.copyArgs(config);
    context._doDefaultBaseAfterCreate();

    context.applyTranslations = function(translationFunction=null){
        //Se existir uma tradução para a classe
        if(context._translations && typeof context._translations === 'function'){
            context._internal_translations = translationFunction || context._translations();
            context.translateMethods( context._internal_translations );
            context.translateAttributes( context._internal_translations );
        }
    }

    context.applyTranslations(null);

    context.getTodasConfiguracoesAplicadas = function(){
        let todasConfiguracoesClassConfig = {};
        let keysConfiguracoesClassConfig = [... Object.keys(context)];

        for( let i = 0 ; i < keysConfiguracoesClassConfig.length ; i++ )
        {
            let nomeConfiguracaoClassConfig = keysConfiguracoesClassConfig[i],
                valorConfiguracaoClassConfig = context[nomeConfiguracaoClassConfig];
            
            todasConfiguracoesClassConfig[nomeConfiguracaoClassConfig] = valorConfiguracaoClassConfig;
        }

        return { 
                  configuracoesUsadas: todasConfiguracoesClassConfig,
                  quantidadeDentro: keysConfiguracoesClassConfig.length
               };
    }

    context.herdarFuncoes = function(referenciaObjeto){
        const templateObjetoCriado = referenciaObjeto();
        const contextObjetoCriado = templateObjetoCriado;
        
        //Aplica dentro deste objeto do Vectorization
        context.copyArgsSeNaoExistir(contextObjetoCriado); 
    }

    return context;
}

//Funções a nivel principal

/**
 * Gera uma matrix de identidade
 * @param {Number} ordem 
 * @returns {Vectorization.Matrix}
*/
window.Vectorization.matrixIdentidade = function(ordem){
    const NON_DIAGONAL_VALUE = 0;
    const DIAGONAL_VALUE = 1;
    let matrix = [];

    for( let i = 0 ; i < ordem ; i++ )
    {
        matrix[i] = [];
        for( let j = 0 ; j < ordem ; j++ )
        {
            //NA LINHA ATUAL, Toda vez que o indice do número for igual ao indice da linha, ele faz parte da diagonal principal
            if( j == i ){
                matrix[i][j] = DIAGONAL_VALUE;

            }else{
                matrix[i][j] = NON_DIAGONAL_VALUE;
            }
        }
    }

    const extraProps = {
        isIdentidade: true
    }

    return Vectorization.Matrix(matrix, extraProps);
}

window.Vectorization.identificarTipo = function(obj){
    //Se for um objeto do Vectorization
    if( obj instanceof Object && obj.objectName != undefined ){

        if( Vectorization.Scalar.isScalar( obj ) ){
            return 'Scalar';

        }else if( Vectorization.Text.isText( obj ) ){
            return 'Text';

        }else{
            return undefined;
        }

    }else{
        if( typeof obj == 'number' ){
            return 'Scalar';

        }else if( typeof obj == 'string' ){
            return 'Text';
        }
    }

    return undefined;
}

window.Vectorization.isAlgumValorVectorization = function(obj){
    return window.Vectorization.identificarTipo(obj) != undefined && 
           obj instanceof Object && 
           obj.objectName != undefined;
}

window.Vectorization.isAlgumVetorVectorization = function(obj){
    return window.Vectorization.Vector.isVectorizationVector(obj) ||
           window.Vectorization.StringVector.isVectorizationStringVector(obj) ||
           window.Vectorization.BendableVector.isVectorizationBendableVector(obj);
}

module.exports = window.Vectorization.Root;

//Cria uma namespace para calculos matemáticos basicos
window.Vectorization.Math = {};

window.Vectorization.Math.log = function(base, valor){
    return Math.log(valor) / Math.log(base)
}

window.Vectorization.Math.log2 = function(valor){
    return Math.log2(valor);
}

window.Vectorization.Math.log10 = function(valor){
    return Math.log10(valor);
}

window.Vectorization.Math.sin = function(radians){
    return Math.sin(radians);
}

window.Vectorization.Math.cos = function(radians){
    return Math.cos(radians);
}

window.Vectorization.Math.pow = function(base, exponente){
    return Math.pow(base, exponente);
}

/**
* Calcula a correlação de Pearson entre dois vetores do Vectorization. 
* Valores altos proximos de 1 significa que é uma correlação positiva forte, ou seja, isso significa que quando os valores de X aumentam, os valores de Y tambem aumentam
* Valores altos proximos de -1 significa que é uma correlação negativa forte, ou seja, isso significa que quando os valores de X aumentam, os valores de Y diminuem
*
* @param {Vectorization.Vector} vetor1
* @param {Vectorization.Vector} vetor2
* @returns {Number}
*/
window.Vectorization.Math.correlation = function(vetor1, vetor2) {
    if( !Vectorization.Vector.isVector(vetor1) || !Vectorization.Vector.isVector(vetor2) ){
        throw new Error('Os parametros precisam ser Vectorization.Vector(s)');
    }
    if (vetor1.length !== vetor2.length) {
        throw new Error('Os dois vetores devem ter o mesmo tamanho.');
    }
    if (vetor1.length === 0) {
        throw new Error('Os vetores não podem estar vazios.');
    }

    //Pega a quantidade de elementos, que vai ser a mesma para ambas os vetores
    const qtdeElementos = vetor1.length;

    //Calcula as médias de ambos os vetores
    const mediaX = vetor1.media();
    const mediaY = vetor2.media();

    let numerador = 0;
    let denominadorX = 0;
    let denominadorY = 0;

    for (let i = 0; i < qtdeElementos; i++) {
        const deltaVetor1 = vetor1[i] - mediaX;
        const deltaVetor2 = vetor2[i] - mediaY;

        numerador += deltaVetor1 * deltaVetor2;
        denominadorX += deltaVetor1 ** 2;
        denominadorY += deltaVetor2 ** 2;
    }

    const denominador = Math.sqrt(denominadorX * denominadorY);

    if (denominador === 0) {
        throw new Error('Impossivel ter divisão por zero ao calcular a correlação.');
    }

    return numerador / denominador;
}

//Cria um alias para facilitar a chamada
if( typeof V == 'undefined' ){
    window.V = window.Vectorization;
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/Root.js*/
/* ARQUIVO VECTORIZATION: ../src/Utilidades.js*/
/*
 * File Name: Utils.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Utilidades = {};

window.Vectorization.Utilidades.apenasNumeros = function(stringObj){
    let apenasNumeros = true;
    let tamanhoString = stringObj.length;
    for( let letra = 0 ; letra < tamanhoString ; letra++ )
    {       
        if( !isNaN( Number(stringObj[letra]) ) || stringObj[letra] == '.' ){
            apenasNumeros = true;

        }else{
            apenasNumeros = false;
            break;
        }
    }

    return apenasNumeros;
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/Utilidades.js*/
/* ARQUIVO VECTORIZATION: ../src/Scalar.js*/
/*
 * File Name: Scalar.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 

    if( window.Vectorization.Random == undefined ){
        require('./Root'); 
        require('./Random'); 
    }

    if( window.Vectorization.Utilidades == undefined ){
        require('./Utilidades'); 
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Scalar = function( value=NaN, classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Scalar._translations || null;

    let classeBaseEscalar = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseEscalar.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( value.objectName != undefined && value.objectName == 'Scalar' ){
        return Vectorization.Scalar( value.raw(), {... classConfig} );
    }

    //let context = {... classConfig};
    let context = window.Vectorization.Base({... classConfig});

    if( value != undefined && 
        !(value instanceof Object) &&
        (typeof value == 'number' || Vectorization.Utilidades.apenasNumeros(value)) == true
    ){
        context.value = Number(value);
        context.configuracoesValue = {};
    
    //Se for um objeto com configurações
    }else if(value instanceof Object){

        //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
        value = classeBaseEscalar.translateAttributes_andReturn(value, classConfig['translations']() );

        //Salva a config
        context.configuracoesValue = {... value};

        if( value.aleatorio == true ){
            if( value.minimo != undefined && value.maximo != undefined ){
                context.aleatorio = true;
                context.ultimoMaximoUsado = value.maximo;
                context.ultimoMinimoUsado = value.minimo;
                context.sementeAleatoria = context.sementeAleatoria || Vectorization.Random._sementeDefinida;

                if( value.sementeAleatoria != undefined ){
                    context.sementeAleatoria = value.sementeAleatoria;

                    if( typeof value.sementeAleatoria == 'number' ){
                        context.numeroSemente = value.sementeAleatoria;
                    }
                }

                context.value = Vectorization.Random.gerarNumeroAleatorio( Number(value.minimo), Number(value.maximo), context.sementeAleatoria );
                if( value.arredondar != undefined ){
                    switch(value.arredondar){
                        case true:
                            context.value = Math.round(context.value);
                            break;

                        case 'cima':
                        case 'up':
                            context.value = Math.ceil(context.value);
                            break;
            
                        case 'baixo':
                        case 'down':
                            context.value = Math.floor(context.value);
                            break;

                        case 'automatico':
                        case 'auto':
                            context.value = Math.round(context.value);
                            break;
                    }
                }

            }else{
                throw 'Para criar um Scalar aleatório voce precisar passar a faixa de valores!';
            }

        }else{
            //Se nao for aleatorio
            if( value.value != undefined ){
                if( typeof value.value == 'string' ){
                    context.value = value.value;
                    
                }else{
                    context.value = Number(value.value);
                }
            }
        }
    }

    context.objectName = 'Scalar';
    context.path = 'Vectorization.Scalar';

    context.storedClassConfig = classConfig || {};

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

        }else{
            throw 'Ação não permitida para este Vectorization.Scalar!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;
        }else{
            throw 'Ação não permitida para este Vectorization.Scalar!';
        }
    }

    context.obterValor = function(){
        return context.value;
    }

    //Troca o número aleatorio dentro desse Vectorization.Scalar
    context.trocarNumeroAleatorio = function(novoMinimo=context.ultimoMinimoUsado, novoMaximo=context.ultimoMaximoUsado, novaSemente=null){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Scalar
        if( context._isBloqueado() == true ){
           throw 'Este Vectorization.Scalar está bloqueado para novas gravações!';
        }

        if( context.aleatorio == true ){

            if( novoMinimo == null ){
                novoMinimo = context.ultimoMinimoUsado;
            }

            if( novoMaximo == null ){
                novoMaximo = context.ultimoMaximoUsado;
            }

            if( novaSemente == null ){
                novaSemente = context.sementeAleatoria;

            }else{
                context.sementeAleatoria = Vectorization.Random._get_dados_semente(novaSemente);
                
                if( typeof novaSemente == 'number' ){
                    context.numeroSemente = novaSemente;
                }
            }

            context.ultimoMaximoUsado = novoMaximo;
            context.ultimoMinimoUsado = novoMinimo;

            context.value = Vectorization.Random.gerarNumeroAleatorio( Number(novoMinimo), Number(novoMaximo), novaSemente );
            if( value.arredondar != undefined ){
                switch(value.arredondar){
                    case true:
                        context.value = Math.round(context.value);
                        break;

                    case 'cima':
                    case 'up':
                        context.value = Math.ceil(context.value);
                        break;
        
                    case 'baixo':
                    case 'down':
                        context.value = Math.floor(context.value);
                        break;

                    case 'automatico':
                    case 'auto':
                        context.value = Math.round(context.value);
                        break;
                }
            }

            return context.value;

        }else{
            throw 'Este objeto não é aleatório!';
        }
    }

    context.valueOf = function(){
        return Number.parseFloat( context.value );
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.Text( context.valueOf(), novasConfiguracoes );
    }

    context.toString = function(){
        return String(context.value);
    }

    context.raw = function(){
        return context.value + 0;
    }

    context.isIgual = function( outraCoisa ){
        if( Vectorization.Scalar.isScalar(outraCoisa) && outraCoisa.objectName != undefined ){
            return context.raw() == outraCoisa.raw();

        }else if( typeof outraCoisa == 'number' ){
            return context.raw() == outraCoisa
        }
    }

    context.somarNumero = function(numero){
        return Vectorization.Scalar(context.value + numero, {... classConfig});
    }

    context.subtrairNumero = function(numero){
        return Vectorization.Scalar(context.value - numero, {... classConfig});
    }

    context.dividirNumero = function(numero){
        return Vectorization.Scalar(context.value / numero, {... classConfig});
    }

    context.multiplicarNumero = function(numero){
        return Vectorization.Scalar(context.value * numero, {... classConfig});
    }

    context.elevarNumero = function(numero){
        return Vectorization.Scalar(Math.pow(context.value, numero), {... classConfig});
    }

    context.aoQuadrado = function(){
        return Vectorization.Scalar(context.elevarNumero(2), {... classConfig});
    }

    context.metade = function(){
        return Vectorization.Scalar(context.dividirNumero(2), {... classConfig});
    }

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    context.bloqueado = (classConfig['bloqueado'] != undefined) ? (classConfig['bloqueado']) : false;

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //return context;
    return new Proxy(context, {
        
        set: function(target, prop, value) {
          //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Scalar
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Scalar está bloqueado para novas gravações!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'Você não pode modificar esta atributo do Vectorization.Vector!';
          }

          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Scalar.isScalar = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Scalar') || typeof obj == 'number';
}

window.Vectorization.Scalar.isVectorizationScalar = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Scalar');
}

module.exports = window.Vectorization.Scalar;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Scalar.js*/
/* ARQUIVO VECTORIZATION: ../src/Scalar-translation.js*/
/*
 * File Name: Scalar-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Scalar._translations = function(){
    const translatedMethods = {
        'elevarQuadrado': 'aoQuadrado',
        'elevarAoQuadrado': 'aoQuadrado'
    };

    const translatedAttributes = {
        'valor': 'value',
        'conteudo': 'value'
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Scalar._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Scalar-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Text.js*/
/*
 * File Name: Text.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
    if( window.Vectorization.Random == undefined ){
        require('./Root'); 
        require('./Scalar'); 
    }

    if( window.Vectorization.Utilidades == undefined ){
        require('./Utilidades'); 
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Text = function( value=NaN, classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Text._translations || null;

    let classeBaseEscalar = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseEscalar.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    if( value.objectName != undefined && value.objectName == 'Text' ){
        return Vectorization.Text( value.raw(), {... classConfig} );
    }

    //let context = {... classConfig};
    let context = window.Vectorization.Base({... classConfig});

    if( value != undefined && 
        !(value instanceof Object) &&
        (typeof value == 'string' || Vectorization.Utilidades.apenasNumeros(value)) == true
    ){

        context.value = String(value);
        context.configuracoesValue = {};
    
    //Se for um objeto com configurações
    }else if(value instanceof Object){

        //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
        value = classeBaseEscalar.translateAttributes_andReturn(value, classConfig['translations']() );

        //Salva a config
        context.configuracoesValue = {... value};

        if( value.value != undefined ){
            if( typeof value.value == 'string' ){
                context.value = value.value;
                
            }else{
                context.value = String(value.value);
            }
        }
    }

    if(context.value == undefined){
        if( Vectorization.Scalar.isScalar(value) == true ){
            context.value = String(value);   
        }
    }

    context.objectName = 'Text';
    context.path = 'Vectorization.Text';

    context.storedClassConfig = classConfig || {};

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

        }else{
            throw 'Ação não permitida para este Vectorization.Scalar!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;
        }else{
            throw 'Ação não permitida para este Vectorization.Scalar!';
        }
    }

    context.obterValor = function(){
        return context.value;
    }

    context.valueOf = function(){
        return String( context.value );
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.Scalar( context.valueOf(), novasConfiguracoes );
    }

    context.toString = function(){
        return String(context.value);
    }

    context.raw = function(){
        return context.value;
    }

    context.isIgual = function( outraCoisa ){
        if( Vectorization.Text.isText(outraCoisa) && outraCoisa.objectName != undefined ){
            return context.raw() == outraCoisa.raw();

        }else if( typeof outraCoisa == 'string' ){
            return context.raw() == outraCoisa
        }
    }

    /**
    * Transforma este Vectorization.Text em um Vectorization.StringVector
    * Transform this Vectorization.Text into a Vectorization.StringVector
    * @returns {Vectorization.StringVector}
    */
    context.toCharacterVector = function(){
        let esteTexto = context;
        return Vectorization.StringVector( esteTexto.obterValor().split('') );
    }
    context.paraVetorCaracteres = context.toCharacterVector;


    context.letrasMaiusculas = function(){
        return Vectorization.Text( String( context.obterValor() ).toUpperCase() );
    }
    context.toUpperCase = context.letrasMaiusculas;


    
    context.letrasMinusculas = function(){
        return Vectorization.Text( String( context.obterValor() ).toLowerCase() );
    }
    context.toLowerCase = context.letrasMinusculas;

    /**
    * Verifica se este Vectorization.Text é igual a outro Vectorization.Text
    * @param {Vectorization.Text} outroTexto 
    * @returns {Boolean}
    */
    context.isIgual = function(outroTexto){
        let outroTexto_Text = Vectorization.Text.isVectorizationText(outroTexto) == false ? Vectorization.Text(outroTexto) : outroTexto;
        return Vectorization.Text.isText(outroTexto) && context.obterValor() === outroTexto_Text.obterValor();
    }

    /**
    * Calcula a distancia hamming deste Vectorization.Text com outro Vectorization.Text
    * @param {Vectorization.Text} outroTexto 
    * @returns {Vectorization.Scalar}
    */
    context.distanciaHamming = function(outroTexto){
        let outroTexto_Text = Vectorization.Text.isVectorizationText(outroTexto) == false ? Vectorization.Text(outroTexto) : outroTexto;
        let caracteresOutroTexto = outroTexto_Text.toCharacterVector();

        let esteTexto_Text = context;
        let caracteresEsteTexto = esteTexto_Text.toCharacterVector();

        let distanciaTotalCalculada = Vectorization.Scalar(0);

        caracteresEsteTexto.paraCadaElemento(function(i){
            let isIgual = (caracteresEsteTexto.lerIndice(i).isIgual( caracteresOutroTexto.lerIndice(i) ) ) == true ? 0 : 1;
            distanciaTotalCalculada = distanciaTotalCalculada.somarNumero( Vectorization.Scalar(isIgual) );
        });

        return Vectorization.Scalar(distanciaTotalCalculada);
    }

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    context.bloqueado = (classConfig['bloqueado'] != undefined) ? (classConfig['bloqueado']) : false;

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //return context;
    return new Proxy(context, {
        
        set: function(target, prop, value) {
          //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Scalar
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Text está bloqueado para novas gravações!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'Você não pode modificar esta atributo do Vectorization.Vector!';
          }

          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Text.isText = function(obj){
    if(obj == undefined){return false};
    return (obj.objectName != undefined && obj.objectName == 'Text') || typeof obj == 'string';
}

window.Vectorization.Text.isVectorizationText = function(obj){
    if(obj == undefined){return false};
    return (obj.objectName != undefined && obj.objectName == 'Text');
}

module.exports = window.Vectorization.Text;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Text.js*/
/* ARQUIVO VECTORIZATION: ../src/Text-translation.js*/
/*
 * File Name: Text-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Text._translations = function(){
    const translatedMethods = {
        'isEquals': 'isIgual'
    };

    const translatedAttributes = {
        'valor': 'value',
        'conteudo': 'value'
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Text._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Text-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Boolean.js*/
/*
 * File Name: Boolean.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 

    if( window.Vectorization.Random == undefined ){
        require('./Root'); 
        require('./Random'); 
    }

    if( window.Vectorization.Utilidades == undefined ){
        require('./Utilidades'); 
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Boolean = function( value=NaN, classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Boolean._translations || null;

    let classeBaseEscalar = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseEscalar.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( value.objectName != undefined && value.objectName == 'Boolean' ){
        return Vectorization.Boolean( value.raw(), {... classConfig} );
    }

    //let context = {... classConfig};
    let context = window.Vectorization.Base({... classConfig});

    if( classConfig.value ){
        value = classConfig.value;
    }

    if( value != undefined && 
        !(value instanceof Object) &&
        (typeof value == 'number' || typeof value == 'false' || typeof value == 'true' || Vectorization.Utilidades.apenasNumeros(value)) == true
    ){
        if( value > 1 ){
            throw 'Esse Vectorization.Boolean não suporta valores maiores do que 1!';
        }

        if( value < 0 ){
            throw 'Esse Vectorization.Boolean não suporta valores menores do que 0!';
        }

        context.value = Number(value);
        context.configuracoesValue = {};
    
    //Se for um objeto com configurações
    }else if(value instanceof Object){

        //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
        value = classeBaseEscalar.translateAttributes_andReturn(value, classConfig['translations']() );

        //Salva a config
        context.configuracoesValue = {... value};

        if( value.value > 1 ){
            throw 'Esse Vectorization.Boolean não suporta valores maiores do que 1!';
        }

        if( value.value < 0 ){
            throw 'Esse Vectorization.Boolean não suporta valores menores do que 0!';
        }

        if( typeof value.value == 'string' ){
            context.value = value.value;
        }else{
            context.value = Number(value.value);
        }
    }

    if( typeof context.value == 'string' ){
        context.value = String(context.value).toLowerCase();
    }

    if( context.value == 'sim' || context.value == 'verdade' || context.value == 'afirmativo' || context.value == 'verdadeiro' ){
        context.value = Number(true);

    }else if( context.value == 'nao' || context.value == 'falso' || context.value == 'negativo' ){
        context.value = Number(false);
    }

    context.objectName = 'Boolean';
    context.path = 'Vectorization.Boolean';

    context.storedClassConfig = classConfig || {};

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

        }else{
            throw 'Ação não permitida para este Vectorization.Boolean!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;
        }else{
            throw 'Ação não permitida para este Vectorization.Boolean!';
        }
    }

    context.obterValor = function(){
        return context.value;
    }

    context.valueOf = function(){
        return Number.parseFloat( context.value );
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.Text( context.valueOf(), novasConfiguracoes );
    }

    context.toString = function(){
        return String(context.value);
    }

    context.raw = function(){
        return context.value + 0;
    }

    context.toggle = function(){
        if( context.value == Number(true) ){
            context.value = Number(false);
            
        }else{
            context.value = Number(true);
        }
    }

    context.isTrue = function(){
        return context.value == Number(true);
    }

    context.isFalse = function(){
        return context.value == Number(false);
    }

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    context.bloqueado = (classConfig['bloqueado'] != undefined) ? (classConfig['bloqueado']) : false;

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //return context;
    return new Proxy(context, {
        
        set: function(target, prop, value) {
          //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Scalar
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Boolean está bloqueado para novas gravações!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'Você não pode modificar esta atributo do Vectorization.Boolean!';
          }

          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Boolean.isBoolean = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Boolean') || typeof obj == 'number';
}

window.Vectorization.Boolean.isVectorizationBoolean = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Boolean');
}

module.exports = window.Vectorization.Boolean;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Boolean.js*/
/* ARQUIVO VECTORIZATION: ../src/Boolean-translation.js*/
/*
 * File Name: Boolean-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Boolean._translations = function(){
    const translatedMethods = {
        
    };

    const translatedAttributes = {
        'valor': 'value',
        'conteudo': 'value'
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Boolean._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Boolean-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Vector.js*/
/*
 * File Name: Vector.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    require('./Scalar');
    require('./Root');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Vector = function( config=[], classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Vector._translations || null;

    //Por padrão o usarEscalares vai ser true
    if( config['usarEscalares'] == undefined && classConfig['usarEscalares'] == undefined && config['usarEscalares'] != false && classConfig['usarEscalares'] != false ){
        config['usarEscalares'] = true;
    }

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.Vector.isVector(config) && config.objectName == 'Vector' ){
        return Vectorization.Vector( config.values() );
    }

    let context = window.Vectorization.Base(classConfig);
    context.objectName = 'Vector';
    context.path = 'Vectorization.Vector';
    context.configRecebidaUsuario = config;

    context.storedClassConfig = classConfig || {};

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    //classConfig = context.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Aplica a tradução dos atributos também no config, EXCETO SE config FOR UM ARRAY
    if( config instanceof Object && !(config instanceof Array && (config instanceof Array || Vectorization.Vector.isVector(config) )) ){
        config = context.translateAttributes_andReturn(config, classConfig['translations']() );
    }

    context.initialColumnValue = config['fillValue'] || 0;
    context.content = [];

    context.permitirDesbloquear = (config['permitirDesbloquear'] != undefined || classConfig['permitirDesbloquear'] != undefined) ? (config['permitirDesbloquear'] || classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (config['permitirBloquear'] != undefined || classConfig['permitirBloquear'] != undefined) ? (config['permitirBloquear'] || classConfig['permitirBloquear']) : true;

    /**
    * Verifica se algum elemento está presente nesta Vectorization.Matrix
    * @param {Object} valor 
    * @returns {Boolean}
    */
    context.have = function( valor ){
        return context.rawProfundo().includes( valor );
    }

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

            if(context.usarEscalares != undefined && context.usarEscalares == true)
            {
                //Bloquear também os filhos dentro deste Vectorization.Vector
                context.paraCadaElemento(function(i, elementoVetor){
                    elementoVetor.bloquearModificacoes();
                });
            }

        }else{
            throw 'Ação não permitida para este Vectorization.Vector!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;

            if(context.usarEscalares != undefined && context.usarEscalares == true)
            {
                //Desbloquear também os filhos dentro deste Vectorization.Vector
                context.paraCadaElemento(function(i, elementoVetor){
                    elementoVetor.desbloquearModificacoes();
                });
            }
            
        }else{
            throw 'Ação não permitida para este Vectorization.Vector!';
        }
    }

    context.trocarValoresAleatorios = function(novoMinimo=null, novoMaximo=null, novaSemente=null){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }
        
        if( context.usarEscalares == true )    
        {
            context.paraCadaElemento(function(i, elementoVetor){
                elementoVetor.trocarNumeroAleatorio(novoMinimo, novoMaximo, novaSemente);
            });

        }else{
            context.substituirElementosPor(
                context.mapearValores(function(i, elementoVetor){
                    return Vectorization.Scalar({
                        aleatorio: true,
                        minimo: 0,
                        maximo: 10
                    }).trocarNumeroAleatorio(novoMinimo, novoMaximo, novaSemente);
                })
            );
        }

        return context;
    }

    context._update = function(){
        context.length = config.length;
        context.elementos = config.length;
    }

    //Se passar diretamente o conteudo
    if( config instanceof Array ){
        context.content = config;
        context.length = config.length;

    //Ou caso contrario
    }else{
        if( config instanceof Object && config['length'] ){
            context.length = config['length'];
        }

        //Inicializa o vetor
        for( let i = 0 ; i < context.length ; i++ )
        {
            if( Vectorization.Vector.isVectorizationVector(context.initialColumnValue) == true ||
                Vectorization.Matrix.isMatrix(context.initialColumnValue) == true
            ){
                context.content[i] = context.initialColumnValue.duplicar();

            }else{
                context.content[i] = context.initialColumnValue;
            }
        }
    }

    /**
     * Permite definir uma posição especifica deste vetor
     * @param {Number} indice 
     * @param {any} valor 
     */
    context.definirElementoNoIndice = function(indice, valor){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.content[indice] = valor;
    }

    context.estaVazio = function(){
        return context.tamanho() == 0 ? true : false;
    }
    context.isVazio = context.estaVazio;

    /**
     * Permite trocar todos os valores deste vetor, elemento a elemento
     * por valores que vem de outro vetor, com a mesma quantidade de elementos
     * 
     * @param {Vectorization.Vector} outroVector - O outro vetor que contem os valores
     * @returns {Vectorization.Vector}
     */
    context.substituirElementosPor = function(outroVector){
        let valoresASeremColocados = (Vectorization.Vector.isVector(outroVector) && Vectorization.Vector.isVectorizationVector(outroVector)) ? outroVector.valores() : outroVector;
        let tamanhoSegundoVetor = (Vectorization.Vector.isVector(outroVector) && Vectorization.Vector.isVectorizationVector(outroVector)) ? outroVector.tamanho() : outroVector.length;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        if(context.tamanho() != tamanhoSegundoVetor){
            throw 'O tamanho do outroVetor precisa ser o mesmo!';
        }
        
        if( context.tamanho() > 0 )
        {
            Vectorization.Vector(context.content).paraCadaElemento(function(indiceTrocar, elementoTrocar){
                context.definirElementoNoIndice(indiceTrocar, valoresASeremColocados[indiceTrocar]);
            });

        }else{
            throw 'O Vectorization.Vector não pode estar vazio!';
        }

        return valoresASeremColocados;
    }

    /**
     * Permite trocar todos os valores deste vetor, PORÈM não elemento a elemento
     * Ele vai casar os indices deste Vectorization.Vector com o vetor de objetos que identificam os indices e os valores
     * 
     * @param {Vectorization.Vector} outroVectorDeInformacoes - O outro vetor que contem os valores
     * @returns {Vectorization.Vector}
     */
    context.substituirElementosPorIndice = function(outroVectorDeInformacoes){
        let valoresASeremColocados = (Vectorization.Vector.isVector(outroVectorDeInformacoes) && Vectorization.Vector.isVectorizationVector(outroVectorDeInformacoes)) ? outroVectorDeInformacoes.valores() : outroVectorDeInformacoes;
    
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        if( context.tamanho() > 0 )
        {
            Vectorization.Vector(valoresASeremColocados).paraCadaElemento(function(indice, elementoComAsInformacoes){
                let indiceTrocar = elementoComAsInformacoes.indice;
                let valorASerColocado = elementoComAsInformacoes.valor;
                
                context.definirElementoNoIndice(indiceTrocar, valorASerColocado);
            });

        }else{
            throw 'O Vectorization.Vector não pode estar vazio!';
        }

        return context;
    }

    context.toText = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.StringVector( context.raw(), novasConfiguracoes);
    }

    context.values = function(){
        if( context.usarEscalares == true ){
            return context.raw();

        }else{
            return context.content;
        }
    }

    //Alias for context.values
    context.valores = context.values;

    context.toArray = function(){
        if( context.usarEscalares != undefined && context.usarEscalares == true )
        {
            let valoresSemEstarEmEscalar = [];
            context.paraCadaElemento(function(i, objetoEscalar){

                if( objetoEscalar.obterValor == undefined && 
                    typeof objetoEscalar == 'number' 
                
                ){
                    valoresSemEstarEmEscalar.push( objetoEscalar );

                }else{
                    valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );
                }
            });

            return valoresSemEstarEmEscalar;

        }else{
            return context.content;
        }
    }

    //Alias for context.toArray
    context.raw = context.toArray;

    context.rawProfundo = function(){
        if( context.usarEscalares != undefined && context.usarEscalares == true )
        {
            let valoresSemEstarEmEscalar = [];
            context.paraCadaElemento(function(i, objetoEscalar){

                if( objetoEscalar.obterValor == undefined && 
                    typeof objetoEscalar == 'number' 
                
                ){
                    valoresSemEstarEmEscalar.push( objetoEscalar );

                }else{
                    valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );
                }
            });

            return valoresSemEstarEmEscalar;

        }else{
            //if( context.content.some( (elementoAtual)=>{ return Vectorization.Vector.isVectorizationVector(elementoAtual) || Vectorization.BendableVector.isVectorizationBendableVector(elementoAtual) } ) 
            if( (elementoAtual) => Vectorization.Scalar.isScalar(elementoAtual) == true || 
                                   Vectorization.Text.isText(elementoAtual) == true )
            {
                let valoresSemEstarEmEscalar = [];
                context.paraCadaElemento(function(i, objetoEscalar){

                    if( Vectorization.Scalar.isScalar(objetoEscalar) || 
                        Vectorization.Text.isText(objetoEscalar)
                    
                    ){
                        if( objetoEscalar.obterValor != undefined )
                        {
                            valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );

                        }else{
                            valoresSemEstarEmEscalar.push( objetoEscalar );
                        }
    
                    }else{
                        valoresSemEstarEmEscalar.push( objetoEscalar );
                    }
                });

                return valoresSemEstarEmEscalar;
                
            }else{
                return context.content;
            }
        }
    }

    context.obterTiposRapido = function(includeNamespace=false){
        let tiposUsados = [];
        context.paraCadaElemento(function(i, elementoAtual){
            if( includeNamespace == true ){
                tiposUsados.push( 'Vectorization.' + String(elementoAtual.objectName) );

            }else{
                tiposUsados.push( String(elementoAtual.objectName) );
            }
        });

        return tiposUsados;
    }

    /**
    * Obtem um novo Vector exatamente igual a este Vector
    * Ou seja, faz uma copia do propio objeto, identido, porém sem manter as referencias. 
    * @returns {Vectorization.Vector}
    */
    context.duplicar = function(){
        let novoVector = [];
        
        for( let i = 0 ; i < context.length ; i++ )
        {
            novoVector.push( context.readIndex(i) );
        }

        return Vectorization.Vector(novoVector);
    }

    //Alias for duplicar
    context.clonar = context.duplicar;


    //Alias for context.content
    context.conteudo = context.content;

    context.sizeOf = function(){
        return context.length;
    }

    context.tamanho = function(){
        return context.sizeOf();
    }

    context.push = function(element){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.content.push(element);
        context._update();
    }
    context.adicionarElemento = context.push;

    context.adicionarElementoNoInicio = function(elemento){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }
        
        context.content.unshift(elemento);
        context._update();
    }

    context.readIndex = function(i){
        return context.content[i];
    }

    /**
    * @param {Function} funcao 
    * @returns {Vectorization.Vector} - o propio Vectorization.Vector
    * 
    * CUIDADO: isso vai modificar este propio Vectorization.Vector
    */
    context.aplicarFuncao = function(funcao){
        context.substituirElementosPor(
            context.mapearValores(function(indice, elementoVetor){
                return funcao(elementoVetor, indice);
            })
        );

        return context;
    }

    context.valorMinimo = function(){
        let valoresAnalisar = context.duplicar();
        let menorValorEncontrado = valoresAnalisar.readIndex(0);

        // Verificar se o vetor não está vazio
        if (valoresAnalisar.elementos == 0) {
            throw 'Este Vectorization.Vector não tem nada dentro.';
        }

        valoresAnalisar.paraCadaElemento(function(i){
            const elemento = valoresAnalisar.readIndex(i);

            if( elemento < menorValorEncontrado )
            {
                menorValorEncontrado = elemento;
            }
        });

        return menorValorEncontrado;
    }

    context.valorMaximo = function(){
        let valoresAnalisar = context.duplicar();
        let maiorElementoEncontrado = valoresAnalisar.readIndex(0);

        // Verificar se o vetor não está vazio
        if (valoresAnalisar.elementos == 0) {
            throw 'Este Vectorization.Vector não tem nada dentro.';
        }

        valoresAnalisar.paraCadaElemento(function(i){
            const elemento = valoresAnalisar.readIndex(i);

            if( elemento > maiorElementoEncontrado )
            {
                maiorElementoEncontrado = elemento;
            }
        });

        return maiorElementoEncontrado;
    }

    context.indexOf = function(elemento, comecandoAPartirDoIndice){
        return Vectorization.Vector(context).duplicar()
        .raw().indexOf( 
            Vectorization.Scalar.isVectorizationScalar(elemento) == true ? elemento.obterValor() : elemento, 
            comecandoAPartirDoIndice);
    }

    context.sum = function(){
        let result = 0;
        for( let i = 0 ; i < context.length ; i++ )
        {   
            result = result + Number.parseFloat( context.readIndex( i ) );
        }

        return result;
    }

    context.soma = function(){
        return context.sum();
    }

    context.mean = function(){
        let sum = context.sum();
        return sum / context.length;
    }

    context.media = function(){
        return context.mean();
    }

    /**
    * Verifica se todos os elementos deste vetor são "true"
    * @returns {Boolean}
    */
    context.todosVerdadeiros = function(){
        let retorno = false;
        for( let i = 0 ; i < context.content.length ; i++ )
        {   
            if( context.content[i] == true ){
                retorno = true;
            }else{
                retorno = false;
                break;
            }
        }

        return retorno;
    }

    /**
    * Verifica se todos os elementos deste vetor são "false"
    * @returns {Boolean}
    */
    context.todosFalsos = function(){
        let retorno = false;
        for( let i = 0 ; i < context.content.length ; i++ )
        {   
            if( context.content[i] == false ){
                retorno = true;
            }else{
                retorno = false;
                break;
            }
        }

        return retorno;
    }

    /**
    * Verifica se todos os elementos deste vetor são iguais a um valor
    * @param {Number} valor - o valor
    * @returns {Boolean}
    */
    context.todosIguaisA = function(valor){
        let retorno = false;
        for( let i = 0 ; i < context.content.length ; i++ )
        {   
            if( context.content[i] == valor ){
                retorno = true;
            }else{
                retorno = false;
                break;
            }
        }

        return retorno;
    }

    /**
    * Verifica se este Vector é exatamente igual a outro Vector, no conteudo 
    */
    context.isExatamenteIgual = function(vectorB){
        let isIgual = false;

        if(!Vectorization.Vector.isVector(vectorB)){
            isIgual = false;
            return isIgual;
        }

        if( context.length != vectorB.length ){
            isIgual = false;
            return isIgual;
        }

        for( let i = 0 ; i < vectorB.length ; i++ )
        {
            const saoEscalaresOuTextos = (Vectorization.Text.isVectorizationText( vectorB.readIndex(i) ) == true && Vectorization.Text.isVectorizationText( context.readIndex(i) ) == true) == true ||
                                         (Vectorization.Scalar.isVectorizationScalar( vectorB.readIndex(i) ) == true && Vectorization.Scalar.isVectorizationScalar( context.readIndex(i) ) == true) == true;
            
            const condicao = saoEscalaresOuTextos == true ? vectorB.readIndex(i).isIgual( context.readIndex(i) )
                                                          : vectorB.readIndex(i) == context.readIndex(i);

            if( condicao == true ){
                isIgual = true;
            }else{
                isIgual = false;
                break;
            }
        }

        return isIgual;
    }

    /**
    * Permite fatiar(ou recortar) este vetor
    * @param {linhaInicial} - inicio
    * @param {linhaFinal} - final
    * @param {intervalo} - intervalo
    * @returns {Vectorization.Vector} - o vetor recortado
    */
    context.slice = function(elementoInicial, elementoFinal, intervalo=1){
        let dadosRecortados = [];

        if( elementoInicial < 0 ){
            throw 'A elementoInicial precisa ser maior ou igual a zero!';
        }

        if( elementoFinal > context.length ){
            throw 'A elementoFinal precisa estar dentro da faixa de valores do Vector! valor muito alto!';
        }

        if( intervalo <= 0 ){
            throw 'O intervalo precisa ser maior que zero!';
        }

        for( let i = elementoInicial ; i < elementoFinal ; i = i + intervalo )
        {
            dadosRecortados.push( context.readIndex(i) );
        }

        return Vectorization.Vector(dadosRecortados);
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma função de callback
    * @param {Function} callback(index, element, context)
    */
    context.forEach = function(callback){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            let ultimoEstadoRetornado = callback( i, context.content[i], context );
    
            if( ultimoEstadoRetornado instanceof Object )
            {
                ultimoEstadoRetornado.propriedadesControle = {};

                switch(ultimoEstadoRetornado.acao){
                    case 'parar':
                    case 'parar_loop':
                    case 'interromper':
                    case 'stop':
                        ultimoEstadoRetornado.propriedadesControle.vaiPararLoop = true;
                        break;

                    case 'reiniciar':
                    case 'reiniciar_loop':
                    case 'restart':
                        i = 0;
                        break;

                    case 'ir_indice':
                    case 'ir_iteracao':
                    case 'go_iteration':
                        if( ultimoEstadoRetornado.valor != undefined )
                        {
                            i = ultimoEstadoRetornado.valor;
                        }else{
                            throw 'Não é possivel ir para uma iteração sem um numero';
                        }
                        break;
                }

                //Interromper este loop
                if( ultimoEstadoRetornado.propriedadesControle.vaiPararLoop == true ){
                    break;
                }
            }
        }
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma função de callback, porém faz isso de forma contrária/revertida
    * @param {Function} callback(index, element, context)
    */
    context.paraCadaElementoReverso = function(callback, executarNoContexto=null){
        let valorComecar = context.tamanho()-1;
        let valorVaiInterromper = 0;
        let vaiParar = false;

        for( let i = valorComecar ; vaiParar == false ; i-- )
        {
            if( i > valorVaiInterromper ){
                vaiParar = false;
            }else{
                //Brecar aqui
                vaiParar = true;
            }

            if( executarNoContexto != null ){
                callback = callback.bind(executarNoContexto);
            }

            ultimoEstadoRetornado = callback(
                     //O indice
                     i, 
                     //O elemento atual
                     context.content[i],
                     //O propio contexto deste Vectorization.Vector 
                     context
                    );

            if( ultimoEstadoRetornado instanceof Object )
            {
                ultimoEstadoRetornado.propriedadesControle = {};

                switch(ultimoEstadoRetornado.acao){
                    case 'parar':
                    case 'parar_loop':
                    case 'interromper':
                    case 'stop':
                        ultimoEstadoRetornado.propriedadesControle.vaiPararLoop = true;
                        break;

                    case 'reiniciar':
                    case 'reiniciar_loop':
                    case 'restart':
                        i = 0;
                        break;

                    case 'ir_indice':
                    case 'ir_iteracao':
                    case 'go_iteration':
                        if( ultimoEstadoRetornado.valor != undefined )
                        {
                            i = ultimoEstadoRetornado.valor;
                        }else{
                            throw 'Não é possivel ir para uma iteração sem um numero';
                        }
                        break;
                }

                //Interromper este loop
                if( ultimoEstadoRetornado.propriedadesControle.vaiPararLoop == true ){
                    break;
                }
            }
        }
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma função de callback, retornando um resultado
    * @param {Function} callback(index, element, context)
    * @returns {Vectorization.Vector}
    */
    context.map = function(callback){
        let novoVetor = [];

        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = callback( i, context.content[i], context );
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma função de filtro, retornando um resultado que é filtrado de forma rígida.
    * Isso ignora elementos que não atendam aos critérios que voce estabeleceu na função de filtro
    * @param {Function} callback(index, element, context)
    * @returns {Vectorization.Vector} - um novo Vectorization.Vector
    */
    context.filtrar = function(funcaoDeFiltro, incluirDetalhes=false){
        let novoVetor = Vectorization.Vector([]);

        if(!funcaoDeFiltro){
            throw 'Voce precisa passar uma função de filtro!. Não permitido!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: context.tamanho()

        }).paraCadaElemento(function(i, element, contextoLoop){
            let checagemDoFiltro = funcaoDeFiltro( i, context.content[i], context );

            if(checagemDoFiltro == true || checagemDoFiltro == 'incluir' || checagemDoFiltro == 'manter' || checagemDoFiltro == 'keep' || checagemDoFiltro == 'ok'){
                if( incluirDetalhes == true ){
                    novoVetor.adicionarElemento({
                        valor: context.content[i],
                        indice: i,
                        parIndiceValor: [i, context.content[i]],
                        terminouExecutarFiltro: new Date().getTime(),
                        resultadoFuncaoFiltro: checagemDoFiltro,
                        context: context
                    });

                }else{
                    novoVetor.adicionarElemento( context.content[i] );
                }
            }
        });

        return Vectorization.Vector( novoVetor.valores() );
    }

    context.ignorarUndefined = function(){
        return context.filtrar(function(iAtualFiltragem, elementoAtualFiltragem){
            if( elementoAtualFiltragem != undefined && 
                elementoAtualFiltragem != null &&
                isNaN(elementoAtualFiltragem) == false
            ){
                return 'manter';
            }
        }, false);
    }

    context.ignorar = function(oElemento){
        return context.filtrar(function(iAtualFiltragem, elementoAtualFiltragem){
            if( elementoAtualFiltragem != oElemento ){
                return 'manter';
            }
        }, false);
    }
    context.ignorarOs = context.ignorar;

    context.sobrescreverConteudo = function(novoConteudoDoVetor){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.content = Vectorization.Vector.isVectorizationVector( novoConteudoDoVetor ) ? novoConteudoDoVetor.valores() : novoConteudoDoVetor;
        context.conteudo = context.content;
    }

    /**
    * Remove valores duplicados deste Vectorization.Vector com base em colunas específicas.
    */
    context.distinct = function(){
        const valoresJaVistos = {};
        const valoresUnicos = Vectorization.Vector([]);

        context.forEach(function(indice, valor){
            const identificador = String(valor);

            if( valoresJaVistos[identificador] == undefined ){
                valoresJaVistos[identificador] = true;
                valoresUnicos.push( valor );
            }
        });

        return valoresUnicos;
    }

    /**
    * Similar ao context.filtrar
    * Percorre cada elemento do vetor, aplicando uma função de filtro, retornando um resultado que é filtrado de forma rígida.
    * Isso ignora elementos que não atendam aos critérios que voce estabeleceu na função de filtro
    * 
    * CUIDADO: Este método vai sobrescrever os valores deste Vectorization.Vector
    */
    context.aplicarFiltro = function(funcaoDeFiltro){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.sobrescreverConteudo(
            Vectorization.Vector(
                context.filtrar(funcaoDeFiltro, incluirDetalhes=true)

            ).mapearValores(function(indiceAtual, valorAtual){
                //Se for um objeto retornado pela função filtrar
                if(typeof valorAtual == 'object')
                {
                    return valorAtual.valor;
                }else{
                    return valorAtual;
                }
            })
        );
    }

    //Preenche tudo com um unico valor especifico
    context.preencherTudo = function(valorEspecifico){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.paraCadaElemento(function(indicePreencher, elemento, contextoVetor){
            context.content[indicePreencher] = valorEspecifico;
        });

        return context;
    }

    /**
    * Similar ao preencherTudo, porém ele só preenche valores que atendam a certo critério simples
    * Neste caso o critério é onde o valorEspecifico apareça no indice deste Vectorization.Vector
    * Mais ele vai preencher todos os valores onde a condição bate
    * @param {any} valorEspecifico 
    * @param {any} novoValorEspecifico 
    * @returns {Vectorization.Vector}
    */
    context.preencherTudoOnde = function(valorEspecifico, novoValorEspecifico){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.paraCadaElemento(function(indicePreencher, elemento, contextoVetor){
            let valorNaPosicaoAtualDoVetor = context.readIndex(indicePreencher);

            if( String(valorNaPosicaoAtualDoVetor) == String(valorEspecifico) &&
                String(valorNaPosicaoAtualDoVetor).length == String(valorEspecifico).length
            ){
                context.definirElementoNoIndice(indicePreencher, novoValorEspecifico);
            }
        });

        return context;
    }

    /**
    * Similar ao preencherTudoOnde, só que ele vai preencher só os N primeiros
    * @param {any} valorEspecifico 
    * @param {any} novoValorEspecifico 
    * @returns {Vectorization.Vector} - o propio Vectorization.Vector
    */
    context.preencherAlgunsOnde = function(valorEspecifico, novoValorEspecifico, quantidadeLimitePreencher, direcaoOperar='esquerda'){
        let quantidadeJaPreencheu = 0;
        let valorNaPosicaoAtualDoVetor;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        switch(direcaoOperar){
            case 'esquerda':
            case 'left':
            case 'inicio':
                context.paraCadaElemento(function(indicePreencher, elemento, contextoVetor){
                    valorNaPosicaoAtualDoVetor = context.readIndex(indicePreencher);
        
                    if( String(valorNaPosicaoAtualDoVetor) == String(valorEspecifico) &&
                        String(valorNaPosicaoAtualDoVetor).length == String(valorEspecifico).length
                    ){
                        if( quantidadeJaPreencheu < quantidadeLimitePreencher ){
                            context.definirElementoNoIndice(indicePreencher, novoValorEspecifico);
                        }
        
                        quantidadeJaPreencheu++;
                    }
                });
                break;

            case 'direita':
            case 'frente':
            case 'right':
                context.paraCadaElementoReverso(function(indicePreencher, elemento, contextoVetor){
                    valorNaPosicaoAtualDoVetor = context.readIndex(indicePreencher);
        
                    if( String(valorNaPosicaoAtualDoVetor) == String(valorEspecifico) &&
                        String(valorNaPosicaoAtualDoVetor).length == String(valorEspecifico).length
                    ){
                        if( quantidadeJaPreencheu < quantidadeLimitePreencher ){
                            context.definirElementoNoIndice(indicePreencher, novoValorEspecifico);
                        }
        
                        quantidadeJaPreencheu++;
                    }
                });
                break;

            default:
                throw 'Voce precisa dizer em qual direção voce quer usar'
                break;
        }

        return context;
    }

    //Também, se o config for um objeto(NÂO FOR UM ARRAY)
    if( config instanceof Object && !(config instanceof Array && (config instanceof Array || Vectorization.Vector.isVector(config) )) ){
        context.aleatorio = config['aleatorio'] || false;
        
        if( config['aleatorio'] != undefined &&
            config['numeros'] != undefined
        ){
            throw 'Voce não pode criar um Vectorization.Vector com contéudo definido, e ao mesmo tempo sendo aleatório!';
        }

        if( context.aleatorio == true ){
            context.content = []; // Zero o conteudo

            //Se tem outros detalhes
            if( config['minimo'] != undefined && 
                config['maximo'] != undefined && 
                config['elementos'] != undefined &&
                typeof config['minimo'] == 'number' &&
                typeof config['maximo'] == 'number' &&
                typeof config['elementos'] == 'number'
            ){
                //Grava os parametros
                context.minimoAleatorio = config['minimo'];
                context.maximoAleatorio = config['maximo'];

                //Se tiver um número base
                if( config['sementeAleatoria'] != undefined &&
                    typeof config['sementeAleatoria'] == 'number'
                ){
                    context.sementeAleatoria = config['sementeAleatoria'];
                }else{
                    context.sementeAleatoria = Vectorization.Random._sementeDefinida;
                }

                //Vai gerando os valores aleatorios enquanto não terminar a quantidade de elementos
                while( context.content.length < config['elementos'] )
                {
                    let numeroAleatorioGeradoParaOIndice = Vectorization.Random.gerarNumeroAleatorio( Number(context.minimoAleatorio), Number(context.maximoAleatorio), context.sementeAleatoria );
                    context.adicionarElemento( numeroAleatorioGeradoParaOIndice );
                }

                //Se o programador quiser arredondar
                if( config['arredondar'] != undefined ){
                    switch(config['arredondar']){
                        case true:
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.round(valor);
                                }).valores()
                            );
                            break;

                        case 'cima':
                        case 'up':
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.ceil(valor);
                                }).valores()
                            );
                            break;
            
                        case 'baixo':
                        case 'down':
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.floor(valor);
                                }).valores()
                            );
                            break;

                        case 'automatico':
                        case 'auto':
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.round(valor);
                                }).valores()
                            );
                            break;
                    }
                }

            }else{
                if( typeof config['minimo'] != 'number' ||
                    typeof config['maximo'] != 'number' ||
                    typeof config['elementos'] != 'number' 
                ){
                    throw 'Os valores minimo, máximo e quantidade de elementos precisam ser números!. Tipo não permitido.'
                
                }else{
                    throw 'Para criar um Vector aleatório voce precisar passar a faixa de valores e a quantidade de elementos!';
                }
            }

            context.conteudo = context.content;
        
        //Se for um objeto, que não possui o atributo "aleatorio"
        }else if(context.aleatorio == false){
            
            if( config['numeros'] != undefined &&
                Vectorization.Vector.isVector(config['numeros'])
            ){
                if( config['aleatorio'] != undefined ){
                    throw 'Voce não pode criar um Vectorization.Vector com contéudo definido, e ao mesmo tempo sendo aleatório!';
                }

                context.content = config['numeros'] != undefined ? 
                                  (Vectorization.Vector.isVectorizationVector(config['numeros']) ? config['numeros'].valores() : 
                                   config['numeros']) : [];

                context.length = context.content.length;
                context.elementos = context.length;
            }

            context.conteudo = context.content;
        }
    }


    /**
    * Retorna os valores deste Vectorization.Vector como arredondados.
    * @param {String} tipoArredondamentoAplicar
    * @returns {Vectorization.Vector}
    */
    context.getValoresArredondados = function(tipoArredondamentoAplicar='cima'){
        let novoVetorArredondado = Vectorization.Vector( context.duplicar() );

        //Se o programador quiser arredondar
        if( tipoArredondamentoAplicar != undefined ){
            switch(tipoArredondamentoAplicar){
                case true:
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.round(valor);
                        }).valores()
                    );
                    break;

                case 'cima':
                case 'up':
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.ceil(valor);
                        }).valores()
                    );
                    break;
    
                case 'baixo':
                case 'down':
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.floor(valor);
                        }).valores()
                    );
                    break;

                case 'automatico':
                case 'auto':
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.round(valor);
                        }).valores()
                    );
                    break;

                default:
                    if(tipoArredondamentoAplicar != false){
                        throw 'Voce precisa falar que tipo de arredondamento voce quer fazer!';
                    }
                    break;
            }
        }

        return novoVetorArredondado;
    }

    /**
    * Aplica um arredondamento sobre os valores deste vetor
    * CUIDADO: isso vai sobrescrever os valores
    * 
    * @param {String} tipoArredondamentoAplicar
    * @returns {Vectorization.Vector} - o propio vetor
    */
    context.aplicarArredondamento = function(tipoArredondamentoAplicar='cima'){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.substituirElementosPor(
            context.getValoresArredondados(tipoArredondamentoAplicar)
        );

        return context;
    }

    /**
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Este propio Vectorization.Vector sobrescrito(CUIDADO!)
    */
    context.acrescentarVetor = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado : Vectorization.Vector(novoVetorASerAcrescentado); 
        let contextoEsteVetor = context;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = novoVetorASerAcrescentado_Vector.lerIndice(i);
            context.adicionarElemento(elementoVetorASerAdicionado);
        });
    }

    /**
    * Se parece muito ao context.acrescentarVetor, só que aqui, ele vai apenas retornar uma novo Vectorization.Vector, NÂO SUBSTITUI ESTE VETOR
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Um novo Vectorization.Vector
    */
    context.juntarComOutroVetor = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado : Vectorization.Vector(novoVetorASerAcrescentado); 
        let contextoEsteVetor = context;

        let novoVetorASerAcrescentado_VectorFinal = contextoEsteVetor.duplicar();

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = novoVetorASerAcrescentado_Vector.lerIndice(i);
            novoVetorASerAcrescentado_VectorFinal.adicionarElemento(elementoVetorASerAdicionado);
        });

        return novoVetorASerAcrescentado_VectorFinal;
    }

    /**
    * Se parece muito ao context.acrescentarVetor, porém ele pôem os elementos no inicio do vetor, ao invés de colocar no final do mesmo
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Este propio Vectorization.Vector sobrescrito(CUIDADO!)
    */
    context.acrescentarNoInicioVetor = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado : Vectorization.Vector(novoVetorASerAcrescentado); 
        let contextoEsteVetor = context;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: contextoEsteVetor.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = contextoEsteVetor.lerIndice(i);
            novoVetorASerAcrescentado_Vector.adicionarElemento(elementoVetorASerAdicionado);
        });

        let novoVetorASerAcrescentado_VectorFinal = Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        });

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_VectorFinal.tamanho()
        })
        .paraCadaElemento(function(i){
            novoVetorASerAcrescentado_VectorFinal[i] = novoVetorASerAcrescentado_Vector.lerIndice(i);
        });

        contextoEsteVetor.sobrescreverConteudo(
            novoVetorASerAcrescentado_VectorFinal.duplicar()
                                                 .valores()
        )
    }

    /**
    * Se parece muito ao context.acrescentarNoInicioVetor, só que aqui, ele vai apenas retornar uma novo Vectorization.Vector, NÂO SUBSTITUI ESTE VETOR
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Um novo Vectorization.Vector
    */
    context.juntarComOutroVetorNoInicio = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado.duplicar() : Vectorization.Vector(novoVetorASerAcrescentado).duplicar(); 
        let contextoEsteVetorDuplicado = context.duplicar();

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: contextoEsteVetorDuplicado.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = contextoEsteVetorDuplicado.lerIndice(i);
            novoVetorASerAcrescentado_Vector.adicionarElemento(elementoVetorASerAdicionado);
        });

        let novoVetorASerAcrescentado_VectorFinal = Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        });

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_VectorFinal.tamanho()
        })
        .paraCadaElemento(function(i){
            novoVetorASerAcrescentado_VectorFinal[i] = novoVetorASerAcrescentado_Vector.lerIndice(i);
        });

        return novoVetorASerAcrescentado_VectorFinal;
    }

    //OUTROS MÉTODOS ABAIXO

    /**
     * Produto escalar entre dois vetores
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-vetor-com-vetor
     * 
     * @param {Vectorization.Vector} vectorA 
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Scalar}
    */
    context.produtoEscalar = function(vectorB){
        let vectorA = context;

        if( vectorA.length != vectorB.length ){
            throw 'The number of elements in vector A must be exactly equal to the number of elements in vector B. Impossible to calculate!';
        }

        if( !vectorB instanceof Object ){
            throw 'vectorB must be a Object'
        }

        if( vectorB.objectName != 'Vector' ){
            throw 'vectorB must be a instance of ' + String( context.path );
        }

        //Inicializa a variavel que será usada para a soma ponderada da linha atual
        let produtoAtual = 0;
        //Percorre cada elemento do vetor B
        for( let colunaB = 0 ; colunaB < vectorB.length ; colunaB++ ){
            produtoAtual += ( vectorA.readIndex(colunaB) * vectorB.readIndex(colunaB) );
        }

        return Vectorization.Scalar(produtoAtual);
    }

    //Alias for produtoEscalar
    context.produtoEscalarVetor = context.produtoEscalar;

    /**
     * Produto escalar entre este vetor e uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-vetor-com-matriz
     * @param {Vectorization.Vector} vectorA 
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Vector}
    */
    context.produtoEscalarMatrix = function(matrixA){
        let vectorB = context.content;

        if( matrixA.rows != vectorB.length ){
            throw 'O número de linhas da matrixA deve ser exatamente igual ao numero de elementos do vetor. Impossivel calcular!';
        }
    
        let vetorResultado = [];
    
        //Percorre cada linha da matrix A
        for( let linha = 0 ; linha < matrixA.rows ; linha++ ){
    
            //Inicializa a variavel que será usada para a soma ponderada
            let produtoAtual = 0;
    
            //Percorre cada elemento do vetor B
            for( let colunaB = 0 ; colunaB < vectorB.length ; colunaB++ ){
                /*
                * Obtem os valores da linha atual da matrix A(nesse caso, a linha é na verdade a colunaB)
                * Pois, quando vamos calcular o produto escalar entre um vetor e uma matrix, acessamos os elementos de forma diferente: ao invez de acessar matrix[linha][coluna](como fazemos no produto escalar entre matrix e vetor), fazemos o contrário e acessamos matrix[coluna][linha], 
                * Ou seja, na matrix A, acessamos a coluna correspondente ao elemento atual do vetor B.
                * Ou seja, a nivel de código, na matrixA acessamos a colunaB que é o elemento atual do vetor, de modo que matrixA.content[colunaB] retornará um vetor(isto é, a variavel colunaB da matrixA), e ai em seguida nós acessamos a linha atual da matrixA, ou seja, literalmente matrixA.content[coluna][linha], e é assim que vamos fazer a soma ponderada.
                * É assim que vamos fazer a soma ponderada.
                */
                let valoresAtualMatrixNaPosicaoColunaB = matrixA.content[colunaB]; //Aqui a linha vai ser na verdade a coluna, no caso, a linha da colunaB, da matrix em questão
    
                produtoAtual += ( vectorB[colunaB] * valoresAtualMatrixNaPosicaoColunaB[linha] ); //E a coluna vai ser a linha
            }
    
            //Vai adicionando os resultados no vetor de resultado
            vetorResultado.push(produtoAtual);
        }
    
        return Vectorization.Vector(vetorResultado);
    }

    /**
     * Multiplica este vetor com outro vetor
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-vetores-elemento-a-elemento/codigo-principal.js
     * @param {Vectorization.Vector} vectorB_param
     * @returns {Vectorization.Vector}
    */
    context.multiplicarVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content;
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let vetorResultado = [];

        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }

        for( let i = 0 ; i < vectorA.length ; i++ )
        {   
            vetorResultado.push( vectorA[i] * vectorB[i] );
        }

        return Vectorization.Vector(vetorResultado);
    }

    /**
     * Multiplica este vetor por um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-vetores-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.multiplicarNumero = function(numero){
        let vetorResultado = [];
        let vectorA = context.content;

        for( let i = 0 ; i < vectorA.length ; i++ )
        {   
            vetorResultado.push( vectorA[i] * numero );
        }

        return Vectorization.Vector(vetorResultado);
    }

    /**
     * Multiplica este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.multiplicarMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] * matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Divide este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.dividirMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] / matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Faz a soma deste vetor com outro vetor
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-vetores/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.somarVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] + vectorB[i];
        }
    
        return Vectorization.Vector(novoVetor);
    }

    /**
     * Soma este vetor com um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-vetores-por-um-numero-scalar/codigo-principal.js 
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.somarNumero = function(numero){
        let novoVetor = [];
        let vectorA = context.content;

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] + numero;
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
     * Soma este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.somarMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] + matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Faz a subtração deste vetor com outro vetor
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-vetores/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.subtrairVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] - vectorB[i];
        }
    
        return Vectorization.Vector(novoVetor);
    }

    /**
     * Subtrai este vetor com um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-vetores-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.subtrairNumero = function(numero){
        let novoVetor = [];

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] - numero;
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
     * Subtrai este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.subtrairMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] - matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Faz a divisão deste vetor com outro vetor
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-vetores/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.dividirVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] / vectorB[i];
        }
    
        return Vectorization.Vector(novoVetor);
    }

    /**
     * Divide este vetor com um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-vetores-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.dividirNumero = function(numero){
        let novoVetor = [];
        let vectorA = context.content;

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] / numero;
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
     * Eleva este vetor a um número
     * 
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.elevarNumero = function(numero){
        let novoVetor = [];

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = Math.pow(vectorA[i], numero);
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Eleva este vetor a outro vetor
    * 
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.elevarVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = Math.pow(vectorA[i], vectorB[i]);
        }
    
        return Vectorization.Vector(novoVetor);
    }

    /**
     * Eleva este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.elevarMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( Math.pow(vectorB[j], matrixA[i][j]) );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Obtem o vetor oposto
    * @returns {Vectorization.Vector}
    */
    context.vetorOposto = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = context.content[i] * -1;
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Obtem o vetor absoluto
    * @returns {Vectorization.Vector}
    */
    context.abs = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = Math.abs(context.content[i]);
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Obtem o vetor absoluto
    * @returns {Vectorization.Vector}
    */
    context.absoluto = function(){
        return context.abs();
    }

    /**
    * Obtem a raiz quadrada de cada elemento do vetor
    * @returns {Vectorization.Vector}
    */
    context.sqrt = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = Math.sqrt(context.content[i]);
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Obtem o log2 de cada elemento do vetor
    * @returns {Vectorization.Vector}
    */
    context.log2 = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = Math.log2(context.content[i]);
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Obtem o log10 de cada elemento do vetor
    * @returns {Vectorization.Vector}
    */
    context.log10 = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = Math.log10(context.content[i]);
        }

        return Vectorization.Vector(novoVetor);
    }

    context.removerApenasUm = function(elementoRemover){
        let novoVectorRetirado = Vectorization.Vector([]);
        let vetorPercorrer = context.duplicar();
        let jaFoi = false;

        vetorPercorrer.paraCadaElemento(function(i, elementoVetor){
            if( jaFoi == false && elementoVetor == elementoRemover){
                jaFoi = true;

            }else{
                novoVectorRetirado.adicionarElemento(elementoVetor);
            }
        });

        novoVectorRetirado._update();
        return novoVectorRetirado;
    }

    /**
    * Ordena este Vectorization.Vector em ordem crescente
    * @returns {Vectorization.Vector} - um novo Vectorization.Vector ordenado
    */
    context.ordenarCrescente = function(){
        let novoVectorOrdenado = Vectorization.Vector([]);
        let vetorPercorrer = context.duplicar();
        let vetorTrabalhando = vetorPercorrer.duplicar();

        while( novoVectorOrdenado.elementos != vetorPercorrer.elementos )
        {
            let valorMinimoVetorTrabalhando = vetorTrabalhando.valorMinimo();
    
            let jaFoiAPrimeira = false;
            vetorTrabalhando.paraCadaElemento(function(i, elementoVetor){
                if( jaFoiAPrimeira == false && elementoVetor == valorMinimoVetorTrabalhando ){
                    novoVectorOrdenado.adicionarElemento( elementoVetor );
                    jaFoiAPrimeira = true;

                    //Vai parar o loop do elementoVetor
                    return {
                        acao: 'parar_loop'
                    }
                }
            })

            //Substitui o vetorTrabalhando
            vetorTrabalhando = vetorTrabalhando.removerApenasUm(valorMinimoVetorTrabalhando);
            jaFoiAPrimeira = false;
        }

        return novoVectorOrdenado;
    }

    /**
    * Ordena este Vectorization.Vector em ordem decrescente
    * @returns {Vectorization.Vector} - um novo Vectorization.Vector ordenado
    */
    context.ordenarDecrescente = function(){
        let novoVectorOrdenado = Vectorization.Vector([]);
        let vetorPercorrer = context.duplicar();
        let vetorTrabalhando = vetorPercorrer.duplicar();

        while( novoVectorOrdenado.elementos != vetorPercorrer.elementos )
        {
            let valorMaximoVetorTrabalhando = vetorTrabalhando.valorMaximo();
    
            let jaFoiAPrimeira = false;
            vetorTrabalhando.paraCadaElemento(function(i, elementoVetor){
                if( jaFoiAPrimeira == false && elementoVetor == valorMaximoVetorTrabalhando ){
                    novoVectorOrdenado.adicionarElemento( elementoVetor );
                    jaFoiAPrimeira = true;

                    //Vai parar o loop do elementoVetor
                    return {
                        acao: 'parar_loop'
                    }
                }
            })

            //Substitui o vetorTrabalhando
            vetorTrabalhando = vetorTrabalhando.removerApenasUm(valorMaximoVetorTrabalhando);
            jaFoiAPrimeira = false;
        }

        return novoVectorOrdenado;
    }

    /**
     * Permite dividir este Vectorization.Vector em N partes iguais.
     * @param {Number} numeroPartesDividir 
     * @returns {Vectorization.Vector} - um Vectorization.Vector de outros Vectorization.Vector(s)
     */
    context.dividirEmPartes = function(numeroPartesDividir){
        let esteVetorCopiado = context.duplicar();
        let tamanhosAproximados = Math.round( esteVetorCopiado.elementos / numeroPartesDividir );
        let ondeParou = 0;

        let listaResultadoDivisao = Vectorization.Vector({
            valorPreencher: Vectorization.Vector([]),
            elementos: numeroPartesDividir
        });

        Vectorization.Vector({
            valorPreencher: tamanhosAproximados,
            elementos: numeroPartesDividir
        }).paraCadaElemento(function(iParte, tamanhoParte){

            let quantosJaColocou = 0;
            let jaTerminouEste = false;
            
            Vectorization.Vector(esteVetorCopiado)
            .paraCadaElemento(function(iElemento){
                let elementoAtual = esteVetorCopiado.lerIndice(iElemento);
                let consideradouEsteIndice = ( (ondeParou == 0 || iElemento > ondeParou) == true && quantosJaColocou <= (tamanhoParte-1) == true) == true;
                let jaColocouTudoDaParte = (quantosJaColocou <= (tamanhoParte-1)) == false;

                if( jaTerminouEste == false && (ondeParou == 0 || iElemento > ondeParou) && quantosJaColocou <= (tamanhoParte-1) )
                {
                    listaResultadoDivisao.lerIndice(iParte)
                                         .adicionarElemento(elementoAtual);

                    ondeParou = iElemento;
                    quantosJaColocou++;
                    
                }else{
                    //Se ele pulou o indice por que ainda não começou a faixa de valores do proximo pedaço, ele ignora e não vai marcar que ja terminou
                    if( jaColocouTudoDaParte == true ){
                        jaTerminouEste = true;

                        //Vai parar o loop do iElemento
                        return {
                            acao: 'parar_loop'
                        }
                    }
                }

            });
        })

        return Vectorization.Vector(listaResultadoDivisao);
    }
    context.split = context.dividirEmPartes;

    /**
     * Verifica se este Vectorization.Vector está ordenado de forma crescente
     * @returns {Boolean}
     */
    context.isOrdenadoCrescente = function(){
        let esteVetorCopiado = context.duplicar();
        let estaOrdenado = true;
        Vectorization.Vector(esteVetorCopiado)
        .paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);
            let elementoMaisUm = esteVetorCopiado.readIndex(i+1) || NaN;
            let elementoMenosUm = esteVetorCopiado.readIndex(i-1) || NaN;

            if( elementoMaisUm < elementoAtual || elementoMenosUm > elementoAtual ){
                estaOrdenado = false;

                return {
                    acao: 'parar_loop'
                }
            }
        });

        return estaOrdenado;
    }

    /**
     * Verifica se este Vectorization.Vector está ordenado de forma decrescente
     * @returns {Boolean}
     */
    context.isOrdenadoDecrescente = function(){
        let esteVetorCopiado = context.duplicar();
        let estaOrdenado = true;
        Vectorization.Vector(esteVetorCopiado)
        .paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);
            let elementoMaisUm = esteVetorCopiado.readIndex(i+1) || NaN;
            let elementoMenosUm = esteVetorCopiado.readIndex(i-1) || NaN;

            if( elementoMaisUm > elementoAtual || elementoMenosUm < elementoAtual ){
                estaOrdenado = false;

                return {
                    acao: 'parar_loop'
                }
            }
        });

        return estaOrdenado;
    }

    /**
     * Verifica se este Vectorization.Vector está ordenado de forma crescente ou então decrescente
     * @returns {Boolean}
     */
    context.isOrdenado = function(){
        return (context.isOrdenadoCrescente() || context.isOrdenadoDecrescente());
    }
    context.estaOrdenado = context.isOrdenado;
    context.estiverOrdenado = context.estaOrdenado;
    context.estiverOrdenadoCrescente = context.isOrdenadoCrescente;

    context.primeiroItem = function(){
        return context.lerIndice(0);
    }

    context.ultimoItem = function(){
        return context.lerIndice(context.elementos - 1) + 0;
    }

    context.segundoItem = function(){
        return context.lerIndice(1);
    }
    context.terceiroItem = function(){
        return context.lerIndice(2);
    }
    context.quartoItem = function(){
        return context.lerIndice(3);
    }
    context.quintoItem = function(){
        return context.lerIndice(4);
    }
    context.sextoItem = function(){
        return context.lerIndice(5);
    }
    context.setimoItem = function(){
        return context.lerIndice(6);
    }
    context.oitavoItem = function(){
        return context.lerIndice(7);
    }
    context.nonoItem = function(){
        return context.lerIndice(8);
    }
    context.decimoItem = function(){
        return context.lerIndice(9);
    }

    /**
    * @param {Number} numeroQuerendoPesquisar 
    * @returns {Object}
    */
    context.pesquisaBinaria = function(numeroQuerendoPesquisar, naoChecarOrdenacao=false){
        let resultado = {
            encontrou: false,
            indiceAchou: -1
        };

        if( naoChecarOrdenacao == true || context.estiverOrdenadoCrescente() )
        {
            let esteVetorCopiado = context.duplicar();
            let esteVetor_dividido = esteVetorCopiado.dividirEmPartes(2);
            let tamanhoEsteVetor = esteVetorCopiado.elementos;
            let tamanhoEsteVetor_pelaMetade = Math.round( tamanhoEsteVetor/2 );

            let parte1 = esteVetor_dividido.primeiroItem(),
                parte2 = esteVetor_dividido.segundoItem();

            if( numeroQuerendoPesquisar >= esteVetorCopiado.lerIndice(tamanhoEsteVetor_pelaMetade) ){
                resultado.indiceAchou = parte2.indiceDe(numeroQuerendoPesquisar);
                resultado.encontrou = resultado.indiceAchou > -1 ? true : false;

            }else{
                resultado.indiceAchou = parte1.indiceDe(numeroQuerendoPesquisar);
                resultado.encontrou = resultado.indiceAchou > -1 ? true : false;
            }   

        }else{
            throw 'Você precisa ordenar primeiro em ordem crescente!';
        }

        return resultado;
    }

    /**
    * Vai percorrer cada elemento deste Vectorization.Vector, visando localizar elementos que aparecem mais de uma vez.
    * E com isso, ele vai remover tais repetições de elementos, retornando um novo Vectorization.Vector que não contenha duplicidade. 
    */
    context.valoresUnicos = function(){
        const esteVetorCopiado = context.duplicar();
        const jaFoi = {};
        
        let novoVetor_sem_repeticoes = Vectorization.Vector([]);

        esteVetorCopiado.paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);

            if( jaFoi[ elementoAtual ] == undefined )
            {
                novoVetor_sem_repeticoes.adicionarElemento(elementoAtual);
                jaFoi[ elementoAtual ] = true;
            }
        });

        return novoVetor_sem_repeticoes;
    }

    /**
    * Conta quantas vezes um elemento em questão apareceu dentro deste Vectorization.Vector
    */
    context.contarFrequenciaElemento = function(elementoEmQuestao='nenhumElemento'){
        let quantidade = 0;
        if( elementoEmQuestao == 'nenhumElemento' ){
            throw 'Voce precisa passar um elemento!';
        }

        context.paraCadaElemento(function(iii){
            const elementoAtual = context.lerIndice(iii);
            if( elementoAtual == elementoEmQuestao )
            {
                quantidade = quantidade + 1;
            }
        });

        return quantidade;
    }

    /**
     * Sub-classe auxiliar, para uso interno
     * Possui uma estrutura personalizada para armazenar frequencias
     * @param { Object{contextVinculado:Vectorization.Vector, calcular:Vectorization.Vector||Array} } dadosFrequencias
     * @returns {Vectorization.Vector.FrequenciaComputada}
     */
    Vectorization.Vector.FrequenciaComputada = function(dadosFrequencias){
        let dadosFrequencias_Obj = {};
        let dadosProcurar = [];

        let contextPropioVector = null;
        if( !Vectorization.Vector.isVector(dadosFrequencias) ){
            dadosFrequencias_Obj = {... dadosFrequencias};
            contextPropioVector = dadosFrequencias_Obj.contextVinculado;
            dadosProcurar = dadosFrequencias_Obj.calcular;

            if( dadosProcurar == null || dadosProcurar == undefined ){
                throw 'Voce precisa informar o calcular';
            }

            if( contextPropioVector == null || contextPropioVector == undefined ){
                throw 'Voce precisa informar o contexto do Vectorization.Vector';
            }   
        }

        let informacoesCopiadas = Vectorization.Base(dadosFrequencias_Obj);
        let context_informacoesCopiadas = informacoesCopiadas;
        context_informacoesCopiadas.tabelaFrequencias = {};

        context_informacoesCopiadas.path = 'Vectorization.Vector.FrequenciaComputada';
        context_informacoesCopiadas.namespace = 'window.Vectorization';
        context_informacoesCopiadas.dadosProcurar = dadosProcurar;

        //Permite adicionar ao frequencias_Vector um elemento a ser contado
        informacoesCopiadas.adicionarInformacao = function(conteudo, quantidade=undefined){
            if(quantidade == undefined || quantidade == null){
                quantidade = context_informacoesCopiadas.contextVinculado.contarFrequenciaElemento(conteudo);
            }

            //Cadastra a quantidade informada(ou identificada)
            context_informacoesCopiadas.tabelaFrequencias[ conteudo ] = quantidade;
        }

        informacoesCopiadas.obterContagens = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.dados = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.obter = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.mostrar = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.raw = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.maisAparece = function(){
            let contagens = informacoesCopiadas.obterContagens();
            let maiorValorPresente = Vectorization.Vector( Object.values( contagens ) ).valorMaximo();
            let valoresIndexados = Vectorization.Vector( Object.keys( contagens ).map( function(numero){return Number(numero)} ) );
            let maisAparece = contagens[ Object.keys( contagens )[0] ];

            valoresIndexados.paraCadaElemento(function(iii){
                const nomeIndice = valoresIndexados.lerIndice(iii);
                const quantidadeElementoEmQuestao = contagens[ nomeIndice ];

                if( quantidadeElementoEmQuestao == maiorValorPresente ){
                    maisAparece = nomeIndice;

                    return {
                        acao: 'parar_loop'
                    }
                }
            });

            return maisAparece;
        }

        //Nao precisa ser apenas um
        informacoesCopiadas.menosAparece = function(){
            let contagens = informacoesCopiadas.obterContagens();
            let menorValorPresente = Vectorization.Vector( Object.values( contagens ) ).valorMinimo();
            let valoresIndexados = Vectorization.Vector( Object.keys( contagens ).map( function(numero){return Number(numero)} ) );
            let menosAparece = contagens[ Object.keys( contagens )[0] ];

            valoresIndexados.paraCadaElemento(function(iii){
                const nomeIndice = valoresIndexados.lerIndice(iii);
                const quantidadeElementoEmQuestao = contagens[ nomeIndice ];

                if( quantidadeElementoEmQuestao == menorValorPresente ){
                    menosAparece = nomeIndice;

                    return {
                        acao: 'parar_loop'
                    }
                }
            });

            return menosAparece;
        }

        informacoesCopiadas.atualizarContagem = function(novosDadosProcurar=null){
            context_informacoesCopiadas.tabelaFrequencias = {};

            if(novosDadosProcurar != null){
                informacoesCopiadas.dadosProcurar = novosDadosProcurar;
                informacoesCopiadas.calcular = novosDadosProcurar;
            }

            if( Vectorization.Vector.isVector(informacoesCopiadas.dadosProcurar) && !Vectorization.Vector.isVectorizationVector(informacoesCopiadas.dadosProcurar) ){
                Vectorization.Vector(informacoesCopiadas.dadosProcurar).paraCadaElemento(function(ii, elementoAtualSublaco, contextoEsteDadosProcurar){
                    const elementoAtual = contextoEsteDadosProcurar.lerIndice(ii);
                    informacoesCopiadas.adicionarInformacao(elementoAtual.obterValor(), null);
                });
    
            }else if(Vectorization.Vector.isVectorizationVector(informacoesCopiadas.dadosProcurar) == true){
                informacoesCopiadas.dadosProcurar.paraCadaElemento(function(ii, elementoAtualSublaco, contextoEsteDadosProcurar){
                    const elementoAtual = contextoEsteDadosProcurar.lerIndice(ii);
                    informacoesCopiadas.adicionarInformacao(elementoAtual.obterValor(), null);
                });
            }
        }

        informacoesCopiadas.atualizarContagem();
        return informacoesCopiadas;
    }

    /**
    * Vai percorrer cada elemento deste Vectorization.Vector, visando contabilizar a quantia de cada elemento que aparece. 
    * Ou seja, a quantidade de cada elemento, caso haja repetiçoes. Similar a um histograma
    */
    context.contabilizarFrequencias = function(valoresBrutos=false){
        let frequenciaComputada = Vectorization.Vector.FrequenciaComputada({
            contextVinculado: context,
            calcular: context.duplicar().valores()
        });

        return valoresBrutos == true ? frequenciaComputada.obterContagens() : frequenciaComputada;
    }

    /**
    * Vai percorrer cada elemento deste Vectorization.Vector, visando contabilizar a quantia de cada elemento que aparece. 
    * Ou seja, a quantidade de cada elemento, caso haja repetiçoes. Similar a um histograma
    * Similar ao context.contabilizarFrequencias
    * porém este contabiliza apenas valores especificos
    * @param {Vectorization.Vector} valoresAnalisar
    */
    context.contabilizarFrequenciasValores = function(valoresAnalisar){
        let frequenciaComputada = Vectorization.Vector.FrequenciaComputada({
            contextVinculado: context,
            calcular: valoresAnalisar
        });

        return frequenciaComputada;
    }

    /**
    * Calcula a correlação deste Vectorization.Vector com a de outro Vectorization.Vector
    */
    context.correlationWith = function( outroVector ){
        return Vectorization.Math.correlation( Vectorization.Vector(context.raw()), outroVector );
    }

    /**
    * Calcula as diferenças com os valores anteriores:
    * 
    * Para cada número no Vector, vai subtrair ele com um número anterior(ou melhor dizendo com o número cujo índice seja "indiceNumero - quantidadeElementosAtraz", caso exista. Se não existir, ele coloca um valor inválido. 
    * Voce pode incluir um parâmetro adicional que permite fazer uma subtração acumulada 
    * 
    * Por exemplo:
    *   V.Vector([10,5,2,50,9]).diferencaValores(1).raw()
    * 
    *      Ele vai retornar: [NaN, -5, -3, 48, -41]
    * 
    * Então, ele vai fazer:
    *   10 - NADA = NADA
    *   5 - 10 = -5
    *   2 - 5 =  -3
    *   50 - 2 = 48
    *   9 - 50 = -41
    * 
    *   NOTA: Ou seja, resultando nesse vetor [NaN, -5, -3, 48, -41]
    * 
    * @param {number} quantidadeElementosAtraz
    * @param {string} acumulacao
    * 
    * @returns {Vectorization.Vector}
    */
    context.diferencaValores = function( quantidadeElementosAtraz, acumulacao="nenhuma" ){
        if( !quantidadeElementosAtraz ){
            throw 'Voce precisa dizer quantos elementos atraz de cada elemento voce quer usar!';
        }

        let vetorResultado = Vectorization.Vector([]);

        context.forEach(function(indiceAtual, valorAtual, contextoEste){

            const indiceAnterior = indiceAtual - Number(quantidadeElementosAtraz);
            const valorAnterior  = context.lerIndice( indiceAnterior );

            if( valorAnterior != undefined ) {
                const subtracaoFeita   = valorAtual - valorAnterior;
                const subtracaoTratada = context.usarEscalares == true ? Vectorization.Scalar(subtracaoFeita) : subtracaoFeita;

                vetorResultado.adicionarElemento( subtracaoTratada );

            //Caso não exista
            }else{
                vetorResultado.adicionarElemento( context.usarEscalares == true ? Vectorization.Scalar( NaN ) : NaN );
            }

        });

        return vetorResultado;
    }

    /**
    * Subfatiar este Vector em varias partes, cada uma com uma CERTA QUANTIDADE FIXA DE ELEMENTOS
    *  
    * Agrupa sequencialmente os números, de acordo com O TAMANHO DA FATIA , por exemplo, se for uma fatia de 7 números, então, ele vai dividir o Vector em subgrupos, cada um tendo 7 números cada.
    * Ou seja, o Vector seria dividido de 7 em 7 números. Ou seja, cada fatia teria 7 números.
    * 
    * NOTA: Cada parte vai ser um novo Vectorization.Vector, contendo números dentro. 
    * 
    * @param {Number} tamanhoFatia - O tamanho das fatias(quantidade de números por fatia)
    * @param {Number} iniciarEm - O indice que ele vai iniciar o fatiamento
    * 
    * Exemplo:
    *   V.Vector([5, 10, 5, 6]).subfatiar(2).soma().raw()
    *       vai retornar: [15, 11]
    *  
    *   o uso do Envelope permite fazer operações mais facilmente.
    * 
    * @returns { Vectorization.Envelope }
    */
    context.subfatiar = function( tamanhoFatia, iniciarEm=0 ){
        if(!tamanhoFatia){
            throw 'Voce precisa definir uma quantidade de números para as fatias!';
        }
        if( tamanhoFatia > context.length ){
            console.warn(`O tamanho de fatia ${tamanhoFatia} é maior do que a quantidade de números deste Vector`);
        }

        let fatiasFeitas = [];
        let indiceFinalFatia = (tamanhoFatia - iniciarEm);;

        for( let indiceAtual = iniciarEm ; indiceAtual < context.length ; indiceAtual += tamanhoFatia ){

            const sliceAtual = context.clonar()
                                      .slice( indiceAtual, indiceFinalFatia );

            indiceFinalFatia = indiceFinalFatia + tamanhoFatia;

            fatiasFeitas.push( sliceAtual );
        }

        return Vectorization.Envelope(fatiasFeitas);
    }
    
    /**
    * Concatena dois Vector(s), retornando um novo Vector contendo a junção desses dois.
    * @param {Vectorization.Vector} outroVector 
    * @returns {Vectorization.Vector}
    */
    context.concat = function( outroVector ){
        return Vectorization.Vector( context.raw().concat( Vectorization.Vector.isVectorizationVector( outroVector ) ? outroVector.raw() : outroVector ), context.classConfig );
    }

    /**
    * Cria varias "áreas deslizantes". Cada área vai ter <N> números.
    * Pode ser usado para calcular médias móveis, desvio padrão movel, variancia movel, etc. 
    * 
    * Em outras palavras, O método 'deslizes' serve para gerar vários deslizes por assim dizer, ou seja, vai deslizando os elementos deste Vector, gerando outros sub Vetores com uma mesma quantidade fixa de elementos, cada parte contendo seu slice atual da posição atual ATÈ a posição atual MAIS O TAMANHO DO PEDAÇO. 
    * O método retorna um objeto Envelope.
    * 
    * @returns {Vectorization.Envelope}
    */
    context.deslizes = function( quantidadeDeslizes=4, iniciarEm=0 ){
        let deslizesProntos = Vectorization.Envelope([]);

        if( String(quantidadeDeslizes).indexOf('.') != -1 ){
            throw `O parametro quantidadeDeslizes tem valor '${quantidadeDeslizes}', porém ele precisa ser inteiro!. `;
        }

        if( iniciarEm < 0 ){
            throw `O parametro 'iniciarEm' tem valor ${ iniciarEm }. Porém, ele precisa ser positivo!`;
        }

        if( quantidadeDeslizes < 0 ){
            throw `O parametro 'quantidadeDeslizes' tem valor ${ quantidadeDeslizes }. Porém, ele precisa ser positivo!`;
        }

        if( quantidadeDeslizes == 0 ){
            throw `O parametro 'quantidadeDeslizes' tem valor ${ quantidadeDeslizes }. Porém, ele precisa ser maior que zero!`;
        }

        //Preenche com zeros nos deslizes iniciais
        let primeiroPosicaoQueVaiTerInicio = context.clonar().slice(0, quantidadeDeslizes);
        let posicaoAtualDoInicio = 1;

        for( let i = 0 ; i < primeiroPosicaoQueVaiTerInicio.length-1 ; i++ ){
            let valoresColocarNessaIteracao = primeiroPosicaoQueVaiTerInicio.slice( 0, posicaoAtualDoInicio );
            posicaoAtualDoInicio++;

            let quantosFaltamNessaIteracao = Math.abs( valoresColocarNessaIteracao.raw().length - quantidadeDeslizes );

            let arrayPreencher = Vectorization.Vector( Array( quantosFaltamNessaIteracao ).fill(0) ).concat( valoresColocarNessaIteracao );

            /* 
            NOTAS DE DESENVOLVIMENTO 02/01/2025

            TODO: Identificar quantos faltam para interar a quantidade de 'quantidadeDeslizes'
            TODO: Ir preenchendo a direita os números que faltam
            TODO EXEMPLO:
            [
                [0, 0, 0, 1]
                [0, 0, 0, 2]
                [0, 0, 0, 3]
                [1, 2, 3, 4]
                [2, 3, 4, 5]
                [3, 4, 5, 6]
                [4, 5, 6, 7]
                [5, 6, 7, 8]
                [6, 7, 8, 9]
                [7, 8, 9, 10]
                [8, 9, 10, 11]
                [9, 10, 11, 12]
                [10, 11, 12, 13]
            ]
            
            BUGS:

                AO INVEZ DE SER [0, 0, 0, 1]
                                [0, 0, 0, 2]
                                [0, 0, 0, 3]
                                [.... etc]

                PRECISARIA SER:
                            [0, 0, 0, 1]
                            [0, 0, 1, 2]
                            [0, 1, 2, 3]
                            [.... etc]
            */
            //arrayPreencher.definirElementoNoIndice( primeiroPosicaoQueVaiTerJanela.length-1, primeiroPosicaoQueVaiTerJanela[ 0+i ] );
            
            deslizesProntos.adicionarObjeto( arrayPreencher );
        }

        //Continua para os "delizes" que vão estar completos(que não vão faltar nenhuma amostra)
        for( let i = iniciarEm ; i < context.length ; i++ ){

            //Se a proxima iteração for ultrapassar os limites deste Vector, interompe, pois ja terminou
            if( i + quantidadeDeslizes > context.length ){
                break;
            }

            const sliceAtual = context.clonar()
                                      .slice( i, i + quantidadeDeslizes );

            deslizesProntos.adicionarObjeto( sliceAtual );
        }

        return deslizesProntos;
    }

    /**
    * Calcula a variancia dos números.
    * Baseado em conceitos matemáticos de estatística.
    * 
    * Isso é, mede o quanto os números do Vector estão se afastando da média.
    * Quanto menor o valor, mais perto da média os números desse Vector estão.
    * @returns {Number} - a variancia
    */
    context.variancia = function(){

        /**
        * A média aritmética normal mesmo 
        */
        const mediaVetor = context.media();

        const diferencasAoQuadrado = Vectorization.Vector([]);

        /**
        * Para cada número dentro deste Vector 
        */
        context.paraCadaElemento(function( indiceElemento, numeroAtual ){

            const subtracao = numeroAtual - mediaVetor;

            /**
            * Adiciona a subtração atual no vetor 'diferencasAoQuadrado'
            */
            diferencasAoQuadrado.adicionarElemento( Math.pow(subtracao, 2 ) );

        });

        const qtdeElementosVetor = context.tamanho();
        const variancia          = diferencasAoQuadrado.soma() / ( qtdeElementosVetor-1 );

        return variancia;
    }

    /**
    * Calcula o desvio padrão.
    * Baseado nos conceitos estatísticos de variância.
    * 
    * Desvio padrão significa o quanto os números do Vector estão se afastando da média.
    * Quanto menor o valor, mais perto da média os números desse Vector estão.
    * 
    * NOTA: Muito semelhante à variancia. É basicamente uma maneira diferente de ver a variancia. 
    */
    context.desvioPadrao = function(){
        return Math.sqrt( context.variancia() );
    }

    /**
    * Método que converte este Vectorization.Vector para um Vectorization.Vector avançado, onde cada elemento dentro do mesmo é um Vectorization.Scalar
    */
    context._vectorElementos2Escalares = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            context.content[i] = Vectorization.Scalar(context.content[i], extraPropsOfLine);
        }
    }

    if( context.configRecebidaUsuario['usarEscalares'] != undefined || classConfig['usarEscalares'] != undefined ){
        if( context.configRecebidaUsuario['usarEscalares'] == true || classConfig['usarEscalares'] == true )
        {
            context.usarEscalares = true;
            context._vectorElementos2Escalares();
        }
    }

    context._doDefaultBaseAfterCreate();

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //Aplica arredondamentos, se o usuario desejar, mesmo não sendo um Vectorization.Vector aleatorio
    if( context._config != undefined &&
        (
            context._config['aleatorio'] == undefined || context._config['aleatorio'] == false
        ) == true && 
        (
            context._config['arredondar'] != undefined ||
            context.configRecebidaUsuario['arredondar'] != undefined
        ) == true
    ){
        context.aplicarArredondamento(
            context._config['arredondar'] != undefined ? context._config['arredondar'] : context.configRecebidaUsuario['arredondar'] 
        );
    }

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    context.bloqueado = (config['bloqueado'] != undefined || classConfig['bloqueado'] != undefined) ? (config['bloqueado'] || classConfig['bloqueado']) : false;

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    if( context._isBloqueado() == true ){
        context.bloquearModificacoes();
    }

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se tiver uma função a ser aplicada por cima de tudo
    if( config['funcaoAplicar'] != undefined || classConfig['funcaoAplicar'] != undefined ){
        context.aplicarFuncao( config['funcaoAplicar'] || classConfig['funcaoAplicar'] );
    }

    //return context;
    //Cria um Proxy para permitir acessar os indices do vetor diretamente
    return new Proxy(context, {
        get: function(target, prop, receiver) {
          if (typeof prop === 'string' && !isNaN(prop)) {
            return target.content[Number(prop)];
          }
          return Reflect.get(target, prop, receiver);
        },

        set: function(target, prop, value) {
          //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'Você não pode modificar esta atributo do Vectorization.Vector!';
          }

          if (typeof prop === 'string' && !isNaN(prop)) {
            target.content[Number(prop)] = value;
            return true;
          }
          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Vector.isVector = function(obj){
    if( obj == undefined ){ return false };
    return ((obj.objectName != undefined && obj.objectName == 'Vector') || 
           Array.isArray(obj)) ? true : false;
}

window.Vectorization.Vector.isVectorizationVector = function(obj){
    if( obj == undefined ){ return false };
    return (obj.objectName != undefined && obj.objectName == 'Vector')
}

module.exports = window.Vectorization.Vector;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Vector.js*/
/* ARQUIVO VECTORIZATION: ../src/Vector-translation.js*/
/*
 * File Name: Vector-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Vector._translations = function(){
    const translatedMethods = {
        //English
        "dotProduct": "produtoEscalar",

        "dotProductMatrix": "produtoEscalarMatrix",

        "dotProductVector": "produtoEscalarVector",

        "multiplyMatrix": "multiplicarMatrix",

        "multiplyNumber": "multiplicarNumero",

        "multiplyVector": "multiplicarVetor",

        "addMatrix": "somarMatrix",

        "addNumber": "somarNumero",

        "addVector": "somarVetor",

        "subtractMatrix": "subtrairMatrix",

        "subtractNumber": "subtrairNumero",

        "subtractVector": "subtrairVetor",

        "divideMatrix": "dividirMatrix",

        "divideNumber": "dividirNumero",

        "divideVector": "dividirVetor",

        "powMatrix": "elevarMatrix",

        "powNumber": "elevarNumero",

        "powVector": "elevarVetor",

        "transposed": "tranposta",

        "oppostMatrix": "matrixOposta",

        "identity": "identidade",

        "filter": "filtrar",

        "blockModifications": "bloquearModificacoes",
        "unblockModifications": "desbloquearModificacoes",

        "findMin": "valorMinimo",
        "findMax": "valorMaximo",
        "sortAscending": "ordenarCrescente",
        "sortDescending": "ordenarDecrescente",
        "mapFunction": "aplicarFuncao",
        "unicalValues": "valoresUnicos",

        //Portugues
        "somarMatriz": "somarMatrix",
        "subtrairMatriz": "subtrairMatrix",
        "multiplicarMatriz": "multiplicarMatrix",
        "elevarMatriz": "elevarMatrix",
        "produtoEscalarMatriz": "produtoEscalarMatrix",
        
        "paraCadaElemento": "forEach",
        "adicionarElemento": "push",
        "mapearValores": "map",
        "filtrarValores": "filtrar",
        "lerIndice": "readIndex",
        "getIndice": "readIndex",
        "bloquear": "bloquearModificacoes",
        "desbloquear": "desbloquearModificacoes",
        "indiceDe": "indexOf",
        "encontrarIndiceDe": "indexOf",
        "encontrarIndice": "indexOf",
        "ordemCrescente": "ordenarCrescente",
        "ordemDecrescente": "ordenarDecrescente",
        "isOrdemCrescente": "isOrdenadoCrescente",
        "isOrdemDecrescente": "isOrdenadoDecrescente"
    };

    const translatedAttributes = {
        //English
        "blocked": "bloqueado",
        "allowBlock": "permitirBloquear",
        "allowUnblock": "permitirDesbloquear",
        "mapUsingFunction": "funcaoAplicar",

        //Portugues
        "valorPreencher": "fillValue",
        "elementos": "length",
        "conteudo": "numeros"
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Vector._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Vector-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/StringVector.js*/
/*
 * File Name: StringVector.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    require('./Root'); 
    require('./Scalar');
    require('./Vector');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringVector = function( config=[], classConfig={} ){
    //Por padrão o usarEscalares vai ser true
    if( config['usarTextos'] == undefined && classConfig['usarTextos'] == undefined && config['usarTextos'] != false && classConfig['usarTextos'] != false ){
        config['usarTextos'] = true;
    }
    
    //Define a tradução
    classConfig['translations'] = window.Vectorization.StringVector._translations || null;

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Este Vectorization.StringVector NÂO usa números, em vez disso, ele é especifico pra texto
    classConfig['usarEscalares'] = false;

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.StringVector.isStringVector(config) && config.objectName == 'StringVector' ){
        return Vectorization.StringVector( config.values() );
    }

    //O StringVector será baseado no Vectorization.Vector
    let context = window.Vectorization.Vector(config, classConfig);
    context.objectName = 'StringVector';
    context.extendedFrom = 'Vector';
    context.path = 'Vectorization.StringVector';
    context.configRecebidaUsuario = config;

    context.letrasMaiusculas = function(){
        let novoStringVector = Vectorization.StringVector([]);
        let contextoMetodo = this instanceof Window ? context : this; 
        
        //Usei o this acima pois isso permite herdar este código em outro objeto
        contextoMetodo.paraCadaElemento(function(i){
            novoStringVector.adicionarElemento( contextoMetodo.lerIndice(i).letrasMaiusculas() );
        });

        return novoStringVector;
    }
    context.toUpperCase = context.letrasMaiusculas;


    context.letrasMinusculas = function(){
        let novoStringVector = Vectorization.StringVector([]);
        let contextoMetodo = this instanceof Window ? context : this; 

        //Usei o this acima pois isso permite herdar este código em outro objeto
        contextoMetodo.paraCadaElemento(function(i){
            novoStringVector.adicionarElemento( contextoMetodo.lerIndice(i).letrasMinusculas() );
        });

        return novoStringVector;
    }
    context.toLowerCase = context.letrasMinusculas;

    
    /**
     * Retorna um Vectorization.Vector, contendo as distancias hamming de cada elemento Vectorizaion.Text
     * @param {Vectorization.StringVector} outroStringVector 
     * @returns {Vectorization.Vector}
     */
    context.distanciaPalavras = function(outroStringVector){
        let distancias = Vectorization.Vector([]);
        let contextoMetodo = this instanceof Window ? context : this; 

        //Usei o this acima pois isso permite herdar este código em outro objeto
        contextoMetodo.paraCadaElemento(function(i){
            let elementoAtual_esteStringVector = contextoMetodo.lerIndice(i),
                elementoAtual_outroStringVector = ( Vectorization.StringVector.isVectorizationStringVector(outroStringVector) == false ? Vectorization.StringVector(outroStringVector) : outroStringVector ).lerIndice(i);

            if( elementoAtual_outroStringVector != undefined ){
                let distanciaElementoIndiceAtual = Vectorization.Text(elementoAtual_esteStringVector)
                                                  .distanciaHamming( Vectorization.Text(elementoAtual_outroStringVector) )
                
                distancias.adicionarElemento( distanciaElementoIndiceAtual );

            }else{
                distancias.adicionarElemento( 1 );
            }
        });

        return distancias;
    }

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    /**
    * Método que converte este Vectorization.StringVector para um Vectorization.StringVector avançado, onde cada elemento dentro do mesmo é um Vectorization.Text
    */
    context._vectorElementos2Textos = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            context.content[i] = Vectorization.Text(context.content[i], extraPropsOfLine);
        }
    }

    /**
    * @override
    * @returns {Array}
    */
    context.toArray = function(){
        if( context.usarTextos != undefined && context.usarTextos == true )
        {
            let valoresSemEstarEmTextos = [];
            context.paraCadaElemento(function(i, objetoTexto){
                valoresSemEstarEmTextos.push( objetoTexto.obterValor() );
            });

            return valoresSemEstarEmTextos;

        }else{
            return context.content;
        }
    }
    /**
    * @override
    * @returns {Array}
    */
    context.raw = context.toArray;

    if( context.configRecebidaUsuario['usarTextos'] != undefined || classConfig['usarTextos'] != undefined ){
        if( context.configRecebidaUsuario['usarTextos'] == true || classConfig['usarTextos'] == true )
        {
            context.usarTextos = true;
            context._vectorElementos2Textos();
        }
    }

    //Se tiver uma função a ser aplicada por cima de tudo
    if( config['funcaoAplicar'] != undefined || classConfig['funcaoAplicar'] != undefined ){
        context.aplicarFuncao( config['funcaoAplicar'] || classConfig['funcaoAplicar'] );
    }

    return context;
};

/**
* Métodos estáticos
*/
window.Vectorization.StringVector.isStringVector = function(obj){
    return ((obj.objectName != undefined && (obj.objectName == 'StringVector' || obj.objectName == 'Vector')) || 
           Array.isArray(obj)) ? true : false;
}

window.Vectorization.StringVector.isVectorizationStringVector = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'StringVector' )
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringVector.js*/
/* ARQUIVO VECTORIZATION: ../src/StringVector-translation.js*/
/*
 * File Name: StringVector-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringVector._translations = function(){
    const translatedMethods = {
        
    };

    const translatedAttributes = {
        
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.StringVector._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringVector-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/BendableVector.js*/
/*
 * File Name: BendableVector.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    require('./Root'); 
    require('./Scalar');
    require('./Vector');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.BendableVector = function( config=[], classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.BendableVector._translations || null;

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Este Vectorization.BendableVector NÂO usa números, em vez disso, vamos especificar o que queremos
    classConfig['usarEscalares'] = false;

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.BendableVector.isVectorizationBendableVector(config) && config.objectName == 'BendableVector' ){
        return Vectorization.BendableVector( config.values(), classConfig );
    }

    //O StringVector será baseado no Vectorization.Vector
    let context = window.Vectorization.Vector(config, classConfig);
    context.objectName = 'BendableVector';
    context.extendedFrom = 'Vector';
    context.path = 'Vectorization.BendableVector';
    context.configRecebidaUsuario = config;
    
    context.storedClassConfig = classConfig || {};

    context.flexibilidade = classConfig['flexibilidade'] || false;

    //Mais opções de flexibilidade
    if( context.flexibilidade != undefined )
    {
        //Se for apenas um texto, com o nome do tipo, ele trata isso aqui
        if( typeof context.flexibilidade == 'string' ){
            context.flexibilidade = [ context.flexibilidade ];
        }

        //Se o usuario passar um array contendo apenas um elemento, ele vai usar ele como tipo para todos os elementos deste Vectorization.BendableVector
        if( context.flexibilidade instanceof Array && context.flexibilidade.length == 1 && context.content.length > 1 )
        {
            
            for( let i = 0 ; i < context.content.length-1 ; i++ )
            {
                //Completa com o tipo que veio
                context.flexibilidade.push(context.flexibilidade[0]);
            }

        }
    }

    if( context.flexibilidade ){
        if( context.flexibilidade.length != context.content.length ){
            throw 'o array flexibilidade precisa conter a mesma quantidade de elementos deste Vectorization.Vector'
        }
    }

    if( context.flexibilidade ){
        //Verifica se todos são do tipo Vectorization.Text
        context.isTudoTexto = Vectorization.StringVector( Vectorization.isAlgumVetorVectorization(context.flexibilidade) ? [... context.flexibilidade.raw()] : [... context.flexibilidade] ).todosIguaisA('Text');
        
    }else{
        context.isTudoTexto = null;
    }

    //Se for tudo texto
    if( context.isTudoTexto == true ){
        context.herdarFuncoes( Vectorization.StringVector );
    }

    context.toText = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.StringVector( context.raw(), novasConfiguracoes);
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        novasConfiguracoes['usarEscalares'] = true;

        return Vectorization.Vector( context.raw(), novasConfiguracoes );
    }

    /**
    * @override
    * @param {Boolean} includeNamespace 
    * @returns {Array}
    */
    context.obterTiposRapido = function(includeNamespace=false){
        let tiposUsados = [];
        context.paraCadaElemento(function(i, elementoAtual){
            if( includeNamespace == true ){
                tiposUsados.push( 'Vectorization.' + String(elementoAtual.objectName) );

            }else{
                tiposUsados.push( String(elementoAtual.objectName) );
            }
        });

        return tiposUsados;
    }

    /**
    * @override 
    */
    context.rawProfundo = function(){
        
        if( (elementoAtual) => Vectorization.Scalar.isScalar(elementoAtual) == true || 
                               Vectorization.Text.isText(elementoAtual) == true ||
                               Vectorization.Boolean.isBoolean(elementoAtual) == true 
                            
        ){
            let valoresSemEstarEmEscalar = [];
            context.paraCadaElemento(function(i, objetoEscalar){

                if( Vectorization.Scalar.isScalar(objetoEscalar) || 
                    Vectorization.Text.isText(objetoEscalar) ||
                    Vectorization.Boolean.isBoolean(objetoEscalar) 

                ){
                    if( objetoEscalar.obterValor != undefined )
                    {
                        valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );

                    }else{
                        valoresSemEstarEmEscalar.push( objetoEscalar );
                    }

                }else{
                    valoresSemEstarEmEscalar.push( objetoEscalar );
                }
            });

            return valoresSemEstarEmEscalar;

        }else{
            return context.content;
        }

    }

    /**
    * @override
    * Permite fatiar(ou recortar) este vetor
    * @param {linhaInicial} - inicio
    * @param {linhaFinal} - final
    * @param {intervalo} - intervalo
    * @returns {Vectorization.Vector} - o vetor recortado
    */
    context.slice = function(elementoInicial, elementoFinal, intervalo=1){
        let dadosRecortados = [];

        if( elementoInicial < 0 ){
            throw 'A elementoInicial precisa ser maior ou igual a zero!';
        }

        if( elementoFinal > context.length ){
            throw 'A elementoFinal precisa estar dentro da faixa de valores do Vector! valor muito alto!';
        }

        if( intervalo <= 0 ){
            throw 'O intervalo precisa ser maior que zero!';
        }

        let quantosForam = 0;
        for( let i = elementoInicial ; i < elementoFinal ; i = i + intervalo )
        {
            dadosRecortados.push( context.readIndex(i) );
            quantosForam = quantosForam + 1;
        }

        let quantidadeFalta = Math.abs(dadosRecortados.length - context.flexibilidade.length);
        let flexibilidadeAjustada = [... context.flexibilidade];

        if( context.flexibilidade.length < quantidadeFalta ){
            for( let i = 0 ; i < quantidadeFalta ; i++ ){
                //Completa com um tipo de dado qualquer
                flexibilidadeAjustada.push('texto');
            }
        }

        let novoVetorCriado = Vectorization.BendableVector(dadosRecortados, {
            flexibilidade: flexibilidadeAjustada
        } );

        return novoVetorCriado;
    }

    /**
    * @override
    * Obtem um novo Vector exatamente igual a este Vector
    * Ou seja, faz uma copia do propio objeto, identido, porém sem manter as referencias. 
    * @returns {Vectorization.Vector}
    */
    context.duplicar = function(){
        let novoVector = [];
        
        for( let i = 0 ; i < context.length ; i++ )
        {
            novoVector.push( context.readIndex(i) );
        }

        //Pra ser compativel com este Vectorization.BendableVector
        let extraPropsOfLine = {};
        if( context.flexibilidade ){
            extraPropsOfLine['flexibilidade'] = context.flexibilidade;
        }

        return Vectorization.BendableVector(novoVector, extraPropsOfLine);
    }

    /**
    * @override
    * Vai percorrer cada elemento deste Vectorization.Vector, visando localizar elementos que aparecem mais de uma vez.
    * E com isso, ele vai remover tais repetições de elementos, retornando um novo Vectorization.Vector que não contenha duplicidade. 
    * @returns {Vectorization.BendableVector} 
    */
    context.valoresUnicos = function(){
        const esteVetorCopiado = context.duplicar();
        const jaFoi = {};
        
        //Pra ser compativel com este Vectorization.BendableVector
        let extraPropsOfLine = {};
        //if( context.flexibilidade ){
        //    extraPropsOfLine['flexibilidade'] = context.flexibilidade;
        //}

        let novoVetor_sem_repeticoes = Vectorization.BendableVector([], extraPropsOfLine);

        esteVetorCopiado.paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);

            if( jaFoi[ elementoAtual ] == undefined )
            {
                novoVetor_sem_repeticoes.adicionarElemento(elementoAtual);
                jaFoi[ elementoAtual ] = true;
            }
        });

        return novoVetor_sem_repeticoes;
    }

    //Alias for duplicar
    context.clonar = context.duplicar;

    /**
    * Método que converte este Vectorization.Vector para um Vectorization.Vector avançado, onde não importa qual o tipo de valor usado
    */
    context._vectorElementos2Flexibilidade = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};

            //context.content[i] = 'vamos identificar abaixo';
            switch( Vectorization.isAlgumValorVectorization( context.flexibilidade[i] ) ? context.flexibilidade[i].raw() : context.flexibilidade[i] ){
                case 'Escalar':
                case 'Scalar':
                case 'Number':
                case 'Numero':
                case 'numero':
                case 'escalar':
                    context.content[i] = Vectorization.Scalar(context.content[i], extraPropsOfLine);
                    break;

                case 'texto':
                case 'Texto':
                case 'Text':
                case 'String':
                case 'Letras':
                    context.content[i] = Vectorization.Text(context.content[i], extraPropsOfLine);
                    break;

                case 'booleano':
                case 'Booleano':
                case 'Boolean':
                case 'boolean':
                case 'Logico':
                    context.content[i] = Vectorization.Boolean(context.content[i], extraPropsOfLine);
                    break;

                default:
                    throw 'Tipo não aceito';
            }
        }
    }

    context._vectorElementos2Flexibilidade();

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //Se tiver uma função a ser aplicada por cima de tudo
    if( config['funcaoAplicar'] != undefined || classConfig['funcaoAplicar'] != undefined ){
        context.aplicarFuncao( config['funcaoAplicar'] || classConfig['funcaoAplicar'] );
    }

    return context;
};

/**
* Métodos estáticos
*/
window.Vectorization.BendableVector.isBendableVector = function(obj){
    if( obj == undefined ){ return false };
    return ((obj.objectName != undefined && (obj.objectName == 'BendableVector' || obj.objectName == 'Vector')) || 
           Array.isArray(obj)) ? true : false;
}

window.Vectorization.BendableVector.isVectorizationBendableVector = function(obj){
    if( obj == undefined ){ return false };
    return (obj.objectName != undefined && obj.objectName == 'BendableVector' )
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/BendableVector.js*/
/* ARQUIVO VECTORIZATION: ../src/BendableVector-translation.js*/
/**
 * File Name: BendableVector-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.BendableVector._translations = function(){
    const translatedMethods = {
        
    };

    const translatedAttributes = {
        
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.BendableVector._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/BendableVector-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Matrix.js*/
/*
 * File Name: Matrix.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    require('./Root');
    require('./Scalar');
    require('./Vector');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Matrix = function( config, classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Matrix._translations || null;

    let classeBaseMatrix = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseMatrix.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar uma matrix a partir de outra matrix, ele recria a propio matrix passada, mantendo a estrutura como ainda sendo uma Matrix
    if( Vectorization.Matrix.isMatrix(config) && config.objectName == 'Matrix' ){
        return Vectorization.Matrix( config.raw() );
    }

    let context = window.Vectorization.Base(classConfig);
    context.objectName = 'Matrix';
    context.path = 'Vectorization.Matrix';
    
    context.configRecebidaUsuario = config;

    context.storedClassConfig = classConfig || {};

    //Aplica a tradução dos atributos, pra ser capaz de entender nomes de atributos em outros idiomas
    //classConfig = context.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Aplica a tradução dos atributos também no config, EXCETO SE config FOR UM ARRAY
    if( config instanceof Object && !(config instanceof Array && (config[0] instanceof Array || Vectorization.Vector.isVector(config[0]) || Vectorization.BendableVector.isVectorizationBendableVector(config[0]) )) ){
        config = context.translateAttributes_andReturn(config, classConfig['translations']() );
    }


    context.rows = config['rows'];
    context.columns = config['columns'];
    context.initialColumnValue = config['fillValue'] || 0;
    context.flexivel = config['flexibilidade'] || classConfig['flexibilidade'] || null;

    //Mais opções de flexibilidade
    if( context.flexivel != undefined && 
        config.length > 0 && 
        config[0] != undefined 
    ){
        //Se for apenas um texto, com o nome do tipo, ele trata isso aqui
        if( typeof context.flexivel == 'string' ){
            context.flexivel = [ context.flexivel ];
        }

        //Se o usuario passar um array contendo apenas um elemento, ele vai usar ele como tipo para todos os elementos deste Vectorization.BendableVector
        if( context.flexivel instanceof Array && context.flexivel.length == 1 && config[0].length > 1 )
        {
            
            for( let i = 0 ; i < config[0].length-1 ; i++ )
            {
                //Completa com o tipo que veio
                context.flexivel.push(context.flexivel[0]);
            }

        }
    }

    context.isFlexivelNasColunas = context.flexivel != undefined && context.flexivel != null ? true : false;

    context.content = [];

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

            if(context.isAdvancedMatrix == true)
            {
                //Bloquear também os filhos Vectorization.Vector dentro deste Vectorization.Matrix
                context.paraCadaLinha(function(i, elementoVetorLinhaMatrix){
                    elementoVetorLinhaMatrix.bloquearModificacoes();
                });
            }

        }else{
            throw 'Ação não permitida para este Vectorization.Matrix!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;

            if(context.isAdvancedMatrix == true)
            {
                //Desbloquear também os filhos Vectorization.Vector dentro deste Vectorization.Matrix
                context.paraCadaLinha(function(i, elementoVetorLinhaMatrix){
                    elementoVetorLinhaMatrix.desbloquearModificacoes();
                });
            }
        }else{
            throw 'Ação não permitida para este Vectorization.Matrix!';
        }
    }

    /**
    * Atualiza a quantidade de linhas e colunas
    */
    context.atualizarQuantidadeColunasLinhas = function(){
        //Atualiza a quantidade das colunas
        context.columns = context.calcTamanhos().lerIndice(1);
        context.colunas = context.columns;

        //Atualiza a quantidade de linhas
        context.rows    = context.content.length; 
        context.linhas  = context.rows;
    }

    //Alguns atributos uteis
    context.isTransposta = classConfig['isTransposta'] || false;
    context.isOposta = classConfig['isOposta'] || false;
    context.isIdentidade = classConfig['isIdentidade'] || false;
    context.isAdvancedMatrix = classConfig['advanced'] || true;

    if( classConfig['advanced'] == false ){
        context.isAdvancedMatrix = false;
    }

    //Se passar diretamente o conteudo
    if( config instanceof Array && (config[0] instanceof Array || Vectorization.Vector.isVector(config[0]) || Vectorization.BendableVector.isVectorizationBendableVector(config[0]) ) ){

        //Se as linhas forem vetores do pacote Vectorization
        if( Vectorization.Vector.isVectorizationVector( config[0] ) == true ||
            Vectorization.BendableVector.isVectorizationBendableVector( config[0] ) == true
        ){
            context.content = config;
            context.rows = config.length;
            context.columns = config[0].length;

        //Se as linhas forem vetores normais
        }else{
            context.content = config;
            context.rows = config.length;
            context.columns = config[0].length;
        }

    //Ou caso contrario
    }else{
        //Inicializa a matrix
        for( let i = 0 ; i < context.rows ; i++ )
        {
            context.content[i] = [];
            for( let j = 0 ; j < context.columns ; j++ )
            {
                context.content[i][j] = context.initialColumnValue;
            }
        }

        /**
        * 25/07/2024 16:55 PM
        *  BUG CORRIGIDO:
        *    se o objeto for uma lista de objetos Vectorization.Vector, da certo
        *    AGORA se o objeto for um Vectorization.Vector que contem outros Vectorization.Vector
        *    dava erro na linha 251
        */
        //Se a matrix nao foi inicializada E SE FOR UM VETOR DO VECTORIZATION QUE CONTEM OUTROS VETORES DO VECTORIZATION
        if( context.rows == undefined && Vectorization.Vector.isVectorizationVector(config) ){
            context.content = config.raw();
            context.rows = config.length;
            context.columns = config.lerIndice(0).length;
        }
    }


    //Também, se o config for um objeto(NÂO FOR UM ARRAY)
    if( config instanceof Object && !(config instanceof Array && (config instanceof Array || Vectorization.Vector.isVector(config) )) ){
        context.aleatorio = config['aleatorio'] || false;

        if( config['aleatorio'] != undefined &&
            config['numeros'] != undefined
        ){
            throw 'Voce não pode criar um Vectorization.Matrix com contéudo definido, e ao mesmo tempo sendo aleatório!';
        }
        
        if( context.aleatorio == true ){
            context.content = []; // Zero o conteudo

            //Se tem outros detalhes
            if( config['minimo'] != undefined && 
                config['maximo'] != undefined && 
                config['linhas'] != undefined &&
                config['colunas'] != undefined &&
                typeof config['minimo'] == 'number' &&
                typeof config['maximo'] == 'number' &&
                typeof context.rows == 'number' &&
                typeof context.columns == 'number'
            ){
                //Grava os parametros
                context.minimoAleatorio = config['minimo'];
                context.maximoAleatorio = config['maximo'];

                //Se tiver um número base
                if( config['sementeAleatoria'] != undefined &&
                    typeof config['sementeAleatoria'] == 'number'
                ){
                    context.sementeAleatoria = config['sementeAleatoria'];
                }else{
                    context.sementeAleatoria = Vectorization.Random._sementeDefinida;
                }

                //Vai gerando os valores aleatorios enquanto não terminar a quantidade de elementos
                Vectorization.Vector({
                    valorPreencher: 1,
                    elementos: context.rows

                }).paraCadaElemento(function(iLinhaMatrix, linhaMatrix){
                    let objLinhaMatrix = linhaMatrix;
                    context.content[iLinhaMatrix] = [];

                    Vectorization.Vector({
                        valorPreencher: 1,
                        elementos: context.columns

                    }).paraCadaElemento(function(jColunaMatrix, colunaMatrix){
                        let objColunaMatrix = colunaMatrix;
                        
                        let numeroAleatorioGeradoParaOIndice = Vectorization.Random.gerarNumeroAleatorio( Number(context.minimoAleatorio), Number(context.maximoAleatorio), context.sementeAleatoria );
                        context.content[iLinhaMatrix][jColunaMatrix] = numeroAleatorioGeradoParaOIndice;
                    });
                });

                //Se o programador quiser arredondar
                if( config['arredondar'] != undefined ){
                    Vectorization.Vector({
                        valorPreencher: 1,
                        elementos: context.rows
    
                    }).paraCadaElemento(function(iLinhaMatrix, linhaMatrix){
                        let objLinhaMatrix = context.content[iLinhaMatrix];

                        if( Vectorization.Vector.isVector(objLinhaMatrix) &&
                            Vectorization.Vector.isVectorizationVector(objLinhaMatrix)
                        ){
                           objLinhaMatrix.aplicarArredondamento(config['arredondar']);

                        }else{
                            if( Vectorization.Vector.isVector(objLinhaMatrix) )
                            {
                                let valoresObtidos = Vectorization.Vector(objLinhaMatrix).getValoresArredondados(config['arredondar']);
                                
                                for( let i = 0 ; i < valoresObtidos.tamanho() ; i++ )
                                {
                                    objLinhaMatrix[i] = valoresObtidos.readIndex(i);
                                }
                            }
                        }
                    });
                }

            }else{
                if( typeof config['minimo'] != 'number' ||
                    typeof config['maximo'] != 'number' ||
                    typeof context.rows != 'number' || 
                    typeof context.columns != 'number'
                ){
                    throw 'Os valores minimo, máximo e quantidade de elementos das linhas e colunas precisam ser números!. Tipo não permitido.'
                
                }else{
                    throw 'Para criar uma Matrix aleatório voce precisar passar a faixa de valores e a quantidade de elementos nas linhas e colunas!';
                }
            }

        }else if(context.aleatorio == false){
        
            if( config['numeros'] != undefined &&
                Vectorization.Vector.isVector(config['numeros'])
            ){
                if( config['aleatorio'] != undefined ){
                    throw 'Voce não pode criar um Vectorization.Matrix com contéudo definido, e ao mesmo tempo sendo aleatório!';
                }

                context.content = config['numeros'] != undefined ? 
                                  (Vectorization.Matrix.isVectorizationMatrix(config['numeros']) ? config['numeros'].valores() : 
                                   config['numeros']) : [];
            }

            context.conteudo = context.content;

            if( config['numeros'] != undefined )
            {
                context.rows = config['numeros'].length;
                context.columns = config['numeros'][0].length;

            }else{
                context.rows = context.content.length;
                
                if( context.content[0] != undefined ){
                    context.columns = context.content[0].length;
                }else{
                    context.columns = 0;
                }
            }
        }
    }


    //Alias em portugues
    context.linhas = context.rows;
    context.colunas = context.columns;
    context.conteudo = context.content;

    //Uma matriz simples nunca vai ser profunda
    context.matrixProfunda = false;

    /**
    * Método que converte a matrix para uma matrix avançada, onde cada linha é um Vector 
    */
    context._matrix2Advanced = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            extraPropsOfLine['index'] = i;
            extraPropsOfLine['_pai']  = context; 

            if( context.isFlexivelNasColunas == true ){
                if( Vectorization.Vector.isVector(context.flexivel) ){
                    extraPropsOfLine['flexibilidade'] = [... context.flexivel];

                }else{
                    extraPropsOfLine['flexibilidade'] = context.flexivel;
                }

                context.content[i] = Vectorization.BendableVector(context.content[i], extraPropsOfLine);

            }else{
                context.content[i] = Vectorization.Vector(context.content[i], extraPropsOfLine);
            }

        }
        context.isAdvancedMatrix = true;
    }

    context.adicionarVetorComoColuna = function(vectorAdicionar){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        if( context.isAdvancedMatrix ){
            if( context.isFlexivelNasColunas == false ){
                context.content.push( vectorAdicionar );

            }else{
                context.content.push( vectorAdicionar );
            }

        }else{
            if( context.isFlexivelNasColunas == false ){
                context.content.push( vectorAdicionar );

            }else{
                context.content.push( vectorAdicionar );
            }
        }

        if( context.content != undefined ){
            context.rows = context.content.length;
        }

        if( context.content != undefined && 
            context.columns[0] != undefined
        ){
            context.columns = context.columns[0].length;
        }
    }

    /**
    * Obtem uma nova matriz exatamente igual a esta matrix.
    * Ou seja, faz um copia do propio objeto, identico, porém sem manter as referencias. 
    * @returns {Vectorization.Matrix}
    */
    context.duplicar = function(){
        let novaMatrix = [];
        let novaMatrix_Matrix = null; //Se for necessario

        if( context.isFlexivelNasColunas == true ){
            //Nesse caso foi necessario usar o novaMatrix_Matrix como Vectorization.Matrix
            novaMatrix_Matrix = Vectorization.Matrix([], {
                flexibilidade: context.flexivel
            });
        }

        for( let i = 0 ; i < context.rows ; i++ )
        {
            if( context.isFlexivelNasColunas == false ){
                novaMatrix.push( Vectorization.Vector(context.getLinha(i)).clonar() );

            }else{
                novaMatrix_Matrix.adicionarVetorComoColuna( Vectorization.BendableVector(context.getLinha(i), {
                    flexibilidade: context.flexivel
                }).clonar() );
            }
        }

        return context.isFlexivelNasColunas == false ? Vectorization.Matrix(novaMatrix) : 
                                                       novaMatrix_Matrix;
    }

    //Alias for duplicar
    context.clonar = context.duplicar;

    /**
    * Calcula a forma (shape) da matrix
    * @returns {Array} - A forma da matrix.
    */
    context.calcTamanhos = function() {
        let dadosMatrix = context.content || [];
        let formato = [];
        let nivelAtual = [... dadosMatrix.copyWithin()];

        while ( Vectorization.Vector.isVector(nivelAtual) ) 
        {
            formato.push(nivelAtual.length);
            nivelAtual = nivelAtual[0];
            if(nivelAtual == undefined){
                break;
            }
        }

        return Vectorization.Vector(formato);
    }

    //Alias for calcTamanhos
    context.calcSizes = context.calcTamanhos;
    context.calcShape = context.calcTamanhos;
    context.calcFormato = context.calcTamanhos;
    context.getFormato = context.calcTamanhos;

    /*
    Calcula o formato da matrix e armazena no objeto sizes
    Por padrão o formato vai ser [qtdeLinhas, qtdeColunas]
    */
    context.sizes = context.calcTamanhos();
    context.formato = context.sizes;

    context.tamanho = function(){
        return context.sizes;
    }

    /**
    * Verifica se esta matrix possui exatamente o mesmo formato de outra matrix
    * @param {Vectorization.Matrix} matrixB - A outra matrix.
    * @returns {Boolean} - Verdadeiro se as formas forem iguais, falso caso contrário.
    */
    context.isExatoMesmoTamanho = function(matrixB){
        if( context.calcTamanhos().isExatamenteIgual( matrixB.calcTamanhos() ) ){
            return true;
        }

        return false;
    }

    //Alias for isExatoMesmoTamanho
    context.isExatamenteMesmoTamanho = context.isExatoMesmoTamanho;
    context.isExatamenteMesmoFormato = context.isExatoMesmoTamanho;
    context.isMesmoTamanhoDe = context.isExatoMesmoTamanho;
    context.isMesmoFormatoDe = context.isExatoMesmoTamanho;
    context.isSameSizes = context.isExatoMesmoTamanho;

    /**
    * Compara se o contéudo desta matrix é exatamente igual ao contéudo da outra matrix  
    * Ele faz isso comparando linha por linha.
    * @param {Vectorization.Matrix} matrixB - A outra matrix
    * @returns {Boolean} - Se o contéudo é exatamente igual ou não
    */
    context.isExatamenteMesmoConteudo = function(matrixB){
        //Verifica se cada linha da matrixB é exatamente igual a linha correspondende da matrix atual
        const mappedVector = Vectorization.Vector( context.map(function(i, valor, selfContext){
            const linhaAtual = i;
            return matrixB.getLinha(linhaAtual).isExatamenteIgual( context.getLinha(linhaAtual) );
        }) );

        //Verifica os resultados de mappedMatrix, se todos são verdadeiros
        return mappedVector.todosVerdadeiros();
    }

    /**
    * Compara se esta matrix é exatamente igual a outra matrix, tanto em formato quanto em contéudo
    * @param {Vectorization.Matrix} matrixB - A outra matrix
    * @returns {Boolean} - Se são iguais ou não
    */
    context.isIgual = function(matrixB){
        return (context.isExatamenteMesmoTamanho(matrixB) == true && 
                context.isExatamenteMesmoConteudo(matrixB) == true);
    }

    //Alias for isIgual
    context.isEquals = context.isIgual;

    context.valueOf = function(){
        return context.content;
    }

    context.toString = function(){
        return String(context.content);
    }

    context.get = function(linha, coluna){
        return context.content[linha][coluna];
    }

    context.getLinha = function(linha){
        return context.content[linha];
    }

    //Alias for getLinha
    context.getLine = context.getLinha;

    context.values = function(){
        return context.content;
    }

    context.rawProfundo = function(){
        let rawValues = [];

        for( let i = 0 ; i < context.rows ; i++ )
        {
            rawValues[i] = context.content[i].rawProfundo();
        }

        return rawValues;
    }

    context.rawValues = function(){
        let rawValues = [];

        //Se for um Vectorization.Matrix com essa opcao especifica ativa, usa por padrao o profundo
        if( context.isFlexivelNasColunas == true ){
            return context.rawProfundo();
        }

        for( let i = 0 ; i < context.rows ; i++ )
        {
            rawValues[i] = context.content[i].values();
        }

        return rawValues;
    }

    context.raw = function(){
        return context.rawValues();
    }

    /**
    * Verifica se algum elemento está presente nesta Vectorization.Matrix
    * @param {Object} valor 
    * @returns {Boolean}
    */
    context.have = function( valor ){
        let tem = false;

        for( let i = 0 ; i < context.rows ; i++ ){
            if( (context.getLinha( i ).have || context.getLinha( i ).includes)( valor ) ){
                tem = true;
                break;
            }
        }

        return tem;
    }

    context.mostrarTabela = function(){
        console.table( context.rawValues() );
    }

    context.mostrar = function(){
        console.log( context.rawValues() );
    }

    context.push = function(element){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        if( context.isAdvancedMatrix ){
            if( context.isFlexivelNasColunas == true ){
                context.content.push( element.objectName != undefined && element.objectName == 'Vector' ? element : Vectorization.BendableVector(element, context._config) );

            //Se não tem flexibilidade
            }else{
                context.content.push( element.objectName != undefined && element.objectName == 'Vector' ? element : Vectorization.Vector(element) );
            }

        }else{
            context.content.push(element);
        }

        //Atualiza a quantidade de linhas e colunas
        context.atualizarQuantidadeColunasLinhas();
    }

    context.obterTiposRapido = function(includeNamespace=false){
        let tiposUsados = [];
        context.paraCadaLinha(function(i, elementoAtual){
            tiposUsados.push( elementoAtual.obterTiposRapido(includeNamespace) );
        });

        return tiposUsados;
    }

    context.identificarTiposColuna = function(numeroColuna){
        const resultado = Vectorization.Base({
            tipos: Vectorization.Vector([], {usarEscalares: false})
        });

        context.percorrerColuna(numeroColuna, function(iColuna, valorColuna){
            resultado.tipos.adicionarElemento( window.Vectorization.identificarTipo( valorColuna ) );
        });

        resultado.tiposUnicos = resultado.tipos.valoresUnicos();
        resultado.raw = function(){
            return resultado.tipos.raw();
        }

        return resultado;
    }
    context.getTiposColuna = context.identificarTiposColuna;
    context.obterTiposColuna = context.identificarTiposColuna;

    /**
    * Permite fatiar(ou recortar) a matrix
    * @param {linhaInicial} - inicio
    * @param {linhaFinal} - final
    * @param {intervalo} - intervalo
    * @returns {Vectorization.Matrix} - a matriz recortada
    */
    context.slice = function(linhaInicial, linhaFinal, intervalo=1){
        let dadosRecortados = [];

        if( linhaInicial < 0 ){
            throw 'A linhaInicial precisa ser maior ou igual a zero!';
        }

        if( linhaFinal > context.rows ){
            throw 'A linhaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        if( intervalo <= 0 ){
            throw 'O intervalo precisa ser maior que zero!';
        }

        for( let i = linhaInicial ; i < linhaFinal ; i = i + intervalo )
        {
            dadosRecortados.push( context.getLinha(i).raw() );
        }

        if( context.flexibilidade ){
            return Vectorization.Matrix(dadosRecortados, {
                flexibilidade: context.flexibilidade || []
            });
        }

        return Vectorization.Matrix(dadosRecortados);
    }

    context.recortarLinhas = context.slice;
    context.sliceLinhas = context.slice;

    /**
     * Similar ao context.slice, porém executado nas colunas
     * @param {Number} colunaInicial 
     * @param {Number} colunaFinal 
     * @param {Number} intervaloLinhas 
     * @param {Number} intervaloColunas 
     * @returns {Vectorization.Matrix}
     */
    context.recortarColunas = function(colunaInicial, colunaFinal='nao_definida', intervaloLinhas=1, intervaloColunas=1){
        let dadosRecortados = [];

        if( colunaFinal == 'nao_definida' ){
            colunaFinal = context.columns + 1;
        }

        if( colunaInicial < 0 ){
            throw 'A colunaInicial precisa ser maior ou igual a zero!';
        }

        if( colunaFinal > context.rows ){
            throw 'A colunaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        for( let i = 0 ; i < context.rows ; i = i + intervaloLinhas )
        {
            dadosRecortados[ i ] = context.getLinha(i)
                                          .slice( colunaInicial, colunaFinal, intervaloColunas );
        }

        return Vectorization.Matrix(dadosRecortados);
    }

    /**
     * Similar ao context.slice, porém executado nas colunas
     * @param {Number} colunaInicial 
     * @param {Number} colunaFinal 
     * @param {Number} intervaloLinhas 
     * @param {Number} intervaloColunas 
     * @returns {Vectorization.Matrix}
     */
    context.sliceColunas = context.recortarColunas;

    /**
     * Similar ao context.slice, porém executado nas linhas e também nas colunas
     * @param {Number} linhaInicial 
     * @param {Number} linhaFinal 
     * @param {Number} colunaInicial 
     * @param {Number} colunaFinal 
     * @param {Number} intervaloLinhas 
     * @param {Number} intervaloColunas 
     * @returns {Vectorization.Matrix}
     */
    context.recortarRegiao = function(linhaInicial, linhaFinal, colunaInicial, colunaFinal='nao_definida', intervaloLinhas=1, intervaloColunas=1){
        let dadosRecortados = [];

        if( linhaInicial < 0 ){
            throw 'A linhaInicial precisa ser maior ou igual a zero!';
        }

        if( linhaFinal > context.rows ){
            throw 'A linhaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        if( colunaFinal == 'nao_definida' ){
            colunaFinal = context.columns + 1;
        }

        if( colunaInicial < 0 ){
            throw 'A colunaInicial precisa ser maior ou igual a zero!';
        }

        if( colunaFinal > context.rows ){
            throw 'A colunaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        for( let i = linhaInicial ; i < linhaFinal ; i = i + intervaloLinhas )
        {
            dadosRecortados[ i ] = context.getLinha(i)
                                          .slice( colunaInicial, colunaFinal, intervaloColunas );
        }

        return Vectorization.Matrix(dadosRecortados);
    }

    /**
    * Similar ao context.slice, porém executado nas linhas e também nas colunas
    * @param {Number} linhaInicial 
    * @param {Number} linhaFinal 
    * @param {Number} colunaInicial 
    * @param {Number} colunaFinal 
    * @param {Number} intervaloLinhas 
    * @param {Number} intervaloColunas 
    * @returns {Vectorization.Matrix}
    */
    context.slice2 = context.recortarRegiao;

    /**
    * Permite extrair valores de uma coluna especifica
    * @param {Number} indiceColuna - o indice da coluna que queremos extrair os valores
    * @returns {Vectorization.Vector || Array}
    */
    context.extrairValoresColuna = function(indiceColuna){
        let valoresColuna = [];
        for( let i = 0 ; i < context.rows ; i++ )
        {
            valoresColuna.push( Vectorization.Vector(context.getLinha(i)).readIndex(indiceColuna) );
        }

        if( context.isAdvancedMatrix ){
            if( context.isFlexivelNasColunas == true ){
                let extraPropsOfLine = {};

                //Cada coluna pode ter o seu
                if( Vectorization.Text.isText( valoresColuna[0] ) ){
                    extraPropsOfLine['flexibilidade'] = Vectorization.Vector({
                        usarEscalares: false,
                        valorPreencher: 'Texto',
                        elementos: valoresColuna.length
                    });

                }else if( Vectorization.Scalar.isScalar( valoresColuna[0] ) ){
                    extraPropsOfLine['flexibilidade'] = Vectorization.Vector({
                        usarEscalares: false,
                        valorPreencher: 'Numero',
                        elementos: valoresColuna.length
                    });
                }

                return Vectorization.BendableVector( valoresColuna, extraPropsOfLine );

            }else if (context.isFlexivelNasColunas == false ){
                return Vectorization.Vector( valoresColuna );
            }

        }else{
            return valoresColuna;
        }
    }

    /**
    * Subfatiar esta matriz em varias partes, cada uma com uma CERTA QUANTIDADE FIXA DE AMOSTRAS
    *  
    * Agrupa sequencialmente amostras, de acordo com O TAMANHO DA FATIA , por exemplo, se for uma fatia de 7 amostras, então, ele vai dividir o dataset em subgrupos, cada um tendo 7 amostras cada.
    * Ou seja, o dataset seria dividido de 7 em 7 amostras. Ou seja, cada fatia teria 7 amostras.
    * 
    * NOTA: Cada parte vai ser uma nova Vectorization.Matrix, contendo Vectorization.Vector(s) dentro. Ou seja, cada Vectorization.Vector dentro dessa matrix resultado, vai ser uma amostra.
    * 
    * @param {Number} tamanhoFatia - O tamanho das fatias(quantidade de amostras por fatia)
    * @param {Number} iniciarEm - O indice que ele vai iniciar o fatiamento
    * 
    * @returns { Vectorization.Envelope }
    */
    context.subfatiar = function( tamanhoFatia, iniciarEm=0 ){
        if(!tamanhoFatia){
            throw 'Voce precisa definir uma quantidade de amostras para as fatias!';
        }
        if( tamanhoFatia > context.linhas ){
            console.warn(`O tamanho de fatia ${tamanhoFatia} é maior do que a quantidade de linhas da matrix`);
        }

        let fatiasFeitas = [];
        let indiceFinalFatia = (tamanhoFatia - iniciarEm);

        for( let indiceAtual = iniciarEm ; indiceAtual < context.linhas ; indiceAtual += tamanhoFatia ){

            const sliceAtual = context.clonar()
                                      .slice( indiceAtual, indiceFinalFatia );

            indiceFinalFatia = indiceFinalFatia + tamanhoFatia;

            fatiasFeitas.push( sliceAtual );
        }

        return Vectorization.Envelope(fatiasFeitas);
    }

    /**
    * Concatena duas matrizes 
    */
    context.concat = function( outraMatrix ){
        let matrixAtualArray = context.clonar();

        outraMatrix.paraCadaLinha(function(indiceLinha, vetorDaLinha){
            matrixAtualArray.push( vetorDaLinha );
        });

        return matrixAtualArray;
    }

    /**
    * Cria varias "áreas deslizantes". Cada área vai ter <N> números.
    * Pode ser usado para calcular médias móveis, desvio padrão movel, variancia movel, etc. 
    * 
    * Em outras palavras, O método 'deslizes' serve para gerar vários deslizes por assim dizer, ou seja, vai deslizando as linhas desta Matrix, gerando outras sub Matrizes com uma mesma quantidade fixa de linhas, cada parte contendo seu slice atual da posição atual ATÈ a posição atual MAIS O TAMANHO DO PEDAÇO. 
    * O método retorna um objeto Envelope.
    * 
    * @returns {Vectorization.Envelope}
    */
    context.deslizes = function( quantidadeDeslizes=4, iniciarEm=0 ){
        let deslizesProntos = Vectorization.Envelope([]);

        if( String(quantidadeDeslizes).indexOf('.') != -1 ){
            throw `O parametro quantidadeDeslizes tem valor '${quantidadeDeslizes}', porém ele precisa ser inteiro!. `;
        }

        if( iniciarEm < 0 ){
            throw `O parametro 'iniciarEm' tem valor ${ iniciarEm }. Porém, ele precisa ser positivo!`;
        }

        if( quantidadeDeslizes < 0 ){
            throw `O parametro 'quantidadeDeslizes' tem valor ${ quantidadeDeslizes }. Porém, ele precisa ser positivo!`;
        }

        if( quantidadeDeslizes == 0 ){
            throw `O parametro 'quantidadeDeslizes' tem valor ${ quantidadeDeslizes }. Porém, ele precisa ser maior que zero!`;
        }

        //Preenche com zeros nos deslizes iniciais
        let primeiroPosicaoQueVaiTerInicio = context.clonar().slice(0, quantidadeDeslizes);
        let posicaoAtualDoInicio = 1;

        for( let i = 0 ; i < primeiroPosicaoQueVaiTerInicio.linhas-1 ; i++ ){
            let valoresColocarNessaIteracao = primeiroPosicaoQueVaiTerInicio.slice( 0, posicaoAtualDoInicio );
            posicaoAtualDoInicio++;

            let quantosFaltamNessaIteracao = Math.abs( valoresColocarNessaIteracao.raw().length - quantidadeDeslizes );

            let arrayPreencher = Vectorization.Matrix( Array( quantosFaltamNessaIteracao )
                                                       .fill( Array( primeiroPosicaoQueVaiTerInicio.raw()[0].length ).fill(0) ) )
                                              .concat( valoresColocarNessaIteracao );

            deslizesProntos.adicionarObjeto( arrayPreencher );
        }

        for( let i = iniciarEm ; i < context.linhas ; i++ ){

            //Se a proxima iteração for ultrapassar os limites(a ultima linha desta Matrix), interompe, pois ja terminou
            if( i + quantidadeDeslizes > context.linhas ){
                break;
            }

            const sliceAtual = context.clonar()
                                      .slice( i, i + quantidadeDeslizes );

            deslizesProntos.adicionarObjeto( sliceAtual );
        }

        return deslizesProntos;
    }

    context.extrairValoresLinha = context.getLinha;

    context._definirValorLinha = function(indice, indiceAdicionar, vetorDaLinha){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        context.getLinha(indice)
               .definirElementoNoIndice(indiceAdicionar, vetorDaLinha);
    }

    /**
    * 
    * @param {Number} indice - O indice da linha
    * @param {Number} indiceAdicionar - O indice da coluna
    * @param {Array} vetorDaLinha 
    */
    context.definirValorLinha = function(indice, indiceAdicionar, vetorDaLinha){
        context._definirValorLinha(indice, indiceAdicionar, vetorDaLinha);
    }

    //Cria uma nova coluna nesta Vectorization.Matrix
    context.adicionarColuna = function(valoresNovaColuna){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        let isVetorVectorization = (
            Vectorization.Vector.isVector(valoresNovaColuna || []) == true &&
            Vectorization.Vector.isVectorizationVector(valoresNovaColuna || []) 
        ) == true;
           
        let valoresNovaColuna_Vector = isVetorVectorization == true ? valoresNovaColuna : Vectorization.Vector(valoresNovaColuna || []);
        let tamanhoVetorNovo = valoresNovaColuna_Vector.tamanho();
        let quantidadeLinhasMatrix = context.getRows();

        if( typeof valoresNovaColuna_Vector == 'object' &&
            tamanhoVetorNovo == quantidadeLinhasMatrix
        ){
            //Para cada linha
            Vectorization.Vector({
                valorPreencher: 1,
                elementos: quantidadeLinhasMatrix

            }).paraCadaElemento(function(iLinha){
                let valoresDaLinhaObtidos = context.getLinha(iLinha);

                switch( Vectorization.Vector.isVectorizationVector(valoresDaLinhaObtidos) || 
                        Vectorization.BendableVector.isVectorizationBendableVector(valoresDaLinhaObtidos) 
                ){
                    case true:
                        valoresDaLinhaObtidos.adicionarElemento( valoresNovaColuna[iLinha] );
                        break;

                    case false:
                        let novoVetorVectorization = Vectorization.Vector(valoresDaLinhaObtidos).adicionarElemento( valoresNovaColuna[iLinha] )
                        context._definirValorLinha(iLinha, valoresDaLinhaObtidos.length, [... novoVetorVectorization.valores()] );
                        break;
                }
            });

            //Atualiza a quantidade das colunas
            context.columns = context.calcTamanhos().lerIndice(1);
            context.colunas = context.columns;

        }else{
            throw 'Não da pra adicionar uma nova coluna se a quantidade de elementos não bater com a quantidade de linhas!. Não permitido.';
        }
    }

    //Remove uma coluna nesta Vectorization.Matrix e retorna uma nova Vectorization.Matrix
    context.removerColuna = function( indiceColuna ){
        let matrixNova = [];
        //Para cada linha
        for( let i = 0 ; i < context.linhas ; i++ )
        {
            const LinhaVector = context.getLinha(i);
            const NovaVector  = Vectorization.Vector([]);

            //Para cada elemento no LinhaVector
            LinhaVector.forEach(function( indiceElemento, valorElemento, contextoLinhaVector ){
                //Se o indice não for o indice que estamos ignorando
                if( indiceElemento != indiceColuna ){
                    NovaVector.push( valorElemento );
                }
            });

            matrixNova.push(NovaVector.raw());
        }

        return Vectorization.Matrix(matrixNova);
    }     
    
    //Remove varias coluna nesta Vectorization.Matrix e retorna uma nova Vectorization.Matrix
    context.removerColunas = function( VectorIndiceColuna=[] ){
        let matrixNova = [];
        //Para cada linha
        for( let i = 0 ; i < context.linhas ; i++ )
        {
            const LinhaVector = context.getLinha(i);
            const NovaVector  = Vectorization.Vector([]);

            //Para cada elemento no LinhaVector
            LinhaVector.forEach(function( indiceElemento, valorElemento, contextoLinhaVector ){
                //Se o indice não for o indice que estamos ignorando
                if( VectorIndiceColuna.includes(indiceElemento) == false ){
                    NovaVector.push( valorElemento );
                }
            });

            matrixNova.push(NovaVector.raw());
        }

        return Vectorization.Matrix(matrixNova);
    }  

    context.zerarColuna = function(indiceColuna, valorDefinirNoLugar=0){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        let quantidadeLinhasMatrix = context.getLinhas();

        //Para cada linha
        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix

        }).paraCadaElemento(function(iLinha){
            context._definirValorLinha(iLinha, indiceColuna, valorDefinirNoLugar );
        });
    }

    /**
    * @param {Number} indiceColuna 
    * @param {Number} valorDefinirNoLugar 
    * @param {Number} funcaoDeCondicao - a função(indiceDaLinhaAtual, indiceDaColunaEmQuestao, vetorDaLinhaAtual, valoresBrutosDaLinha, valorDaColunaAtualDaLinhaAtual, contextoPropiaMatrix) 
    */
    context.zerarColunaOnde = function(indiceColuna, valorDefinirNoLugar=0, funcaoDeCondicao){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }
        
        if( typeof funcaoDeCondicao == 'function' && funcaoDeCondicao != undefined )
        {
            let quantidadeLinhasMatrix = context.getLinhas();

            //Para cada linha
            Vectorization.Vector({
                valorPreencher: 1,
                elementos: quantidadeLinhasMatrix

            }).paraCadaElemento(function(iLinha){
                let vetorDaLinhaAtual = context.getLinha(iLinha),
                    valoresBrutosDaLinha = vetorDaLinhaAtual.valores(),
                    indiceDaLinhaAtual = iLinha,
                    indiceDaColunaEmQuestao = indiceColuna,
                    valorDaColunaAtualDaLinhaAtual = vetorDaLinhaAtual.readIndex(indiceColuna),
                    contextoPropiaMatrix = context;

                let checagemDaFuncaoDeCondicao = funcaoDeCondicao(indiceDaLinhaAtual, indiceDaColunaEmQuestao, vetorDaLinhaAtual, valoresBrutosDaLinha, valorDaColunaAtualDaLinhaAtual, contextoPropiaMatrix);

                if( checagemDaFuncaoDeCondicao == true || checagemDaFuncaoDeCondicao == 'limpar' || checagemDaFuncaoDeCondicao == 'zerar' || checagemDaFuncaoDeCondicao == 'clear' || checagemDaFuncaoDeCondicao == 'clean'){
                    context._definirValorLinha(iLinha, indiceColuna, valorDefinirNoLugar );
                }
            });

        }else{
            throw 'Precisa ter a funcaoDeCondicao';
        }
    }

    context.zerarLinha = function(indiceLinha, valorDefinirNoLugar=0){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        context.getLinha(indiceLinha).substituirElementosPor( Vectorization.Vector({
            valorPreencher: valorDefinirNoLugar,
            elementos: context.columns
        }) );
    }

    /**
    * Aplica um arredondamento sobre os valores deste vetor
    * CUIDADO: isso vai sobrescrever os valores
    * 
    * @param {String} tipoArredondamentoAplicar
    * @returns {Vectorization.Matrix} - a matrix arredondada
    */
    context.aplicarArredondamento = function(tipoArredondamentoAplicar='cima'){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: context.rows

        }).paraCadaElemento(function(i){
            let subVetorAplicarArredondamento = context.getLinha(i);

            if( Vectorization.Vector.isVectorizationVector(subVetorAplicarArredondamento) ){
                subVetorAplicarArredondamento.aplicarArredondamento(tipoArredondamentoAplicar);
            }
        });

        return context;
    }

    /**
    * Vai tornar possivel que voce ande por todos os elementos que estão presentes dentro da coluna especifica que vc passar como parametro.
    * @param {Number} indiceColuna - o indice da coluna em questão
    * @param {Function} callbackPercorrer - callbackPercorrer(valorNoIndiceDeInteresse, iLinha, LinhaMatrix_Vector, context)
    */
    context.percorrerColuna = function(indiceColuna, callbackPercorrer){
        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let valorNoIndiceDeInteresse = LinhaMatrix_Vector.lerIndice(indiceColuna);

            callbackPercorrer( 
                      indiceColuna,
                      valorNoIndiceDeInteresse, 
                      iLinha, 
                      LinhaMatrix_Vector, 
                      context 
                    );
        });
    }

    context.paraCadaColuna = context.percorrerColuna;

    /** 
    * Remove amostras duplicadas deste Vectorization.Vector com base em colunas específicas.
    */
    context.distinct = function(){
        const valoresJaVistos = {};
        const valoresUnicos = Vectorization.Matrix([], { flexibilidade: context.flexibilidade });

        context.forEach(function(indice, linhaVector){
            const identificador = linhaVector.raw()
                                             .join('|');

            if( valoresJaVistos[identificador] == undefined ){
                valoresJaVistos[identificador] = true;
                valoresUnicos.push( linhaVector );
            }
        });

        return valoresUnicos;
    }

    /**
    * Vai tornar possivel que voce ande por todos os elementos que estão presentes dentro da coluna especifica que vc passar como parametro.
    * SIMILAR AO context.percorrerColuna, porém ele vai implementar algo mais parecido com o Vectorization.Vector.mapearValores
    * @param {Number} indiceColuna - o indice da coluna em questão
    * @param {Function} callbackMapeamento - callbackMapeamento(valorNoIndiceDeInteresse, iLinha, LinhaMatrix_Vector, context)
    * @returns {Vectorization.Vector} - a coluna após a aplicação desta função
    */
    context.mapearColuna = function(indiceColuna, callbackMapeamento){
        let valoresAposAplicacaoMetodo = Vectorization.Vector([]);

        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let valorNoIndiceDeInteresse = LinhaMatrix_Vector.lerIndice(indiceColuna);

            let resultadoAplicacaoFuncao = callbackMapeamento( valorNoIndiceDeInteresse, 
                      iLinha, LinhaMatrix_Vector, context 
                    );

            valoresAposAplicacaoMetodo.adicionarElemento(resultadoAplicacaoFuncao);
        });

        return Vectorization.Vector(valoresAposAplicacaoMetodo);
    }

    /**
    * Vai permitir "Peneirar" os elementos que estão presentes dentro da coluna especifica que vc passar como parametro.
    * SIMILAR AO Vectorization.Vector.filtrarValores
    * @param {Number} indiceColuna - o indice da coluna em questão
    * @param {Function} callbackFiltragem - callbackFiltragem(valorNoIndiceDeInteresse, iLinha, LinhaMatrix_Vector, context)
    * @returns {Vectorization.Vector} - a coluna após a aplicação deste filtro
    */
    context.filtrarColuna = function(indiceColuna, callbackFiltragem){
        let valoresAposAplicacaoMetodo = Vectorization.Vector([]);

        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let valorNoIndiceDeInteresse = LinhaMatrix_Vector.lerIndice(indiceColuna);

            if(!callbackFiltragem){
                throw 'Voce precisa passar uma função de filtro!. Não permitido!';
            }

            let resultadoAplicacaoFuncao = callbackFiltragem( valorNoIndiceDeInteresse, 
                      iLinha, LinhaMatrix_Vector, context 
                    );

            let checagemDoFiltro = resultadoAplicacaoFuncao;

            if(checagemDoFiltro == true || checagemDoFiltro == 'incluir' || checagemDoFiltro == 'manter' || checagemDoFiltro == 'keep' || checagemDoFiltro == 'ok'){
                valoresAposAplicacaoMetodo.adicionarElemento(valorNoIndiceDeInteresse);
            }

        });

        return Vectorization.Vector(valoresAposAplicacaoMetodo);
    }

    /**
    * Aplica um "peneiramento" na coluna desta Vectorization.Matrix
    * @param {Number} indiceColuna - o indice da coluna em questão
    * @param {Function} callbackFiltragem - callbackFiltragem(iColuna, elementoNaPosicaoAtual, context)
    * @returns {Vectorization.Matrix} - Esta propia Vectorization.Matrix
    * 
    * CUIDADO: isso vai sobrescrever esta Vectorization.Matrix
    */
    context.aplicarFiltroColuna = function(indiceColuna, callbackFiltragem){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let LinhaMatrix_Vector_copia = ( LinhaMatrix_Vector || Vectorization.Vector([]) ).duplicar();
            let dadosLinhaMatrix_Vector_Filtrados = Vectorization.Vector( LinhaMatrix_Vector_copia.filtrarValores(callbackFiltragem) );

            if(!callbackFiltragem){
                throw 'Voce precisa passar uma função de filtro!. Não permitido!';
            }

            if( Vectorization.Vector.isVectorizationVector(dadosLinhaMatrix_Vector_Filtrados) ){
                //Atualiza esta Vectorization.Matrix
                LinhaMatrix_Vector.sobrescreverConteudo(
                    Vectorization.Vector( dadosLinhaMatrix_Vector_Filtrados.valores() || [] )
                );

            }else{
                console.warn('Nenhum filtro foi aplicado');
            }

        });

        return context;
    }

    /**
    * Descobre qual que é a maior quantidade de elementos das linhas cadastradas na matrix
    */
    context.getMaiorQuantidadeColunas = function(){
        let primeiraLinha = context.getLinha(0);
        let maiorQuantiaAtualmenteObtida = primeiraLinha.tamanho();
        let quantidadeLinhasMatrix = context.rows;

        Vectorization.Vector({
           valorPreencher: 1,
           elementos: quantidadeLinhasMatrix
           
        }).paraCadaElemento(
            function(i){
                let linhaAtual = context.getLinha(i);
                let tamanhoDaLinhaAtual = linhaAtual.tamanho();
                maiorQuantiaAtualmenteObtida = (maiorQuantiaAtualmenteObtida <= tamanhoDaLinhaAtual) ? tamanhoDaLinhaAtual : maiorQuantiaAtualmenteObtida;
            });

        return maiorQuantiaAtualmenteObtida;
    }

    /**
    Descobre qual que é a linha que tem mais quantidade de elementos.
    */
    context.getMaiorLinha = function(){
        let primeiraLinha = context.getLinha(0);
        let maiorLinha = primeiraLinha;
        let quantidadeLinhasMatrix = context.rows;
        let maiorQuantidadeColunas = context.getMaiorQuantidadeColunas();

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix
            
         }).paraCadaElemento(
             function(i){
                 let linhaAtual = context.getLinha(i);
                 let tamanhoDaLinhaAtual = linhaAtual.tamanho();
                 if( tamanhoDaLinhaAtual >= maiorQuantidadeColunas ){ maiorLinha = linhaAtual };
             });

        return maiorLinha;
    }

    /**
    * Método que ele vai sair percorrendo cada linha, e vai deixar todas as linhas com a mesma quantidade de elemeentos
    * Se baseando estritamente na quantidade de colunas atual desta Vectorization.Matrix
    */
    context.igualarColunas = function(valorDefinirNoLugar){
        let maiorQuantidadeColunas = context.getMaiorQuantidadeColunas();
        let quantidadeLinhasMatrix = context.rows;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix
            
        }).paraCadaElemento(function(i){
            let linhaAtual = context.getLinha(i);
            let tamanhoDaLinhaAtual = linhaAtual.tamanho();

            if( tamanhoDaLinhaAtual < maiorQuantidadeColunas )
            {
                let quantosElementosFaltam = Math.abs( tamanhoDaLinhaAtual - maiorQuantidadeColunas );
                
                let novoVetorASerAcrescentado = Vectorization.Vector({
                    valorPreencher: valorDefinirNoLugar,
                    elementos: quantosElementosFaltam
                });

                //Vai acrescentar um novo Vectorization.Vector dentro da linha atual desta Vectorization.Matrix
                //Vai usar um método chamado acrescentarVetor do Vectorization.Vector
                linhaAtual.acrescentarVetor(novoVetorASerAcrescentado);
            }
        });
    }

    /**
    * Quase identico ao context.igualarColunas, porém com uma diferença drástica: ele adiciona no inicio da linha
    * 
    * Método que ele vai sair percorrendo cada linha, e vai deixar todas as linhas com a mesma quantidade de elemeentos
    * Se baseando estritamente na quantidade de colunas atual desta Vectorization.Matrix
    */
    context.igualarColunasNoInicio = function(valorDefinirNoLugar){
        let maiorQuantidadeColunas = context.getMaiorQuantidadeColunas();
        let quantidadeLinhasMatrix = context.rows;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix
            
        }).paraCadaElemento(function(i){
            let linhaAtual = context.getLinha(i);
            let tamanhoDaLinhaAtual = linhaAtual.tamanho();

            if( tamanhoDaLinhaAtual < maiorQuantidadeColunas )
            {
                let quantosElementosFaltam = Math.abs( tamanhoDaLinhaAtual - maiorQuantidadeColunas );
                
                let novoVetorASerAcrescentado = Vectorization.Vector({
                    valorPreencher: valorDefinirNoLugar,
                    elementos: quantosElementosFaltam
                });

                //Vai acrescentar um novo Vectorization.Vector dentro da linha atual desta Vectorization.Matrix
                //Vai usar um método chamado acrescentarVetor do Vectorization.Vector
                linhaAtual.acrescentarNoInicioVetor(novoVetorASerAcrescentado.valores());
            }
        });
    }

    context.adicionarEmTodasLinhas = function(){

    }

    /**
    * Percorre cada linha da matrix, aplicando uma função de callback
    * @param {Function} callback(index, element, context)
    */
    context.forEach = function(callback){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            callback( i, context.content[i], context );
        }
    }

    /**
    * Percorre cada linha da matrix, aplicando uma função de callback, retornando um resultado
    * @param {Function} callback(index, element, context)
    * @returns {Vectorization.Vector or Vectorization.Matrix}
    */
    context.map = function(callback){
        let novaMatrix = [];

        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novaMatrix[i] = callback( i, context.content[i], context );
        }

        //Se a função de callback ao ser aplicada resultar numa matrix, então ele converte resultado para Matrix
        if( Vectorization.Vector.isVector( novaMatrix[0] ) ){
            return Vectorization.Matrix(novaMatrix);
        }else{
            return Vectorization.Vector(novaMatrix);
        }
    }

    /**
     * Produto escalar de uma matriz com um vetor ou outra matriz
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matriz-com-vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matrizes
     * 
     * @param {Vectorization.Matrix} matrixA
     * @param {Object} matrixB
     * @returns {Object}
    */
    context.produtoEscalar = function( matrixB ){
        let matrixA = context;
        /**
        * Regra: percorre na vertical a matrixB, para cada coluna:
        * Coluna1 matrixB com linha1 matrixA, depois Coluna2 da matrixB com linha1 da matrixA.
        */

        if( !matrixB.objectName || (matrixB.objectName != 'Matrix' && matrixB.objectName != 'Vector') ){
            throw 'matrixB must be a Vectorization.Matrix';
        }

        if( matrixA.rows != (matrixB.columns || matrixB.length) ){
            throw 'The number of rows in matrixA must be exactly equal to the number of columns in matrixB. Impossible to calculate!';
        }

        //Se o segundo parametro for uma matrix
        if( matrixB.objectName == 'Matrix' ){
            let resultMatrix = [];
            let ordemColunasB = [];

            //Esse trecho é semelhante a uma transposição de matriz, pra tornar possivel os calculos
            for( let coluna = 0 ; coluna < matrixB.columns ; coluna++ ){

                //Extrair os valores da coluna atual da matrixB
                let valoresColunaBAtual = [];
                for( let linha = 0 ; linha < matrixB.rows ; linha++ ){
                    valoresColunaBAtual.push( matrixB.content[linha][coluna] );
                }

                //Salva isso numa lista, em ordem certa para os calculos abaixo no proximo bloco a seguir:
                ordemColunasB.push( valoresColunaBAtual );

            }   

            //Proxima etapa: percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){

                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];

                //Cria um array vazio para a linha. Esse array vai ser usado para armazenar os produtos feitos com os valores da linha abaixo:
                resultMatrix[linha] = [];
                
                //Percorre cada "fileira"(ou melhor dizendo, cada fileira é um vetor contendo cada valor da colunaB atual, ou seja, em sentido vertical) da matrix B
                for( let colunaB = 0 ; colunaB < ordemColunasB.length ; colunaB++ ){

                    //Obtem a fileira atual da matrix B(o vetor atual)
                    let valoresColunaBAtual = ordemColunasB[colunaB];

                    //Inicializa a variavel que será usada para a soma ponderada
                    let produtoAtual = 0;
                    //Percorre cada indice dos valores da fileira atual da matrix B
                    for( let indexValor = 0 ; indexValor < valoresColunaBAtual.length ; indexValor++ ){
                        produtoAtual += ( valoresLinhaAtual[indexValor] * valoresColunaBAtual[indexValor] );
                    }

                    //Atribui o produto dentro da linha atual da matriz resultante, isso é feito em ordem sequencial
                    resultMatrix[linha].push( produtoAtual );

                    //... vai pro próximo produto [...], permanecendo na linha atual da matrixA

                }
            }

            return Vectorization.Matrix(resultMatrix);

        //Se o segundo objeto for um Vector
        }else if( matrixB.objectName == 'Vector' ){
            if( matrixA.rows != matrixB.length ){
                throw 'The number of lines in matrixA must be exactly equal to the number of elements in the vector. Impossible to calculate!';
            }
        
            let vetorResultado = [];
        
            //Percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){
        
                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];
        
                //Inicializa a variavel que será usada para a soma ponderada da linha atual
                let produtoAtual = 0;
        
                //Percorre cada elemento do vetor B
                for( let colunaB = 0 ; colunaB < matrixB.length ; colunaB++ ){
                    produtoAtual += ( valoresLinhaAtual[colunaB] * matrixB.readIndex(colunaB) );
                }
        
                //Vai adicionando os resultados no vetor de resultado
                vetorResultado.push(produtoAtual);
            }
        
            return Vectorization.Vector(vetorResultado);
        }
    }

    /**
     * Produto escalar de uma matriz com outra matriz
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matriz-com-vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matrizes
     * 
     * @param {Vectorization.Matrix} matrixA
     * @param {Vectorization.Matrix} matrixB
     * @returns {Vectorization.Matrix}
    */
    context.produtoEscalarMatrix = function( matrixB ){
        let matrixA = context;
        /**
        * Regra: percorre na vertical a matrixB, para cada coluna:
        * Coluna1 matrixB com linha1 matrixA, depois Coluna2 da matrixB com linha1 da matrixA.
        */

        if( !matrixB.objectName || (matrixB.objectName != 'Matrix' && matrixB.objectName != 'Vector') ){
            throw 'matrixB must be a Vectorization.Matrix';
        }

        if( matrixA.rows != (matrixB.columns || matrixB.length) ){
            throw 'The number of rows in matrixA must be exactly equal to the number of columns in matrixB. Impossible to calculate!';
        }

        //Se o segundo parametro for uma matrix
        if( matrixB.objectName == 'Matrix' ){
            let resultMatrix = [];
            let ordemColunasB = [];

            //Esse trecho é semelhante a uma transposição de matriz, pra tornar possivel os calculos
            for( let coluna = 0 ; coluna < matrixB.columns ; coluna++ ){

                //Extrair os valores da coluna atual da matrixB
                let valoresColunaBAtual = [];
                for( let linha = 0 ; linha < matrixB.rows ; linha++ ){
                    valoresColunaBAtual.push( matrixB.content[linha][coluna] );
                }

                //Salva isso numa lista, em ordem certa para os calculos abaixo no proximo bloco a seguir:
                ordemColunasB.push( valoresColunaBAtual );

            }   

            //Proxima etapa: percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){

                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];

                //Cria um array vazio para a linha. Esse array vai ser usado para armazenar os produtos feitos com os valores da linha abaixo:
                resultMatrix[linha] = [];
                
                //Percorre cada "fileira"(ou melhor dizendo, cada fileira é um vetor contendo cada valor da colunaB atual, ou seja, em sentido vertical) da matrix B
                for( let colunaB = 0 ; colunaB < ordemColunasB.length ; colunaB++ ){

                    //Obtem a fileira atual da matrix B(o vetor atual)
                    let valoresColunaBAtual = ordemColunasB[colunaB];

                    //Inicializa a variavel que será usada para a soma ponderada
                    let produtoAtual = 0;
                    //Percorre cada indice dos valores da fileira atual da matrix B
                    for( let indexValor = 0 ; indexValor < valoresColunaBAtual.length ; indexValor++ ){
                        produtoAtual += ( valoresLinhaAtual[indexValor] * valoresColunaBAtual[indexValor] );
                    }

                    //Atribui o produto dentro da linha atual da matriz resultante, isso é feito em ordem sequencial
                    resultMatrix[linha].push( produtoAtual );

                    //... vai pro próximo produto [...], permanecendo na linha atual da matrixA

                }
            }

            return Vectorization.Matrix(resultMatrix);

        //Se o segundo objeto for um Vector
        }else if( matrixB.objectName == 'Vector' ){
            throw 'O segundo parametro precisa ser uma Matrix!';
        }
    }

    /**
     * Produto escalar de uma matriz com um vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matriz-com-vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matrizes
     * 
     * @param {Vectorization.Matrix} matrixA
     * @param {Vectorization.Vector} matrixB
     * @returns {Vectorization.Vector}
    */
    context.produtoEscalarVetor = function( matrixB ){
        let matrixA = context;
        /**
        * Regra: percorre na vertical a matrixB, para cada coluna:
        * Coluna1 matrixB com linha1 matrixA, depois Coluna2 da matrixB com linha1 da matrixA.
        */

        if( !matrixB.objectName || (matrixB.objectName != 'Matrix' && matrixB.objectName != 'Vector') ){
            throw 'matrixB must be a Vectorization.Matrix';
        }

        if( matrixA.rows != (matrixB.columns || matrixB.length) ){
            throw 'The number of rows in matrixA must be exactly equal to the number of columns in matrixB. Impossible to calculate!';
        }

        //Se o segundo parametro for uma matrix
        if( matrixB.objectName == 'Matrix' ){
            throw 'O segundo parametro precisa ser um Vector!';

        //Se o segundo objeto for um Vector
        }else if( matrixB.objectName == 'Vector' ){
            if( matrixA.rows != matrixB.length ){
                throw 'The number of lines in matrixA must be exactly equal to the number of elements in the vector. Impossible to calculate!';
            }
        
            let vetorResultado = [];
        
            //Percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){
        
                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];
        
                //Inicializa a variavel que será usada para a soma ponderada da linha atual
                let produtoAtual = 0;
        
                //Percorre cada elemento do vetor B
                for( let colunaB = 0 ; colunaB < matrixB.length ; colunaB++ ){
                    produtoAtual += ( valoresLinhaAtual[colunaB] * matrixB.readIndex(colunaB) );
                }
        
                //Vai adicionando os resultados no vetor de resultado
                vetorResultado.push(produtoAtual);
            }
        
            return Vectorization.Vector(vetorResultado);
        }
    }

    /**
     * Multiplica esta matrix com outra, de maneira elemento a elemento
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-elemento-a-elemento/codigo-principal.js
     * 
     * @param {Vectorization.Matrix} matrixB_param
     * @returns {Vectorization.Matrix}
    */
    context.multiplicarMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E não um ' + String(matrixB_param.objectName);
        }

        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let matrixResultado = [];

        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                matrixResultado[i].push( matrixA[i][j] * matrixB[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Multiplica esta matrix por um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Matrix}
     */
    context.multiplicarNumero = function(numero){
        let matrixA = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];
    
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                matrixResultado[i].push( matrixA[i][j] * numero );
            }
        }
    
        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Multiplica esta matrix por um vetor
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB_param
     * @returns {Vectorization.Matrix} 
     */
    context.multiplicarVetor = function(vectorB_param){
        let matrixA = context.content;
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let matrixResultado = [];

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( matrixA[i][j] * vectorB[j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Faz a transposta da matrix
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/matriz-transposta
     *
     * @returns {Vectorization.Matrix}
    */
    context.transposta = function(){
        let novaMatrix = [];

        for( let j = 0 ; j < context.content[0].length ; j++ ){
            novaMatrix[j] = [];

            for( let i = 0 ; i < context.content.length ; i++ ){
                novaMatrix[j].push( context.content[i][j] );
            }
        }

        const extraProps = {
            isTransposta: !context.isTransposta ? true : false
        }

        return Vectorization.Matrix(novaMatrix, extraProps);
    }

    /**
     * Obtem a matrix oposta
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/matriz-oposta/codigo-principal.js
     * @returns {Vectorization.Matrix}
     */
    context.matrixOposta = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] * -1;
            }
        }

        const extraProps = {
            isOposta: !context.isOposta ? true : false
        }
    
        return Vectorization.Matrix(novaMatrix, extraProps);
    }

    /**
     * Obtem a matrix absoluta
     * 
     * @returns {Vectorization.Matrix}
     */
    context.abs = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.abs(matrixA[i][j]);
            }
        }

        const extraProps = {
            isOposta: !context.isOposta ? true : false
        }
    
        return Vectorization.Matrix(novaMatrix, extraProps);
    }

    context.modulo = function(){
        return context.abs();
    }

    context.absoluto = function(){
        return context.abs();
    }

    /**
     * Obtem a raiz quadrada, de cada elemento da matrix 
     * @returns {Vectorization.Matrix}
     */
    context.sqrt = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.sqrt(matrixA[i][j]);
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Obtem o log2, de cada elemento da matrix 
     * @returns {Vectorization.Matrix}
     */
    context.log2 = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.log2(matrixA[i][j]);
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Obtem o log10, de cada elemento da matrix 
     * @returns {Vectorization.Matrix}
     */
    context.log10 = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.log10(matrixA[i][j]);
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Tenta obter a matrix de identidade de ordem desta matrix 
    */
    context.identidade = function(){
        if( context.rows != context.columns ){
            throw 'A matrix precisa ser quadrada de ordem X'
        }
        
        return window.Vectorization.matrixIdentidade( context.rows );
    }

    /**
     * Soma esta matrix com outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.somarMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E não um ' + String(matrixB_param.objectName);
        }

        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] + matrixB[i][j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Soma esta matrix com um número
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-matrizes-por-um-numero-scalar/codigo-principal.js
    * @param {Number} numero
    * @returns {Vectorization.Matrix}
    */
    context.somarNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] + numero;
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Soma esta matrix com um vetor
     * 
     * @param {Vectorization.Matrix} vectorB_param 
     * @returns {Vectorization.Matrix}
    */
    context.somarVetor = function(vectorB_param){
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;

        if( vectorB.objectName != undefined && vectorB.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB.objectName);
        }
        
        let matrixA = context.content;

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        //let matrixB = (vectorB.objectName != undefined && vectorB.objectName == 'Vector') ? vectorB.content : vectorB;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] + vectorB[j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Subtrai esta matrix com outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.subtrairMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E não um ' + String(matrixB_param.objectName);
        }

        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] - matrixB[i][j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Subtrai esta matrix com um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-matrizes-por-um-numero-scalar/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix} 
    */
    context.subtrairNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] - numero;
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Subtrai esta matrix com um vetor
     * 
     * @param {Vectorization.Matrix} vectorB_param 
     * @returns {Vectorization.Matrix}
    */
    context.subtrairVetor = function(vectorB_param){
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;

        if( vectorB.objectName != undefined && vectorB.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB.objectName);
        }
        
        let matrixA = context.content;

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        //let matrixB = (vectorB.objectName != undefined && vectorB.objectName == 'Vector') ? vectorB.content : vectorB;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] - vectorB[j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Divide esta matrix com outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.dividirMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E não um ' + String(matrixB_param.objectName);
        }
        
        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] / matrixB[i][j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Divide esta matrix por um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero 
     * @returns {Vectorization.Matrix}
     */
    context.dividirNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];
        
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] / numero;
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Divide esta matrix por um vetor, aplicando o vetor a cada linha desta matrix 
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Matrix}
    */
    context.dividirVetor = function(vectorB_param){
        let matrixA = context.content;
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novaMatrix = [];

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser igual a quantidade de colunas da matrix!'
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] / vectorB[j];
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Eleva esta matrix a um número
    * 
    * @param {Number} numero
    * @returns {Vectorization.Matrix}
    */
    context.elevarNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.pow(matrixA[i][j], numero);
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Eleva esta matrix a um vetor
     * 
     * @param {Vectorization.Vector} vectorB_param
     * @returns {Vectorization.Matrix} 
     */
    context.elevarVetor = function(vectorB_param){
        let matrixA = context.content;
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let matrixResultado = [];

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( Math.pow(matrixA[i][j], vectorB[j]) );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Eleva esta matrix a outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.elevarMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E não um ' + String(matrixB_param.objectName);
        }
        
        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.pow(matrixA[i][j], matrixB[i][j]);
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Pega todos os elementos que estão dentro desta Vectorization.Matrix,
    * e deixa todos eles num unico Vectorization.Vector, desprezando as dimensões, e deste modo: concentrando tudo em um unico Vectorization.Vector. 
    * @returns {Vectorization.Vector}
    */
    context.planificar = function(){
        let novoVetorASerRetornado = Vectorization.Vector([]);
        Vectorization.Matrix(context.duplicar())
        .paraCadaLinha(
            function(iLinha, vetorDaLinha){
                const vetorDaLinha_Vector = Vectorization.Vector.isVectorizationVector(vetorDaLinha) ? vetorDaLinha : Vectorization.Vector(vetorDaLinha);
                novoVetorASerRetornado.acrescentarVetor( Vectorization.Vector( vetorDaLinha_Vector ).duplicar() );
            }); 

        return Vectorization.Vector(novoVetorASerRetornado);
    }

    /**
    * DIFERENTE DO context.extrairValoresColuna
    * Esse método extrai os valores de uma ou mais colunas,
    * NOTA: Isso vai retornar um Vectorization.Vector para cada coluna
    * e não recortar colunas da Vectorization.Matrix, então o resultado não será um Vectorization.Matrix
    * o resultado será um Vectorization.Vector, conteundo outros Vectorization.Vector(as colunas)
    * @param {Vectorization.Vector || Array} listaColunas - um Vectorization.Vector de indices(numeros inteiros)
    * @returns {Vectorization.Vector}
    */
    context.extrairValoresColunas = function( listaColunas='todasColunas' ){
        let listaColunas_Vector = listaColunas != 'todasColunas' ?
                                  Vectorization.Vector.isVectorizationVector(listaColunas) == false ? Vectorization.Vector(listaColunas) : listaColunas : 'todasColunas';
    
        let colunasExtraida = Vectorization.Vector([], {usarEscalares: false});

        if( listaColunas == 'todasColunas' ){
           //Para cada coluna
           Vectorization.Vector({
              valorPreencher: 1,
              //Vai criar uma iteração em cada coluna
              elementos: matrix1.columns

           }).paraCadaElemento(function(j, numeroColuna){
               let valoresExtraidosColunaAtual = context.extrairValoresColuna(numeroColuna);
               colunasExtraida.adicionarElemento( valoresExtraidosColunaAtual );
           });

        }else{
           //Para cada coluna a ser extraida
           listaColunas_Vector.paraCadaElemento(function(j, numeroColuna){
               let valoresExtraidosColunaAtual = context.extrairValoresColuna(numeroColuna);
               colunasExtraida.adicionarElemento( valoresExtraidosColunaAtual );
           });
        }

        return colunasExtraida;
    }

    /**
    * DIFERENTE DO context.extrairValoresColuna
    * SIMILAR ao context.extrairValoresColunas
    * 
    * Esse método extrai os valores de todas as colunas EXCETO UMA,
    * NOTA: Isso vai retornar um Vectorization.Vector para cada coluna
    * e não recortar colunas da Vectorization.Matrix, então o resultado não será um Vectorization.Matrix
    * o resultado será um Vectorization.Vector, conteundo outros Vectorization.Vector(as colunas)
    * @param {Vectorization.Vector || Array} listaColunas - um Vectorization.Vector de indices(numeros inteiros)
    * @returns {Vectorization.Vector}
    */
    context.extrairValoresColunasExceto = function(numeroColunaIgnorar){
        let colunasExtraida = Vectorization.Vector([], {usarEscalares: false});

        //Para cada coluna
        Vectorization.Vector({
            valorPreencher: 1,
            //Vai criar uma iteração em cada coluna
            elementos: matrix1.columns

        }).paraCadaElemento(function(j, numeroColuna){
            if( j != numeroColunaIgnorar )
            {
                let valoresExtraidosColunaAtual = context.extrairValoresColuna(j);
                colunasExtraida.adicionarElemento( valoresExtraidosColunaAtual );
            
            }else{
                //Faz nada, IGNORA
            }
        });

        return colunasExtraida;
    }

    /**
     * Faz o onehot em uma coluna especifica
     * retorna um Vectorization.Vector, contendo outros Vectorization.Vector(coluna) contendo valores booleanos,
     * para cada valor unico na coluna especifica ele vai percorrer cada valor existente na coluna especifica(numeroColuna), e verificar se o item atual da coluna da matrix é igual a esse valor unico atual
     * se sim, então vai colocar 1, caso contrario vai colocar 0
     * 
     * NOTA: Isso só faz o onehot para uma unica coluna especifica
     * e retorna um Vectorization.Vector para cada valor unico da coluna especifica a ser codificada
     * 
     * @param {Number} numeroColuna 
     * @param {Vectorization.Vector} dadosColunaAtual 
     * @returns {Vectorization.Vector}
     */
    context.aplicarCodificacaoONEHOT = function(numeroColuna, dadosColunaAtual){
        const valoresUnicosColunaAtual = dadosColunaAtual.valoresUnicos();

        //Cria as colunas que serão usadas
        const novasColunas_COLUNA_ATUAL = Vectorization.Vector({
            valorPreencher: Vectorization.Vector([], {usarEscalares: false}),
            elementos: valoresUnicosColunaAtual.elementos
        }, {
            usarEscalares: false
        });

        //Percorre essa numeroColuna coluna da matrix
        context.paraCadaLinha(function(ii){
            let dadosLinha = context.getLinha(ii);
            let dadosLinhaNACOLUNA = dadosLinha.lerIndice(numeroColuna);

            for( let jj = 0 ; jj < valoresUnicosColunaAtual.elementos ; jj++ )
            {
                const valorUnico = valoresUnicosColunaAtual.lerIndice(jj);
                const isIgual = dadosLinhaNACOLUNA.raw() == valorUnico;

                if( isIgual == true ){
                    novasColunas_COLUNA_ATUAL.lerIndice(jj)
                                             .adicionarElemento(1);

                }else{
                    novasColunas_COLUNA_ATUAL.lerIndice(jj)
                                             .adicionarElemento(0);
                }
            }
        });

        return novasColunas_COLUNA_ATUAL;
    }

    /**
    * Faz o onehot nas colunas definidas
    * @param {Number} numeroColunasQuero
    * @returns {Object} - objeto onde voce pode obter Vectorization.Vector(s) ou uma Vectorization.Matrix com os valores inclusos
    */
    context.oneHotColunas = function(numeroColunasQuero){
        const colunas_Vetor = context.extrairValoresColunas(numeroColunasQuero);

        /*
        * Vai fazer a codificação de cada coluna passada em numeroColunasQuero, 
        * E armazenar aqui no resultadoOperacao
        */
        const resultadoOperacao = Vectorization.Vector([], {usarEscalares: false});
        const resultadoMatrix = context.duplicar();

        //Para cada coluna que quero aplicar
        colunas_Vetor.paraCadaElemento(function(i){
            
            //Obtenho os dados da coluna
            const dadosColunaAtual = colunas_Vetor.lerIndice(i);
            const dadosCodificadosColunaAtual = context.aplicarCodificacaoONEHOT( i , dadosColunaAtual );
        
            resultadoOperacao.adicionarElemento(dadosCodificadosColunaAtual);

            //Vai jogando tudo isso dentro da Vectorization.Matrix copiada
            dadosCodificadosColunaAtual.paraCadaElemento(function(jColuna, elementoColuna){
                if( 
                    Vectorization.Vector.isVector( elementoColuna ) == true || 
                    Vectorization.BendableVector.isBendableVector( elementoColuna ) == true 
                ){
                    resultadoMatrix.adicionarColuna(elementoColuna);
                }
            });
        });

        return {
            resultado_vector: resultadoOperacao,
            matrix_incluida: resultadoMatrix,

            raw: function(){
                return resultadoOperacao.raw();
            },

            obterMatrix: function(){
                return this.matrix_incluida;
            },

            obterVector: function(){
                return this.resultado_vector;
            }
        };
    }

    /**
    * Calcula a correlação entre duas colunas(pelo indice) 
    */
    context.correlationColumns = function(indiceColuna1, indiceColuna2){
        const valoresColuna1 = context.extrairValoresColuna(indiceColuna1);
        const valoresColuna2 = context.extrairValoresColuna(indiceColuna2);
        return valoresColuna1.correlationWith( valoresColuna2 );
    }

    context._doDefaultBaseAfterCreate();

    //Se a opção advanced estiver ativa, ele roda um método adicional após criar a matrix
    if( context.isAdvancedMatrix == true ){
        context._matrix2Advanced();
    }

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //Aplica arredondamentos, se o usuario desejar, mesmo não sendo um Vectorization.Matrix aleatoria
    if( context._config != undefined &&
        (
            context._config['aleatorio'] == undefined || context._config['aleatorio'] == false
        ) == true && 
        (
            context._config['arredondar'] != undefined ||
            context.configRecebidaUsuario['arredondar'] != undefined
        ) == true
    ){
        context.aplicarArredondamento(context._config['arredondar'] || context.configRecebidaUsuario['arredondar']);
    }

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    context.bloqueado = (config['bloqueado'] != undefined || classConfig['bloqueado'] != undefined) ? (config['bloqueado'] || classConfig['bloqueado']) : false;

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    if( context._isBloqueado() == true ){
        context.bloquearModificacoes();
    }

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    /** EXPORTAÇÂO DE DADOS  */

    /**
    * Método auxiliar para fazer download do arquivo CSV.
    * @param {string} conteudo Conteúdo do arquivo.
    * @param {string} nomeArquivo Nome do arquivo.
    */
    context.downloadArquivo = function(conteudo, nomeArquivo) {
        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {

            const blob = new Blob([conteudo], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = nomeArquivo;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
        }
    }

    /**
    * Exporta os dados de um objeto Vectorization.Matrix para um formato CSV com separador configurável.
    * @param {string|null} downloadArquivo Nome do arquivo para download (opcional).
    * @param {string} separador Separador de colunas (padrão: ',').
    * @returns {string} Conteúdo do CSV.
    */
    context.exportarCSV = function(downloadArquivo = null, separador = ',') {
        let csvConteudo = '';

        // Gera a linha de cabeçalho
        //const linhaCabecalho = Array(context.colunas).fill(0).map((_, index) => `Coluna_${index}`).join(separador);
        //csvConteudo += linhaCabecalho + '\n';

        // Percorre cada linha da matriz
        context.content.forEach(linha => {
            const linhaValores = linha.map( (indice, valor) => {
                // Escapa valores que contêm o separador ou aspas
                if (typeof valor === 'string' && (valor.includes(separador) || valor.includes('"'))) {
                    return `"${valor.replace(/"/g, '""')}"`;
                }
                return valor;
            }).raw().join(separador);

            // Adiciona a linha atual ao conteúdo do CSV
            csvConteudo += linhaValores + '\n';
        });

        //Corta o \n sozinho no final
        if( csvConteudo.endsWith('\n') ){
            csvConteudo = csvConteudo.slice(0, csvConteudo.length-String('\n').length);
        }

        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
            // Faz o download do arquivo, se solicitado
            if (downloadArquivo && downloadArquivo.endsWith('.csv')) {
                context.downloadArquivo(csvConteudo, downloadArquivo);
            }

        //Se for node
        }if( VECTORIZATION_BUILD_TYPE == 'node' ) {

        }

        return csvConteudo;
    }

    /**
    * Exporta os dados de um objeto Vectorization.Matrix para um formato TXT com separador configurável.
    * @param {string|null} downloadArquivo Nome do arquivo para download (opcional).
    * @param {string} separador Separador entre valores (padrão: tabulação '\t').
    * @returns {string} Conteúdo do TXT.
    */
    context.exportarTXT = function(downloadArquivo = null, separador = '\t') {
        let txtConteudo = '';

        // Gera as linhas do conteúdo TXT
        context.content.forEach(linha => {
            const linhaValores = linha.map( (indice, valor) => {
                // Formata o valor, se necessário
                if (typeof valor === 'string' && (valor.includes(separador) || valor.includes('"'))) {
                    return `"${valor.replace(/"/g, '""')}"`;
                }
                return valor;
            }).raw().join(separador);

            // Adiciona a linha ao conteúdo do TXT
            txtConteudo += linhaValores + '\n';
        });

        //Corta o \n sozinho no final
        if( txtConteudo.endsWith('\n') ){
            txtConteudo = txtConteudo.slice(0, txtConteudo.length-String('\n').length);
        }

        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
            // Faz o download do arquivo, se solicitado
            if (downloadArquivo && downloadArquivo.endsWith('.txt')) {
                context.downloadArquivo(txtConteudo, downloadArquivo);
            }

        //Se for node
        }else if( VECTORIZATION_BUILD_TYPE == 'node' ) {

        }

        return txtConteudo;
    }

    /**
	* Exporta os dados deste Vectorization.Matrix para um formato JSON
	*/
	context.exportarJSON = function( downloadArquivo=null ){
		
        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
            if(downloadArquivo && downloadArquivo.endsWith('.json') ){
                context.downloadArquivo( context.raw() , downloadArquivo );
            }

        //Se for node
        }if( VECTORIZATION_BUILD_TYPE == 'node' ) {
            
        }

		return context.raw();
	}

    /** IMPORTAR DADOS */

	/**
	* Carrega um arquivo CSV do computador via upload e injeta dentro deste DataStructure
	* @param {Function} callback
	* @param {string} separador Separador usado no CSV (padrão: ',')
	*/
	context.loadCSV = function(callback, separador = ',') {

        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
            // Cria dinamicamente o elemento <input> do tipo "file"
            const inputFile = document.createElement("input");
            inputFile.type = "file";
            inputFile.accept = ".csv"; // Aceita apenas arquivos CSV

            // Adiciona o evento "change" para capturar o arquivo selecionado
            inputFile.addEventListener("change", function(event) {
                const file = event.target.files[0]; // Obtém o primeiro arquivo selecionado

                if (!file) return; // Caso nenhum arquivo seja selecionado, não faz nada

                const reader = new FileReader();

                // Lê o conteúdo do arquivo como texto
                reader.onload = function() {
                    try {
                        const csvData = reader.result;

                        // Divide as linhas do CSV
                        const linhas = csvData.split(/\r?\n/).filter(linha => linha.trim() !== '');

                        // Processa os dados (demais linhas)
                        const dadosTratados = linhas.map(linha => {
                            const valores = linha.split(separador).map(valor => valor.trim());

                            return valores;
                        });

                        context.content = dadosTratados.map(amostra =>
                            Object.values(amostra)
                        );
                        context._matrix2Advanced();
                        context.atualizarQuantidadeColunasLinhas();

                        context.columns = context.content[0]?.length || 0;
                        context.colunas = context.columns;

                        if (callback) {
                            // Chama o callback com os dados CSV
                            callback(dadosTratados, context);
                        }
                    } catch (error) {
                        console.error("Erro ao carregar o arquivo CSV:", error);
                        alert("O arquivo selecionado não é um CSV válido.");
                    }
                };

                // Lê o arquivo
                reader.readAsText(file);

                // Remove o elemento de input do DOM após a leitura
                document.body.removeChild(inputFile);
            });

            // Adiciona o elemento de input ao DOM para que possa ser utilizado
            document.body.appendChild(inputFile);

            // Simula um clique no input para abrir a janela de seleção de arquivo
            inputFile.click();

        //Se for node
        }if( VECTORIZATION_BUILD_TYPE == 'node' ) {

        }
	}

	/**
	* Carrega um arquivo TXT do computador via upload e injeta dentro deste DataStructure.
	* @param {Function} callback Função a ser chamada após carregar os dados.
	* @param {string} separador Separador usado no TXT (padrão: '\t').
	*/
	context.loadTXT = function(callback, separador = '\t') {

        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {

            // Cria dinamicamente o elemento <input> do tipo "file"
            const inputFile = document.createElement("input");
            inputFile.type = "file";
            inputFile.accept = ".txt"; // Aceita apenas arquivos TXT

            // Adiciona o evento "change" para capturar o arquivo selecionado
            inputFile.addEventListener("change", function(event) {
                const file = event.target.files[0]; // Obtém o primeiro arquivo selecionado

                if (!file) return; // Caso nenhum arquivo seja selecionado, não faz nada

                const reader = new FileReader();

                // Lê o conteúdo do arquivo como texto
                reader.onload = function() {
                    try {
                        const txtData = reader.result;

                        // Divide as linhas do TXT
                        const linhas = txtData.split(/\r?\n/).filter(linha => linha.trim() !== '');

                        // Processa os dados (demais linhas)
                        const dadosTratados = linhas.map(linha => {
                            const valores = linha.split(separador).map(valor => valor.trim());

                            return valores;
                        });

                        context.content = dadosTratados.map(amostra =>
                            Object.values(amostra)
                        );
                        context._matrix2Advanced();
                        context.atualizarQuantidadeColunasLinhas();

                        context.columns = context.content[0]?.length || 0;
                        context.colunas = context.columns;

                        if (callback) {
                            // Chama o callback com os dados TXT
                            callback(dadosTratados, context);
                        }
                    } catch (error) {
                        console.error("Erro ao carregar o arquivo TXT:", error);
                        alert("O arquivo selecionado não é um TXT válido.");
                    }
                };

                // Lê o arquivo
                reader.readAsText(file);

                // Remove o elemento de input do DOM após a leitura
                document.body.removeChild(inputFile);
            });

            // Adiciona o elemento de input ao DOM para que possa ser utilizado
            document.body.appendChild(inputFile);

            // Simula um clique no input para abrir a janela de seleção de arquivo
            inputFile.click();

        //Se for node
        }else if( VECTORIZATION_BUILD_TYPE == 'node' ) {

        }
	}

    //return context;
    //Cria um Proxy para permitir acessar os indices da matrix diretamente
    return new Proxy(context, {
        get: function(target, prop, receiver) {
          if (typeof prop === 'string' && !isNaN(prop)) {
            return target.content[Number(prop)];
          }
          return Reflect.get(target, prop, receiver);
        },

        set: function(target, prop, value) {
          //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
          if( target._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
            throw 'Você não pode modificar esta atributo do Vectorization.Matrix!';
          }

          if (typeof prop === 'string' && !isNaN(prop)) {
            target.content[Number(prop)] = value;
            return true;
          }
          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Matrix.isMatrix = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Matrix');
}

window.Vectorization.Matrix.isVectorizationMatrix = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Matrix');
}

module.exports = window.Vectorization.Matrix;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Matrix.js*/
/* ARQUIVO VECTORIZATION: ../src/Matrix-translation.js*/
/*
 * File Name: Matrix-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Matrix._translations = function(){
    const translatedMethods = {
        //English
        "deepLevel": "nivelProfundidade",
        "getDeepLevel": "nivelProfundidade",

        "dotProduct": "produtoEscalar",

        "dotProductMatrix": "produtoEscalarMatrix",

        "dotProductVector": "produtoEscalarVector",

        "multiplyMatrix": "multiplicarMatrix",

        "multiplyNumber": "multiplicarNumero",

        "multiplyVector": "multiplicarVetor",

        "addMatrix": "somarMatrix",

        "addNumber": "somarNumero",

        "addVector": "somarVetor",

        "subtractMatrix": "subtrairMatrix",

        "subtractNumber": "subtrairNumero",

        "subtractVector": "subtrairVetor",

        "divideMatrix": "dividirMatrix",

        "divideNumber": "dividirNumero",

        "divideVector": "dividirVetor",

        "powMatrix": "elevarMatrix",

        "powNumber": "elevarNumero",

        "powVector": "elevarVetor",

        "transposed": "tranposta",

        "oppostMatrix": "matrixOposta",

        "identity": "identidade",

        "extractColumnValues": "extrairValoresColuna",
        "extractColumnsValues": "extrairValoresColunas",
        "extractColumnsValuesExcept": "extrairValoresColunasExceto",

        "extractLineValues": "extrairValoresLinha",

        "blockModifications": "bloquearModificacoes",
        "unblockModifications": "desbloquearModificacoes",

        "planify": "planificar",

        "oneHotColumns": "oneHotColunas",
        "sliceLines": "slice",
        "sliceColumns": "sliceColunas",
        "sliceRegion": "recortarRegiao",

        "removeColumns": "removerColunas",
        "removeColumn": "removerColuna",

        //Portugues
        "obterTransposta": "transposta",
        "somarMatriz": "somarMatrix",
        "subtrairMatriz": "subtrairMatrix",
        "multiplicarMatriz": "multiplicarMatrix",
        "elevarMatriz": "elevarMatrix",
        "produtoEscalarMatriz": "produtoEscalarMatrix",
        "addColuna": "adicionarColuna",
        "preencherLinha": "zerarLinha",
        "preencherColuna": "zerarColuna",
        "preencherColunaOnde": "zerarColunaOnde",
        "paraCadaLinha": "forEach",
        "percorrerElementosColuna": "percorrerColuna",
        "mapearElementosColuna": "mapearColuna",
        "bloquear": "bloquearModificacoes",
        "desbloquear": "desbloquearModificacoes"
    };

    const translatedAttributes = {
        //Portugues
        "valorPreencher": "fillValue",
        "preencherValor": "fillValue",
        "matrizAvancada": "isAdvancedMatrix",
        "matrixAvancada": "isAdvancedMatrix",
        "linhas": "rows",
        "colunas": "columns",

        //English
        //Ingles
        "blocked": "bloqueado",
        "allowBlock": "permitirBloquear",
        "allowUnblock": "permitirDesbloquear",
        "deepMatrix": "matrixProfunda"
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Matrix._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Matrix-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/StringMatrix.js*/
/*
 * File Name: StringMatrix.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    require('./Root'); 
    require('./Scalar');
    require('./Vector');
    require('./StringVector');
    require('./Matrix');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringMatrix = function( config=[], classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.StringMatrix._translations || null;
    classConfig['advanced'] = false;
    classConfig['usarTexto'] = true;

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.StringMatrix.isStringMatrix(config) && config.objectName == 'StringMatrix' ){
        return Vectorization.StringMatrix( config.values() );
    }

    //O StringMatrix será baseado no Vectorization.Matrix
    let context = window.Vectorization.Matrix(config, classConfig);
    context.objectName = 'StringMatrix';
    context.extendedFrom = 'Matrix';
    context.path = 'Vectorization.StringMatrix';
    context.configRecebidaUsuario = config;

    /**
    * @override
    * Método que converte a matrix para uma matrix avançada, onde cada linha é um Vector 
    */
    context._matrix2Advanced = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            extraPropsOfLine['index'] = i;
            extraPropsOfLine['usarTexto'] = true;

            context.content[i] = Vectorization.StringVector(context.content[i], extraPropsOfLine);
        }
        context.isAdvancedMatrix = true;
    }

    context._matrix2Advanced();

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    return context;
}

window.Vectorization.StringMatrix.isStringMatrix = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'StringMatrix' )
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringMatrix.js*/
/* ARQUIVO VECTORIZATION: ../src/StringMatrix-translation.js*/
/*
 * File Name: StringMatrix-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringMatrix._translations = function(){
    const translatedMethods = {
       
    };

    const translatedAttributes = {
       
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.StringMatrix._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringMatrix-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Random.js*/
/*
 * File Name: Random.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    
    require('./Root'); 

    if( window.Vectorization.Scalar == undefined ){
        require('./Scalar');
    }

    if( window.Vectorization.Vector == undefined ){
        require('./Vector');
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

//Classe que possui métodos para gerar números aleatórios do Vectorization
window.Vectorization.Random = function( classConfig={} ){
    let context = {... classConfig};
    context.value = value;
    context.objectName = 'Random';
    context.path = 'Vectorization.Random';
    return context;
}

/**
* Métodos estáticos
*/
window.Vectorization.Random._sementes = [
    //Passos por semente
    {
        sequencia: [2, -5, 8, 0.5, 3, 4.8, 1, 0.00001, 12, 2, 3, 7, 9, 15, 25, 0.8, 1, 0,5],
        multiplicador: 0.5
    },
    {
        sequencia: [5.555555555555555, -13.88888888888889, 22.22222222222222, 1.3888888888888888, 8.333333333333334, 13.333333333333332, 2.7777777777777777, 0.00002777777777777778, 33.333333333333336, 5.555555555555555, 8.333333333333334, 19.444444444444443, 25, 41.666666666666664, 69.44444444444444, 2.2222222222222223, 2.7777777777777777, 0.152, 13.88888888888889],
        multiplicador: 1.5
    },
    {
        sequencia: [0.75, -1.875, 3, 0.1875, 1.1250000000000002, 1.8000000000000003, 0.375, 0.00000375, 4.500000000000001, 0.75, 1.1250000000000002, 2.625, 3.375, 5.625, 9.375, 0.30000000000000004, 0.375, 0, 1.875],
        multiplicador: 4.5
    },
    {
        sequencia: [-1.0666666666666667, 2.6666666666666665, -4.266666666666667, -0.26666666666666666, -1.5999999999999999, -2.56, -0.5333333333333333, -0.000005333333333333334, -6.3999999999999995, -1.0666666666666667, -1.5999999999999999, -3.7333333333333334, -4.8, -8, -13.333333333333334, -0.42666666666666664, -0.5333333333333333, -0.25, -2.6666666666666665],
        multiplicador: 8
    }
]

//Inicializa a vezesJaUsouAteAgora de todas elas, pra nao repetir os mesmos numeros
for( let i = 0 ; i < window.Vectorization.Random._sementes.length ; i++ ){
    const sequenciaAtual = window.Vectorization.Random._sementes[i];
    sequenciaAtual.vezesJaUsouAteAgora = 0;
    sequenciaAtual.indiceAtual = 0;
}

window.Vectorization.Random._numeroSementePadraoDefinida = 5;

//Extrai os dados da semente definida pelo úsuario
window.Vectorization.Random._get_dados_semente = function(numeroDaSemente){
    let iSemente = 0;
    let sementeAtual = {... window.Vectorization.Random._sementes[0]};
    let iContadorIteracao = 0;

    while( iContadorIteracao <= Number.parseInt(numeroDaSemente) )
    {
        if(iSemente > window.Vectorization.Random._sementes.length - 1){
            sementeAtual = {... window.Vectorization.Random._sementes[0]};
            iSemente = 0;
        }

        sementeAtual = {... window.Vectorization.Random._sementes[iSemente]};
        iSemente++;

        iContadorIteracao++;
    }

    if(sementeAtual){
        return sementeAtual;

    }else{
        throw 'Erro ao tentar obter os dados da semente!. Tente outra.'
    }
}

window.Vectorization.Random._sementeDefinida = window.Vectorization.Random._get_dados_semente( window.Vectorization.Random._numeroSementePadraoDefinida );

window.Vectorization.Random.definirSemente = function(numeroDaSemente){
    switch(typeof numeroDaSemente){
        case 'number':
            window.Vectorization.Random._sementeDefinida = window.Vectorization.Random._get_dados_semente(numeroDaSemente);
            window.Vectorization.Random._numeroSementeDefinida = numeroDaSemente;
            break;

        //Se for um objeto do Vectorization
        case 'object':
        case 'function':
            if( numeroDaSemente.sequencia != undefined &&
                numeroDaSemente.multiplicador != undefined &&
                numeroDaSemente.sequencia.length > 2 &&
                numeroDaSemente.vezesJaUsouAteAgora != undefined
            ){
                window.Vectorization.Random._sementeDefinida = window.Vectorization.Random._get_dados_semente(numeroDaSemente);
            }
            break;

    }
}

/**
* @param {Object} sementeAtual 
* @returns {Number}
*/
window.Vectorization.Random.proximoNumeroDaSequenciaSemente = function(sementeAtual){
    let sequenciaVector = Vectorization.Vector(sementeAtual.sequencia);
    if( sementeAtual.indiceAtual > sequenciaVector.length-1 ){
        sementeAtual.indiceAtual = 0;
    }

    let meuNumeroTal = sequenciaVector.readIndex(sementeAtual.indiceAtual);
    sementeAtual.indiceAtual++;
    sementeAtual.vezesJaUsouAteAgora++;

    //Vai variando os valores
    let operacaoAAplicar = sementeAtual.indiceAtual % 2 == 0 ? '+' : '-';

    if( sementeAtual.indiceAtual < sequenciaVector.length ){
        if( sementeAtual.numeroAnterior != undefined && typeof sementeAtual.numeroAnterior == 'number' ){
            switch(operacaoAAplicar){
                case '+':
                    sementeAtual.sequencia[sementeAtual.indiceAtual] += ( (1/100 * sementeAtual.numeroAnterior) );
                    break;
                case '-':
                    sementeAtual.sequencia[sementeAtual.indiceAtual] -= ( (1/100 * sementeAtual.numeroAnterior) );
                    break;
            }
        }
    }

    let numeroGeradoDeAgora = ( (meuNumeroTal * sementeAtual.multiplicador) / (sementeAtual.vezesJaUsouAteAgora < 100 ? sementeAtual.vezesJaUsouAteAgora+10 : sementeAtual.vezesJaUsouAteAgora) ) * meuNumeroTal * sementeAtual.multiplicador;
    sementeAtual.numeroAnterior = numeroGeradoDeAgora;
    return numeroGeradoDeAgora;
}

/**
 * Permite gerar um número aleatorio entre um número inicial e final
 * Isso respeita o template definido, fazendo com que os números gerado sejam sempre os mesmos
 * 
 * @param {Number} minimo 
 * @param {Number} maximo 
 * @param {Number} sementeDefinida 
 * @returns {Number}
 */
window.Vectorization.Random.gerarNumeroAleatorio = function(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida){
    //Verificar a semente
    let sementeAleatoria = null;
    if( sementeDefinida != undefined && typeof sementeDefinida == 'number' ){
        sementeAleatoria = window.Vectorization.Random._get_dados_semente(sementeDefinida);
    }else{
        sementeAleatoria = sementeDefinida;
    }

    //Gerar o valor
    let sequenciaVector = Vectorization.Vector(sementeAleatoria.sequencia);
    let base = sequenciaVector.media() + (Math.PI * sequenciaVector.media()/2);
    let meuNumeroQualquer = (base + (maximo / (minimo+1.2) ) * (25/100 * base)) + minimo;

    //Isso obriga o número a ser menor que o limite(valor máximo que definimos)
    let maxTentativas = 500;
    let quantidadeTentativas = 0;
    while( meuNumeroQualquer > maximo ){
        if( quantidadeTentativas > maxTentativas ){
            break;
        }

        meuNumeroQualquer = window.Vectorization.Random.proximoNumeroDaSequenciaSemente(sementeAleatoria);
        quantidadeTentativas++;
    }

    if( quantidadeTentativas > maxTentativas ){
        meuNumeroQualquer = meuNumeroQualquer - maximo;

        if( meuNumeroQualquer < minimo ){
            meuNumeroQualquer += (minimo/2.5) * (2/100 * base);
        }
    }

    meuNumeroQualquer += minimo;

    return meuNumeroQualquer;
}

/**
 * Permite gerar um número aleatorio entre um número inicial e final
 * Isso respeita o template definido, fazendo com que os números gerado sejam sempre os mesmos
 * 
 * @param {Number} minimo 
 * @param {Number} maximo 
 * @param {Number} sementeDefinida 
 * @returns {Number}
 */
window.Vectorization.Random.gerarNumeroInteiroAleatorio = function(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida){
    let numeroAleatorioAtual = window.Vectorization.Random.gerarNumeroAleatorio(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida);
    return Number.parseInt(numeroAleatorioAtual);
}

/**
 * Permite gerar um número aleatorio entre um número inicial e final
 * Isso respeita o template definido, fazendo com que os números gerado sejam sempre os mesmos
 * 
 * @param {Number} minimo 
 * @param {Number} maximo 
 * @param {Number} sementeDefinida 
 * @returns {Number}
 */
window.Vectorization.Random.gerarNumeroFloatAleatorio = function(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida){
    let numeroAleatorioAtual = window.Vectorization.Random.gerarNumeroAleatorio(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida);
    return Number.parseFloat(numeroAleatorioAtual);
}


//Cria uma cópia segura das sementes como elas estavam antes de serem manipuladas/utilizadas pelo usuario
window.Vectorization.Random._sementesIniciais = Vectorization.Vector([... window.Vectorization.Random._sementes.copyWithin()]).duplicar();
window.Vectorization.Random._sementeDefinidaInicial = {... window.Vectorization.Random._sementeDefinida};

window.Vectorization.Random.resetarEstadoInicial = function(){
    window.Vectorization.Random._sementes = window.Vectorization.Random._sementesIniciais.duplicar().valores();
    window.Vectorization.Random.definirSemente( window.Vectorization.Random._numeroSementePadraoDefinida );
    window.Vectorization.Random._sementeDefinida = {... window.Vectorization.Random._sementeDefinidaInicial};
    console.warn('sementes aleatórias redefinidas!')
}


module.exports = window.Vectorization.Random;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Random.js*/
/* ARQUIVO VECTORIZATION: ../src/Random-translation.js*/
/*
 * File Name: Random-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Random._translations = function(){
    const translatedMethods = {
        //English
        'generateRandomNumericalValue': 'gerarNumeroAleatorio',
        'generateRandomFloatNumericalValue': 'gerarNumeroFloatAleatorio',
        'generateRandomIntegerNumericalValue': 'gerarNumeroInteiroAleatorio',
        'especifyOriginalInitialPoint': 'definirSemente'
    };

    const translatedAttributes = {
        
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

let randomClasseBase = window.Vectorization.Base(window.Vectorization.Random);

//Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
randomClassConfig = randomClasseBase.translateAttributes_andReturn(window.Vectorization.Random, window.Vectorization.Random._translations() );

//Se existir uma tradução para a classe
if(window.Vectorization.Random._translations && typeof window.Vectorization.Random._translations === 'function'){
    randomClasseBase.applyTranslations( window.Vectorization.Random._translations() );
}

//Passando as configurações pra dentro da classe Vectorization.Random
let todasConfiguracoesClassConfig = randomClasseBase.getTodasConfiguracoesAplicadas();
let keysConfiguracoesClassConfig = [... Object.keys(randomClasseBase)];

for( let i = 0 ; i < todasConfiguracoesClassConfig.quantidadeDentro ; i++ )
{   
    let nomeConfiguracaoClassConfig = keysConfiguracoesClassConfig[i],
        valorConfiguracaoClassConfig = todasConfiguracoesClassConfig.configuracoesUsadas[nomeConfiguracaoClassConfig];

    if( window.Vectorization.Random[ nomeConfiguracaoClassConfig ] == undefined )
    {
        window.Vectorization.Random[ nomeConfiguracaoClassConfig ] = valorConfiguracaoClassConfig;
    }
}

module.exports = window.Vectorization.Random._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Random-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Envelope.js*/
/*
 * File Name: Envelope.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Um objeto chamado literalmente de Envelope, para permitir "envelopar" varios objetos de diversos tipos, e permitir executar algum método em todos eles.
 * Ao executar um método em um Envelope, ele vai executar esse método em cada objeto que ele está armazenando. E vai retornar um novo Envelope, conténdo os resultados, que podem ser números, vetores, matrizes, ou qualquer coisa que o método escolhido para ser aplicado retorne.
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 

    if( window.Vectorization.Random == undefined ){
        require('./Root'); 
        require('./Random'); 
    }

    if( window.Vectorization.Utilidades == undefined ){
        require('./Utilidades'); 
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Envelope = function( arrayObjetos=[], classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Envelope._translations || null;

    let classeBase = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBase.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    let context = window.Vectorization.Base({... classConfig});

    context.objectName = 'Envelope';
    context.path = 'Vectorization.Envelope';
    context.arrayObjetos = arrayObjetos;

    context.adicionarObjeto = function( objeto ){
        context.arrayObjetos.push( objeto );
    }

    context.raw = function(){
        return context.arrayObjetos;
    }

    /*
    * Calcula a média de cada objeto que estiver dentro do Envelope
    * O tipo de retorno não tem uma flexibilide definida. Vai depender os objetos que temos dentro do Envelope e do tipo de retorno que o método usado retorna
    */
    //context.media = function(){
    //    let novoEnvelope = Vectorization.Envelope([], classConfig);
        
    //    for( let i = 0 ; i < context.arrayObjetos.length ; i++ ){
    //        novoEnvelope.adicionarObjeto( context.arrayObjetos[i].media() );
    //    }

    //    return novoEnvelope;
    //}

    context.storedClassConfig = classConfig || {};

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    return new Proxy(context, {
        /*
        * Calcula o resultado do NOME_ALGUM_MÈTODO de cada objeto que estiver dentro do Envelope
        * O tipo de retorno não tem uma flexibilide definida. Vai depender os objetos que temos dentro do Envelope e do tipo de retorno que o método usado retorna
        *
        * PERMITE FAZER envelope.NOME_ALGUM_MÈTODO(); 
        * 
        * Por exemplo:
        *   V.Envelope([ vec1, vec2, matrix1 ]).algumaMetodo().raw()
        * 
        * Ele vai tentar executar o método 'algumaMetodo' dentro de cada objeto: vec1, vec2 e matrix1
        */
        get: function(target, prop) {
            if (typeof prop === 'string' && typeof target[prop] === 'undefined') {
                // Verifica se o método existe em cada objeto dentro de arrayObjetos
                return function(...args) {
                    // Cria um Envelope para guardar os resultados
                    let novoEnvelope = Vectorization.Envelope([], classConfig);

                    // Tenta executar o método em cada objeto e adiciona o resultado ao novo Envelope
                    for (let i = 0; i < target.arrayObjetos.length; i++) 
                    {
                        let obj = target.arrayObjetos[i];

                        if (typeof obj[prop] === 'function') {
                            novoEnvelope.adicionarObjeto(obj[prop](...args));  // Executa o método no objeto
                        }else{
                            novoEnvelope.adicionarObjeto(null);  // INDICA QUE O MÈTODO NÂO EXISTIA
                        }
                    }

                    return novoEnvelope;
                };
            }
            return target[prop];
        },

        set: function(target, prop, value) {
          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Envelope.isEnvelope = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Envelope');
}

module.exports = window.Vectorization.Envelope;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Envelope.js*/
/* ARQUIVO VECTORIZATION: ../src/Envelope-translation.js*/
/*
 * File Name: Envelope-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Envelope._translations = function(){
    const translatedMethods = {
        "raw": "bruto"
    };

    const translatedAttributes = {
        "path": "caminho"
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Envelope._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Envelope-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Vectorization.js*/
/*
 * File Name: Vectorization.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

var Vectorization_4Node = class{
    constructor(){
        if( typeof window !== 'undefined' && window.isbrowser == true ){
            throw 'This class only works in Node';
        }

        //Se for node
        if( window.isbrowser == false && window.iscompilation == false )
        {
            //Importando classe raiz
            this.Root = require('./Root');

            this.Utilidades = require('./Utilidades');

            //Importando numeros escalares
            this.Scalar = require('./Scalar');
            this.Scalar_translation = require('./Scalar-translation');

            //Importando Text
            this.Scalar = require('./Text');
            this.Scalar_translation = require('./Text-translation');

            //Importando Vetores
            this.Vector = require('./Vector');
            this.Vector_translation = require('./Vector-translation');

            //Importando Vetores de String
            this.StringVector = require('./StringVector');
            this.StringVector_translation = require('./StringVector-translation');

            this.Random = require('./Random');
            this.Random_translation = require('./Random-translation');

            //Importando Matrizes
            this.Matrix = require('./Matrix');
            this.Matrix_translation = require('./Matrix-translation');
            
            this.StringMatrix = require('./StringMatrix');
            this.StringMatrix_translation = require('./StringMatrix-translation');
        }

        return window.Vectorization;
    }
}; 

module.exports = new Vectorization_4Node();
/* FIM DO ARQUIVO VECTORIZATION: ../src/Vectorization.js*/

window.isbrowser = true;

window.iscompilation = true
/* FIM DO ARQUIVO: ../libs/Vectorization-builded.js*/
/* ARQUIVO: ../src/Base.js*/
Analise = {};

//Constantes
Analise.IGNORE = '$#_IGNORE_CAMPO'; //Usado para ignorar um campo quando vai usar o método mergeWith com o parametro sobrescrever=true. Caso o valor do campo seja Analise.IGNORE, o valor deste campo não será sobrescrito

Analise.libs = {
    Vectorization: window.Vectorization
};

Analise.Base = function( config, parametrosAdicionais={} ){
    const context = Vectorization.Matrix(config, parametrosAdicionais);

    /**
    * Copia parametros para dentro da instancia desse objeto 
    * @param {JSON} parametros 
    */
    context.copyParametros = function( parametros={} ){
        const chaves = Object.keys( parametros );

        for( let i = 0 ; i < chaves.length ; i++ )
        {
            const chaveAtual = chaves[i];
            const valorChave = parametros[ chaveAtual ];

            //Atribui o valor
            this[ chaveAtual ] = valorChave;
        }
    }

    context.downloadArquivo = function(data, filename='dados.json'){
        // Verifica se o data é um objeto; se não for, assume que já é JSON válido.
        const jsonData = typeof data === "object" ? JSON.stringify(data, null, 2) : data;

        // Cria um blob com os dados JSON.
        const blob = new Blob([jsonData], { type: "application/json" });

        // Cria uma URL temporária para o blob.
        const url = URL.createObjectURL(blob);

        // Cria um elemento <a> para disparar o download.
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;

        // Adiciona o elemento <a> ao DOM e simula um clique.
        document.body.appendChild(a);
        a.click();

        // Remove o elemento <a> do DOM.
        document.body.removeChild(a);

        // Revoga a URL temporária.
        URL.revokeObjectURL(url);
    }

    return context;
}

//Alias
window.A = window.Analise;
/* FIM DO ARQUIVO: ../src/Base.js*/
/* ARQUIVO: ../src/DataStructure.js*/
Analise.DataStructure = function( dadosIniciais=[] , config={} ){
	let parametrosAdicionais = {
		flexibilidade: config.flexibilidade || null
	};

	let map_keysIdentificadas = {};

	let dadosIniciais_tratados  = [];

	let tipoDadosIniciais       = undefined;

	//Tratar os dados iniciais
	//Se for um array de JSON
	if( typeof dadosIniciais == 'object' && !(dadosIniciais[0] instanceof Array) )
	{
		tipoDadosIniciais = 'JSON_ARRAY';

		//Para cada amostra
		for( let i = 0 ; i < dadosIniciais.length ; i++ )
		{
			//Extrai as informações
			const amostraJSON     = dadosIniciais[i];
			const keysAmostra     = Object.keys(amostraJSON);

			//Vai salvando as chaves no mapa de chaves identificadas
			keysAmostra.forEach(function(chave){
				map_keysIdentificadas[chave] = true;
			});

			const valoresAmostra  = Object.values(amostraJSON);

			//Joga os dados da amostra no Array
			dadosIniciais_tratados.push(valoresAmostra);
		}

	//Se for uma Matrix
	}else if( dadosIniciais[0] instanceof Array ){
		tipoDadosIniciais = 'Matrix';

		//Atribui os dados ao dadosIniciais_tratados
		dadosIniciais_tratados = JSON.parse(JSON.stringify(dadosIniciais));
	}

    const context = Analise.Base(dadosIniciais_tratados, parametrosAdicionais);
	
	context.idObjeto = new Date().getTime();

	context.tipoDadosIniciais = tipoDadosIniciais;
	context.keysIdentificadas = [];

	context.parametrosAdicionais = parametrosAdicionais || {};
	context.objectName = 'DataStructure';
	context.extendedFrom = 'Matrix';

	context.dadosIniciais = dadosIniciais;

	context.mapaCampos  = {};

	//Pega o nome dos campos
	switch(tipoDadosIniciais)
	{
		//Se for Matrix, os keysIdentificadas vai ser o mesmo que config.campos
		case 'Matrix':
			context.keysIdentificadas = config.campos || [];
			context.nomesCampos       = config.campos || [];
			break;

		case 'JSON_ARRAY':
			context.keysIdentificadas = config.campos || Object.keys( map_keysIdentificadas );
			context.nomesCampos       = config.campos || context.keysIdentificadas;
			break;
	}

	/**
	* Exporta os dados deste DataStructure para um formato JSON
	* @returns {Array}
	*/
	context.exportarJSON = function( downloadArquivo=null ){
		const dadosConvertidos = [];

		//Percorre cada amostra
		context.forEach(function( indiceElemento, amostraVector, contexto ){
			const estruturaCamposAmostra = {};
			
			//Obtem os valores dos campos para a amostra atual
			context.nomesCampos.forEach(function(nomeCampo){

				estruturaCamposAmostra[nomeCampo] = amostraVector.getCampo( nomeCampo )
				                                                 .raw();

			});

			//Adiciona os dados JSON da amostra atual na lista
			dadosConvertidos.push(estruturaCamposAmostra);
		});

		if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
			if(downloadArquivo && downloadArquivo.endsWith('.json') ){
				context.downloadArquivo( dadosConvertidos , downloadArquivo );
			}

		//Se for node
		}else if( VECTORIZATION_BUILD_TYPE == 'node' ) {

		}

		return dadosConvertidos;
	}

	/**
	* Exporta os dados deste DataStructure para um formato JSON completo
	* @returns {Object}
	*/
	context.exportarJSON_indexado = function( downloadArquivo=null ){
		const dadosConvertidos = {};

		//Percorre cada amostra
		context.forEach(function( indiceElemento, amostraVector, contexto ){
			const estruturaCamposAmostra = {};
			
			//Obtem os valores dos campos para a amostra atual
			context.nomesCampos.forEach(function(nomeCampo){

				estruturaCamposAmostra[nomeCampo] = amostraVector.getCampo( nomeCampo )
				                                                 .raw();

			});

			//Adiciona os dados JSON da amostra atual na lista
			dadosConvertidos[ indiceElemento ] = estruturaCamposAmostra;
		});

		if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
			if(downloadArquivo && downloadArquivo.endsWith('.json') ){
				context.downloadArquivo( dadosConvertidos , downloadArquivo );
			}

		//Se for node
		}else if( VECTORIZATION_BUILD_TYPE == 'node' ) {

		}

		return dadosConvertidos;
	}

	/**
	* Exporta os dados para um JSON que contém ARRAYS para os dados das colunas
	*/
	context.exportarJSON_colunas = function( downloadArquivo=null ){
		
		const dadosJSON_ARRAY = {};

		context.getNomeCampos().forEach(function(nomeCampo){
			const dadosCampo = context.extrairValoresCampo(nomeCampo).rawProfundo();
			dadosJSON_ARRAY[nomeCampo] = dadosCampo;
		});

		if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
			if(downloadArquivo && downloadArquivo.endsWith('.json') ){
				context.downloadArquivo( dadosJSON_ARRAY , downloadArquivo );
			}

		//Se for node
		}else if( VECTORIZATION_BUILD_TYPE == 'node' ) {

		}

		return dadosJSON_ARRAY;
	}

	/**
	* Exporta os dados deste DataStructure para um formato CSV com separador configurável
	* @param {string|null} downloadArquivo Nome do arquivo para download (opcional)
	* @param {string} separador Separador de colunas (padrão: ',')
	*/
	context.exportarCSV = function(downloadArquivo = null, separador = ',') {
		let csvConteudo = '';

		// Gera a linha de cabeçalho (nomes dos campos)
		const linhaCabecalho = context.nomesCampos.join(separador);
		csvConteudo += linhaCabecalho + '\n';

		// Percorre cada amostra
		context.forEach(function(indiceElemento, amostraVector, contexto) {
			const linhaValores = context.nomesCampos.map(function(nomeCampo) {
				const valorCampo = amostraVector.getCampo(nomeCampo).raw();

				// Escapa valores que contêm o separador ou aspas
				if (typeof valorCampo === 'string' && (valorCampo.includes(separador) || valorCampo.includes('"'))) {
					return `"${valorCampo.replace(/"/g, '""')}"`;
				}
				return valorCampo;
			}).join(separador);

			// Adiciona a linha atual ao conteúdo do CSV
			csvConteudo += linhaValores + '\n';
		});

		//Corta o \n sozinho no final
        if( csvConteudo.endsWith('\n') ){
            csvConteudo = csvConteudo.slice(0, csvConteudo.length-String('\n').length);
        }

		if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
			// Faz o download do arquivo, se solicitado
			if (downloadArquivo && downloadArquivo.endsWith('.csv')) {
				context.downloadArquivo(csvConteudo, downloadArquivo);
			}

		//Se for node
		}else if( VECTORIZATION_BUILD_TYPE == 'node' ) {

		}

		return csvConteudo;
	}

	/**
	* Exporta os dados deste DataStructure para um formato TXT com separador configurável.
	* @param {string|null} downloadArquivo Nome do arquivo para download (opcional).
	* @param {string} separador Separador de colunas (padrão: '\t').
	* @returns {string} Conteúdo do arquivo TXT.
	*/
	context.exportarTXT = function(downloadArquivo = null, separador = '\t') {
		let txtConteudo = '';

		// Gera a linha de cabeçalho (nomes dos campos)
		const linhaCabecalho = context.nomesCampos.join(separador);
		txtConteudo += linhaCabecalho + '\n';

		// Percorre cada amostra
		context.forEach(function(indiceElemento, amostraVector, contexto) {
			const linhaValores = context.nomesCampos.map(function(nomeCampo) {
				const valorCampo = amostraVector.getCampo(nomeCampo).raw();

				// Escapa valores que contêm o separador
				if (typeof valorCampo === 'string' && valorCampo.includes(separador)) {
					return `"${valorCampo}"`; // Adiciona aspas apenas se houver o separador no valor
				}
				return valorCampo;
			}).join(separador);

			// Adiciona a linha atual ao conteúdo do TXT
			txtConteudo += linhaValores + '\n';
		});

		//Corta o \n sozinho no final
        if( txtConteudo.endsWith('\n') ){
            txtConteudo = txtConteudo.slice(0, txtConteudo.length-String('\n').length);
        }

		if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
			// Faz o download do arquivo, se solicitado
			if (downloadArquivo && downloadArquivo.endsWith('.txt')) {
				context.downloadArquivo(txtConteudo, downloadArquivo);
			}

		//Se for node
		}else if( VECTORIZATION_BUILD_TYPE == 'node' ){


		}

		return txtConteudo;
	}

	/**
	* Carrega um arquivo JSON do computador via upload e depois injeta dentro deste DataStructure
	* @param {Function} callback 
	*/
	context.loadJSON = function(callback) {

		if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
			// Cria dinamicamente o elemento <input> do tipo "file"
			const inputFile = document.createElement("input");
			inputFile.type = "file";
			inputFile.accept = ".json"; // Aceita apenas arquivos JSON
		
			// Adiciona o evento "change" para capturar o arquivo selecionado
			inputFile.addEventListener("change", function (event) {
				const file = event.target.files[0]; // Obtém o primeiro arquivo selecionado
		
				if (!file) return; // Caso nenhum arquivo seja selecionado, não faz nada
		
				const reader = new FileReader();
		
				// Lê o conteúdo do arquivo como texto
				reader.onload = function () {
					try {
						// Parseia o conteúdo do arquivo para JSON
						const jsonData = JSON.parse(reader.result);
						
						//Para cada amostra
						const dados_tratados = [];
						const map_keysIdentificadas_tratado = {};

						for( let i = 0 ; i < jsonData.length ; i++ )
						{
							//Extrai as informações
							const amostraJSON     = jsonData[i];
							const keysAmostra     = Object.keys(amostraJSON);
				
							//Vai salvando as chaves no mapa de chaves identificadas
							keysAmostra.forEach(function(chave){
								map_keysIdentificadas_tratado[chave] = true;
							});
				
							const valoresAmostra  = Object.values(amostraJSON);
				
							//Joga os dados da amostra no Array
							dados_tratados.push(valoresAmostra);
						}

						//Se os campos não existem neste DataStructure, cria
						context.keysIdentificadas = Object.keys( map_keysIdentificadas_tratado );
						context.nomesCampos       = context.keysIdentificadas;

						context.content = dados_tratados;
						context._matrix2Advanced();
						context.mapearNomes();
						context.atualizarQuantidadeColunasLinhas();

						//Atualiza a quantidade das colunas
						//Como é um JSON, vai precisar calcular de forma diferente as colunas
						context.columns = context.content[0].length;
						context.colunas = context.columns;

						context.injetarFuncoesAmostras();

						if(callback)
						{
							// Chama o callback com os dados JSON
							callback(jsonData, context);
						}

					} catch (error) {
						console.error("Erro ao carregar o arquivo JSON:", error);
						alert("O arquivo selecionado não é um JSON válido.");
					}
				};
		
				// Lê o arquivo
				reader.readAsText(file);
		
				// Remove o elemento de input do DOM após a leitura
				document.body.removeChild(inputFile);
			});
		
			// Adiciona o elemento de input ao DOM para que possa ser utilizado
			document.body.appendChild(inputFile);
		
			// Simula um clique no input para abrir a janela de seleção de arquivo
			inputFile.click();

		//Se for node
		}else if( VECTORIZATION_BUILD_TYPE == 'node' ){
			
		}
	}

	/**
	* Carrega um arquivo JSON do computador via upload e depois injeta dentro deste DataStructure
	* @param {Function} callback 
	*/
	context.loadJSON_indexado = function(callback) {

		if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
			// Cria dinamicamente o elemento <input> do tipo "file"
			const inputFile = document.createElement("input");
			inputFile.type = "file";
			inputFile.accept = ".json"; // Aceita apenas arquivos JSON
		
			// Adiciona o evento "change" para capturar o arquivo selecionado
			inputFile.addEventListener("change", function (event) {
				const file = event.target.files[0]; // Obtém o primeiro arquivo selecionado
		
				if (!file) return; // Caso nenhum arquivo seja selecionado, não faz nada
		
				const reader = new FileReader();
		
				// Lê o conteúdo do arquivo como texto
				reader.onload = function () {
					try {
						// Parseia o conteúdo do arquivo para JSON
						const jsonData = JSON.parse(reader.result);
						
						//Para cada amostra
						const dados_tratados = [];
						const map_keysIdentificadas_tratado = {};

						for( let i = 0 ; i < Object.keys(jsonData).length ; i++ )
						{
							//Extrai as informações
							const amostraJSON     = jsonData[i];
							const keysAmostra     = Object.keys(amostraJSON);
				
							//Vai salvando as chaves no mapa de chaves identificadas
							keysAmostra.forEach(function(chave){
								map_keysIdentificadas_tratado[chave] = true;
							});
				
							const valoresAmostra  = Object.values(amostraJSON);
				
							//Joga os dados da amostra no Array
							dados_tratados.push(valoresAmostra);
						}

						//Se os campos não existem neste DataStructure, cria
						context.keysIdentificadas = Object.keys( map_keysIdentificadas_tratado );
						context.nomesCampos       = context.keysIdentificadas;

						context.content = dados_tratados;
						context._matrix2Advanced();
						context.mapearNomes();
						context.atualizarQuantidadeColunasLinhas();

						//Atualiza a quantidade das colunas
						//Como é um JSON, vai precisar calcular de forma diferente as colunas
						context.columns = context.content[0].length;
						context.colunas = context.columns;

						context.injetarFuncoesAmostras();

						if(callback)
						{
							// Chama o callback com os dados JSON
							callback(jsonData, context);
						}

					} catch (error) {
						console.error("Erro ao carregar o arquivo JSON:", error);
						alert("O arquivo selecionado não é um JSON válido.");
					}
				};
		
				// Lê o arquivo
				reader.readAsText(file);
		
				// Remove o elemento de input do DOM após a leitura
				document.body.removeChild(inputFile);
			});
		
			// Adiciona o elemento de input ao DOM para que possa ser utilizado
			document.body.appendChild(inputFile);
		
			// Simula um clique no input para abrir a janela de seleção de arquivo
			inputFile.click();

		//Se for node
		}else if( VECTORIZATION_BUILD_TYPE == 'node' ){
			
		}
	}

	/**
	* Carrega um arquivo JSON do computador via upload e depois injeta dentro deste DataStructure
	* @param {Function} callback 
	*/
	context.loadJSON_colunas = function(callback) {

		if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
			// Cria dinamicamente o elemento <input> do tipo "file"
			const inputFile = document.createElement("input");
			inputFile.type = "file";
			inputFile.accept = ".json"; // Aceita apenas arquivos JSON
		
			// Adiciona o evento "change" para capturar o arquivo selecionado
			inputFile.addEventListener("change", function (event) {
				const file = event.target.files[0]; // Obtém o primeiro arquivo selecionado
		
				if (!file) return; // Caso nenhum arquivo seja selecionado, não faz nada
		
				const reader = new FileReader();
		
				// Lê o conteúdo do arquivo como texto
				reader.onload = function () {
					try {
						// Parseia o conteúdo do arquivo para JSON
						const jsonData = JSON.parse(reader.result);
						
						//Para cada amostra
						const dados_tratados = [];
						const map_keysIdentificadas_tratado = {};

						const camposPresentes    = Object.keys(jsonData);
						const quantidadeCampos   = camposPresentes.length;
						const quantidadeAmostras = jsonData[ camposPresentes[0] ].length;

						for( let i = 0 ; i < quantidadeAmostras ; i++ )
						{
							//Extrai as informações
							const dadosAmostra = [];

							//Para cada campo
							camposPresentes.forEach(function(nomeCampo){
								dadosAmostra.push( jsonData[nomeCampo][i] );
							});

							const keysAmostra     = camposPresentes;
				
							//Vai salvando as chaves no mapa de chaves identificadas
							keysAmostra.forEach(function(chave){
								map_keysIdentificadas_tratado[chave] = true;
							});
				
							const valoresAmostra = dadosAmostra;
				
							//Joga os dados da amostra no Array
							dados_tratados.push(valoresAmostra);
						}

						//Se os campos não existem neste DataStructure, cria
						context.keysIdentificadas = Object.keys( map_keysIdentificadas_tratado );
						context.nomesCampos       = context.keysIdentificadas;

						context.content = dados_tratados;
						context._matrix2Advanced();
						context.mapearNomes();
						context.atualizarQuantidadeColunasLinhas();

						//Atualiza a quantidade das colunas
						//Como é um JSON, vai precisar calcular de forma diferente as colunas
						context.columns = context.content[0].length;
						context.colunas = context.columns;

						context.injetarFuncoesAmostras();

						if(callback)
						{
							// Chama o callback com os dados JSON
							callback(jsonData, context);
						}

					} catch (error) {
						console.error("Erro ao carregar o arquivo JSON:", error);
						alert("O arquivo selecionado não é um JSON válido.");
					}
				};
		
				// Lê o arquivo
				reader.readAsText(file);
		
				// Remove o elemento de input do DOM após a leitura
				document.body.removeChild(inputFile);
			});
		
			// Adiciona o elemento de input ao DOM para que possa ser utilizado
			document.body.appendChild(inputFile);
		
			// Simula um clique no input para abrir a janela de seleção de arquivo
			inputFile.click();

		//Se for node
		}else if( VECTORIZATION_BUILD_TYPE == 'node' ){
			
		}
	}

	/**
	* Carrega um arquivo CSV do computador via upload e injeta dentro deste DataStructure
	* @param {Function} callback
	* @param {string} separador Separador usado no CSV (padrão: ',')
	*/
	context.loadCSV = function(callback, separador = ',') {

		if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
			// Cria dinamicamente o elemento <input> do tipo "file"
			const inputFile = document.createElement("input");
			inputFile.type = "file";
			inputFile.accept = ".csv"; // Aceita apenas arquivos CSV

			// Adiciona o evento "change" para capturar o arquivo selecionado
			inputFile.addEventListener("change", function(event) {
				const file = event.target.files[0]; // Obtém o primeiro arquivo selecionado

				if (!file) return; // Caso nenhum arquivo seja selecionado, não faz nada

				const reader = new FileReader();

				// Lê o conteúdo do arquivo como texto
				reader.onload = function() {
					try {
						const csvData = reader.result;

						// Divide as linhas do CSV
						const linhas = csvData.split(/\r?\n/).filter(linha => linha.trim() !== '');

						// Extrai os cabeçalhos (primeira linha)
						const nomesCampos = linhas[0].split(separador).map(campo => campo.trim());

						// Processa os dados (demais linhas)
						const dadosTratados = linhas.slice(1).map(linha => {
							const valores = linha.split(separador).map(valor => valor.trim());

							// Gera um objeto chave-valor com base nos cabeçalhos
							const amostra = {};
							nomesCampos.forEach((nome, index) => {
								amostra[nome] = valores[index] || null; // Lida com campos vazios
							});

							return amostra;
						});

						// Atualiza os dados do DataStructure
						context.nomesCampos = nomesCampos;
						context.keysIdentificadas = nomesCampos;
						context.content = dadosTratados.map(amostra =>
							Object.values(amostra)
						);
						context._matrix2Advanced();
						context.mapearNomes();
						context.atualizarQuantidadeColunasLinhas();

						context.columns = context.content[0]?.length || 0;
						context.colunas = context.columns;

						context.injetarFuncoesAmostras();

						if (callback) {
							// Chama o callback com os dados CSV
							callback(dadosTratados, context);
						}
					} catch (error) {
						console.error("Erro ao carregar o arquivo CSV:", error);
						alert("O arquivo selecionado não é um CSV válido.");
					}
				};

				// Lê o arquivo
				reader.readAsText(file);

				// Remove o elemento de input do DOM após a leitura
				document.body.removeChild(inputFile);
			});

			// Adiciona o elemento de input ao DOM para que possa ser utilizado
			document.body.appendChild(inputFile);

			// Simula um clique no input para abrir a janela de seleção de arquivo
			inputFile.click();

		//Se for node
		}else if( VECTORIZATION_BUILD_TYPE == 'node' ){

		}
	}

	/**
	* Carrega um arquivo TXT do computador via upload e injeta dentro deste DataStructure.
	* @param {Function} callback Função a ser chamada após carregar os dados.
	* @param {string} separador Separador usado no TXT (padrão: '\t').
	*/
	context.loadTXT = function(callback, separador = '\t') {

		if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {

			// Cria dinamicamente o elemento <input> do tipo "file"
			const inputFile = document.createElement("input");
			inputFile.type = "file";
			inputFile.accept = ".txt"; // Aceita apenas arquivos TXT

			// Adiciona o evento "change" para capturar o arquivo selecionado
			inputFile.addEventListener("change", function(event) {
				const file = event.target.files[0]; // Obtém o primeiro arquivo selecionado

				if (!file) return; // Caso nenhum arquivo seja selecionado, não faz nada

				const reader = new FileReader();

				// Lê o conteúdo do arquivo como texto
				reader.onload = function() {
					try {
						const txtData = reader.result;

						// Divide as linhas do TXT
						const linhas = txtData.split(/\r?\n/).filter(linha => linha.trim() !== '');

						// Extrai os cabeçalhos (primeira linha)
						const nomesCampos = linhas[0].split(separador).map(campo => campo.trim());

						// Processa os dados (demais linhas)
						const dadosTratados = linhas.slice(1).map(linha => {
							const valores = linha.split(separador).map(valor => valor.trim());

							// Gera um objeto chave-valor com base nos cabeçalhos
							const amostra = {};
							nomesCampos.forEach((nome, index) => {
								amostra[nome] = valores[index] || null; // Lida com campos vazios
							});

							return amostra;
						});

						// Atualiza os dados do DataStructure
						context.nomesCampos = nomesCampos;
						context.keysIdentificadas = nomesCampos;
						context.content = dadosTratados.map(amostra =>
							Object.values(amostra)
						);
						context._matrix2Advanced();
						context.mapearNomes();
						context.atualizarQuantidadeColunasLinhas();

						context.columns = context.content[0]?.length || 0;
						context.colunas = context.columns;

						context.injetarFuncoesAmostras();

						if (callback) {
							// Chama o callback com os dados TXT
							callback(dadosTratados, context);
						}
					} catch (error) {
						console.error("Erro ao carregar o arquivo TXT:", error);
						alert("O arquivo selecionado não é um TXT válido.");
					}
				};

				// Lê o arquivo
				reader.readAsText(file);

				// Remove o elemento de input do DOM após a leitura
				document.body.removeChild(inputFile);
			});

			// Adiciona o elemento de input ao DOM para que possa ser utilizado
			document.body.appendChild(inputFile);

			// Simula um clique no input para abrir a janela de seleção de arquivo
			inputFile.click();

		//Se for node
		}else if( VECTORIZATION_BUILD_TYPE == 'node' ){

		}
	}

	context.mapearNomes = function(){
		/**
		* Transforma nomes dos campos em indices e isso pode ser usado pelo método getColunaCampo para obter o Vector que contém os dados da coluna cujo nome é TAL
		*/
		for( let i = 0 ; i < context.nomesCampos.length ; i++ )
		{
			const nomeCampo    = context.nomesCampos[i];
			const indiceCampo  = i;
	
			context.mapaCampos[ nomeCampo ] = indiceCampo;
		}
	}

	/**
	* Transforma nomes dos campos em indices e isso pode ser usado pelo método getColunaCampo para obter o Vector que contém os dados da coluna cujo nome é TAL
	*/
	context.mapearNomes();

	/**
	* Obtem uma determinada amostra 
	*/
	context.getAmostra = context.getLinha;

	/**
	* Obtem o nome dos campos
	* @param {*} nomeCampo 
	* @returns 
	*/
	context.getNomeCampos = function(){
		return context.nomesCampos;
	}

	/**
	* Verifica se um campo existe ou não 
	*/
	context.existeCampo = function( nomeCampo ){
		return context.mapaCampos[ nomeCampo ] != undefined;
	}

	/**
	* Obtém o indice de um campo nomeCampo
	*/
	context.getIndiceCampo = function( nomeCampo ){
		if( context.mapaCampos[ nomeCampo ] == undefined ){
			throw `O campo ${nomeCampo} não existe!`;
		}
		return context.mapaCampos[ nomeCampo ];
	}

	context.getIndiceCampos = function(nomesCampos){
		const indicesCampos = [];
		nomesCampos.forEach(function( nomeCampo ){
			indicesCampos.push( context.getIndiceCampo(nomeCampo) );
		});

		return indicesCampos;
	}

	/**
	* @override
    * Obtem um novo DataStructure exatamente igual a este
    * Ou seja, faz um copia do propio objeto, identico, porém sem manter as referencias. 
    * @returns {Analise.DataStructure}
    */
    context.duplicar = function(){
    
		return Analise.DataStructure( context.toMatrix().duplicar().raw(), 
									{
			                          campos: context.nomesCampos, 
									  flexibilidade: context.flexibilidade 
									});
    }

	/**
	* @override
    * Permite fatiar(ou recortar) o DataStructure
    * @param {linhaInicial} - inicio
    * @param {linhaFinal} - final
    * @param {intervalo} - intervalo
    * @returns {Vectorization.Matrix} - o DataStructure recortado
    */
    context.slice = function(linhaInicial, linhaFinal, intervalo=1){
        let dadosRecortados = [];

        if( linhaInicial < 0 ){
            throw 'A linhaInicial precisa ser maior ou igual a zero!';
        }

        if( linhaFinal > context.rows ){
            throw 'A linhaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        if( intervalo <= 0 ){
            throw 'O intervalo precisa ser maior que zero!';
        }

        for( let i = linhaInicial ; i < linhaFinal ; i = i + intervalo )
        {
            dadosRecortados.push( context.getLinha(i).rawProfundo() );
        }

		const parametrosDados = {
			campos: context.nomesCampos, 
			flexibilidade: context.flexibilidade 
		};

        return Analise.DataStructure( Vectorization.Matrix( 
			                                                dadosRecortados, 
			                                                parametrosDados
														  ).raw(),
									  parametrosDados
									);
    }

    context.recortarLinhas = context.slice;
    context.sliceLinhas = context.slice;

	/**
	* @override
    * Obtem um novo DataStructure exatamente igual a este
    * Ou seja, faz um copia do propio objeto, identico, porém sem manter as referencias. 
    * @returns {Analise.DataStructure}
    */
	context.clonar = context.duplicar;

	//Injeta uma função dentro de cada amostra
	context.injetarFuncoesAmostras = function(){
		
		context.forEach(function(indice, vetorAmostra, contextoDataStructure){
			vetorAmostra.getCampo = function( nomeCampo ){
				return vetorAmostra.getIndice( contextoDataStructure.getIndiceCampo(nomeCampo) );
			}

			vetorAmostra.setCampo = function( nomeCampo, valorDefinir ){
				vetorAmostra.definirElementoNoIndice( contextoDataStructure.getIndiceCampo(nomeCampo), valorDefinir ) ;
			}

			//Cria um novo campo dentro da amostra atual
			vetorAmostra.adicionarCampo = function( nomeCampo, valorDefinir, flexibilidadeUsada ){
				context.criarCampoEmBranco( nomeCampo );
				vetorAmostra.setCampo( nomeCampo, valorDefinir );

				//Adiciona na flexibilidade
				context.flexibilidade[ context.getIndiceCampo( nomeCampo ) ] = flexibilidadeUsada;
			}

			//Converte a amostra para JSON
			vetorAmostra.toJSON = function(){
				const estruturaCamposAmostra = {};

				context.getNomeCampos().forEach( function(nomeCampo){ 
					estruturaCamposAmostra[nomeCampo] = vetorAmostra.getCampo(nomeCampo).raw();
				});

				return estruturaCamposAmostra;
			}
		});
	}

	context.injetarFuncoesAmostras();

	/** 
	* @override
    * Remove amostras duplicadas deste Vectorization.Matrix com base em colunas específicas.
	* @param {String[]} nomeCampos - Os campos especificos que serão usados nessa verificação. Se não passar nada, ele ignora e usa todos
    */
    context.distinct = function( nomeCampos=null ){
        const valoresJaVistos = {};
        const valoresUnicos = Vectorization.Matrix([], context.parametrosAdicionais);

        context.forEach(function(indice, linhaVector){
            const identificador = (
				                   nomeCampos != null ? nomeCampos.map(function( nomeCampo ){ return linhaVector.getCampo( nomeCampo ) }) 
			                                          : linhaVector.raw()
								  ).join('|');

            if( valoresJaVistos[identificador] == undefined ){
                valoresJaVistos[identificador] = true;
                valoresUnicos.push( linhaVector );
            }
        });

        return Analise.DataStructure(valoresUnicos.raw(), context.parametrosAdicionais);
    }

	/**
	* Cria uma nova coluna EM TODAS AS AMOSTRAS e preenche elas com null
	*/
	context.criarCampoEmBranco = function( nomeNovoCampo ){

		if( !context.existeCampo(nomeNovoCampo) ){

			//Adiciona o nome do campo na lista de campos
			context.nomesCampos.push( nomeNovoCampo );

			//Mapear o indice desse novo campo
			context.mapearNomes();

			//Para todas as amostras, preencher esse campo com null
			context.forEach(function(indiceAmostra, amostra){
				amostra.setCampo( nomeNovoCampo, Vectorization.Scalar(0) );
			});

			context.flexibilidade.push( 'numero' );

		}
	}

	/**
	* Criar varios campos em branco
	* Para cada um: Cria uma nova coluna EM TODAS AS AMOSTRAS e preenche elas com null
	*/
	context.criarCamposEmBranco = function( camposCriar=[] ){

		//Cria os campos que NÂO EXISTEM NO DataStructure atual
		camposCriar.forEach(function( campoCriar ){
			context.criarCampoEmBranco( campoCriar );
		});	

	}

	/**
	* MERGE:
	*	mesclar duas DataStructure(es)
    *
	*	Se o ID(o campo chave) existir, todos os dados da segunda DataStructure serão acrescentados nele, e os novos campos que não existiam na DataStructure A serão criados, e em todas as outras amostras vão ficar como null.
    *
	*	Se o ID não existir, ele adiciona uma nova amostra com  todos os dados da segunda DataStructure, e e os novos campos que não existiam na DataStructure A serão criados, todas as outras amostras vão ficar como null.
	*
    * Se o parametro "sobrescrever" for true, então, Se o ID(o campo chave) existir, e os campos existem em ambos os DataStructures, então ele vai sobrescrever o valor dessas amostras no primeiro DataStructure pelos valores que estão no segundo DataStructure
    * Voce pode ignorar alguns campos na hora de sobrescrever, basta atribuir ao campo o valor A.IGNORE.
	* 
	* Retorna o contexto atual do DataStructure com essa junção feita
	*/
	context.mergeWith = function( outraDataStructure, campoChave='nome', sobrescrever=false ){
		
		const campoChaveIsArray  = campoChave instanceof Array ? true : false; 
		const campoChaveIsString = (!campoChaveIsArray && typeof campoChave == 'string') ? true : false; 

		const camposEste  = context.getNomeCampos();

		//Pegar os campos que tem no OUTRO DataStructure  QUE NÂO EXISTEM NO DataStructure Atual
		const camposOutro = outraDataStructure.getNomeCampos().filter(function( nomeCampo ){ return !camposEste.includes(nomeCampo) });

		//Percorrer cada amostra do outro DataStructure
		outraDataStructure.forEach(function( indiceAmostra, amostraOutroVector, contextOutro ){

			//Verifica se o campo NOME da amostra atual deste DataStructure tem exatamente o mesmo valor que o campo NOME do OUTRO DataStructure 
			let seCorresponde = false;
			for( let i = 0 ; i < context.linhas ; i++){
				const amostraAtual = context.getAmostra(i);

				//Se algum campo chave foi correspondido
				if( 
					//Se o parametro for um array de nome de campos, usa eles como chave, PRA VERIFICAR se alguma amostra for correspondido
					(
						campoChaveIsArray  == true && 
						campoChave.map(function( campoChaveAtual ){
											return amostraAtual.getCampo(campoChaveAtual).raw() == amostraOutroVector.getCampo(campoChaveAtual).raw()
									})
									.some(( condicao )=>{ return condicao == true }) == true
					) 

					//Ou então, se existe apenas um unico campo chave, usa apenas ele PRA VERIFICAR se alguma amostra for correspondido
					|| (campoChaveIsString == true && amostraAtual.getCampo(campoChave).raw() == amostraOutroVector.getCampo(campoChave).raw() )

				){
					seCorresponde = true; //Sinaliza que encontrou alguma correspondencia

					//Para cada campo DO OUTRO QUE NÂO EXISTE NESSE 
					//Dados que serão adicionados neste DataStructure
					
					camposOutro.forEach(function( campoOutro ){
						const valorInserir = amostraOutroVector.getCampo( campoOutro );

						//Obtem a flexibilidade do campo
						const indiceCampoOutro          = outraDataStructure.getNomeCampos().indexOf( campoOutro );
						const flexibilidadeCampoOutro   = outraDataStructure.flexibilidade[ indiceCampoOutro ];

						//Se o campo não existe no DataStructure atual
						//Adiciona o campo apenas na amostraAtual, e nas demais amostras, preenche aquele campo com null se ele não existir
						amostraAtual.adicionarCampo( campoOutro, valorInserir, flexibilidadeCampoOutro );
					});	

					//Se for permitido sobrescrever campos
					if( sobrescrever == true )
					{
						//Para cada campo do primeiro DataStructure
						camposEste.forEach(function( campoEste ){

							//Se o campo atual deste primeiro DataStructure tambem existe no segundo DataStructure
							if( contextOutro.existeCampo( campoEste ) == true ){
								//Obtem a flexibilidade do campo
								const indiceCampoOutro          = outraDataStructure.getNomeCampos().indexOf( campoEste );
								const flexibilidadeCampoOutro   = outraDataStructure.flexibilidade[ indiceCampoOutro ];
								const valorCampoOutro           = amostraOutroVector.getCampo( campoEste );

								//Se não for um campo que deve ser ignorado
								if( valorCampoOutro.raw() != Analise.IGNORE && 
								    valorCampoOutro.raw() != null &&
									!isNaN(valorCampoOutro.raw())
								){
									//Define o valor da amostra atual deste primeiro DataStructure 
									amostraAtual.setCampo( campoEste, valorCampoOutro );
								}
							}

						});
					}

					//Não faz sentido ter mais de uma amostra que bate com a chave, pois muitas vezes o campo chave vai ser unico, por isso usei 'break'
					break;
				}
			}

			//Se não encontrou nenhuma correspondencia
			if( !seCorresponde ){
				
				//Cria os campos em branco
				const camposCriar = outraDataStructure.getNomeCampos();
				context.criarCamposEmBranco( camposCriar );

				//Ajusta a flexibilidade antes de adicionar os campos que faltam
				camposCriar.forEach(function( nomeCampo ){
					//Obtem a flexibilidade do campo
					const indiceCampoEste          = context.getNomeCampos().indexOf( nomeCampo );
					const indiceCampoOutro         = outraDataStructure.getNomeCampos().indexOf( nomeCampo );
					const flexibilidadeCampoOutro  = outraDataStructure.flexibilidade[ indiceCampoOutro ];

					//Define a flexibilidade
					context.flexibilidade[ indiceCampoEste ] = flexibilidadeCampoOutro;
				});

				//Vai apenas adicionar a amostra 'amostraOutroVector' ao DataStructure atual

				//Monta os campos que vai adicionar
				const estruturaCamposAmostra = {};
				camposEste.forEach( function(nomeCampo){ 
					
					if( contextOutro.existeCampo(nomeCampo) == true ){
						//Se ja existe então a flexibilidade tambem ja esta definida

						//Define o valor
						estruturaCamposAmostra[nomeCampo] = amostraOutroVector.getCampo(nomeCampo).raw();

					//Se o campo não existe no outro DataStructure, define um valor padrão, e ajusta a flexibilidade
					}else{
						//Define o valor
						estruturaCamposAmostra[nomeCampo] = 0;
					}
					
				});
				
				context.inserir( estruturaCamposAmostra );

				context.columns = context.content[0].length;
				context.colunas = context.columns;

				context.injetarFuncoesAmostras();
			}
		});

		return context;
	}

	/**
	* SUBSTITUIR AMOSTRAS:
	*	substitui certos campos das amostras do primeiro DataStructure, com os valores que estão no segundo DataStructure
	*
    * Se o ID(o campo chave) existir, e os campos existem em ambos os DataStructures, então ele vai sobrescrever o valor dessas amostras no primeiro DataStructure pelos valores que estão no segundo DataStructure
    * Voce pode ignorar alguns campos na hora de sobrescrever, basta atribuir ao campo o valor A.IGNORE.
	* 
	* Retorna o contexto atual do DataStructure com essa substituição feita
	*/
	context.substituirCamposAmostras = function( outraDataStructure, campoChave='nome' ){
		
		const campoChaveIsArray  = campoChave instanceof Array ? true : false; 
		const campoChaveIsString = (!campoChaveIsArray && typeof campoChave == 'string') ? true : false; 
		const camposEste  = context.getNomeCampos();

		//Percorrer cada amostra do outro DataStructure
		outraDataStructure.forEach(function( indiceAmostra, amostraOutroVector, contextOutro ){

			//Verifica se o campo NOME da amostra atual deste DataStructure tem exatamente o mesmo valor que o campo NOME do OUTRO DataStructure 
			let seCorresponde = false;
			for( let i = 0 ; i < context.linhas ; i++){
				const amostraAtual = context.getAmostra(i);

				//Se algum campo chave foi correspondido
				if( 
					//Se o parametro for um array de nome de campos, usa eles como chave, PRA VERIFICAR se alguma amostra for correspondido
					(
						campoChaveIsArray  == true && 
						campoChave.map(function( campoChaveAtual ){
											return amostraAtual.getCampo(campoChaveAtual).raw() == amostraOutroVector.getCampo(campoChaveAtual).raw()
									})
									.some(( condicao )=>{ return condicao == true }) == true
					) 

					//Ou então, se existe apenas um unico campo chave, usa apenas ele PRA VERIFICAR se alguma amostra for correspondido
					|| (campoChaveIsString == true && amostraAtual.getCampo(campoChave).raw() == amostraOutroVector.getCampo(campoChave).raw() )

				){
					seCorresponde = true; //Sinaliza que encontrou alguma correspondencia

					//Para cada campo do primeiro DataStructure
					camposEste.forEach(function( campoEste ){

						//Se o campo atual deste primeiro DataStructure tambem existe no segundo DataStructure
						if( contextOutro.existeCampo( campoEste ) == true ){
							//Obtem a flexibilidade do campo
							const indiceCampoOutro          = outraDataStructure.getNomeCampos().indexOf( campoEste );
							const flexibilidadeCampoOutro   = outraDataStructure.flexibilidade[ indiceCampoOutro ];
							const valorCampoOutro           = amostraOutroVector.getCampo( campoEste );

							//Se não for um campo que deve ser ignorado
							if( valorCampoOutro != undefined &&
								valorCampoOutro.raw() != Analise.IGNORE && 
								valorCampoOutro.raw() != null &&
								!isNaN(valorCampoOutro.raw())
							){
								//Define o valor da amostra atual deste primeiro DataStructure 
								amostraAtual.setCampo( campoEste, valorCampoOutro );
							}
						}

					});

					//Não faz sentido ter mais de uma amostra que bate com a chave, pois muitas vezes o campo chave vai ser unico, por isso usei 'break'
					break;
				}
			}

		});

		return context;
	}

	/**
	* Adiciona uma ou mais nova(s) amostra(s). 
	* Para isso basta passar um JSON da amostra, ou um ARRAY DE JSONs das amostras
	*
	* >>>> Exemplo com uma única amostra (JSON) <<<<
	* 	@example
	* 	context.inserir({ nome: 'William',  cf: 30, idade: 32 })
	*
	* >>>> Exemplo com múltiplas amostras (Array de JSONs) <<<<
	* 	@example
	* 	context.inserir([
	*   	{ nome: 'William',  cf: 30, idade: 32 },
	*   	{ nome: 'Pedro',  cf: 30, idade: 45 }
	* 	]);
	*/
	context.inserir = function( amostraObj ){
		// Caso o argumento seja um array, iterar e inserir cada amostra individualmente
		if (Array.isArray(amostraObj)) {
			amostraObj.forEach((amostra) => context.inserir(amostra));
		} 
		// Caso seja uma única amostra (Vector ou Objeto)
		else {

			if( Vectorization.Vector.isVector( amostraObj ) == true ){

				if( amostraObj.length != context.colunas ){
					throw `A nova amostra ${amostraObj} tem ${ amostraObj.length } colunas, porém, esse DataStructure possui ${context.colunas} colunas!`
				}

				context.push(amostraObj);

			//Caso não seja um Vectorization.Vector, então, ele pode um JSON
			}else if( typeof amostraObj == 'object' ) {

				const camposAmostra = Object.keys( amostraObj );
				const valoresAmostra = Object.values( amostraObj );
				const temTodosOsCampos = context.nomesCampos.every( ( campo )=>{ return amostraObj[campo] != undefined } );

				if(!temTodosOsCampos){
					throw `A amostra precisa ter os campos [${ context.nomesCampos }] `;
				}

				//Verifica se existe algum campo novo
				camposAmostra.forEach(function( nomeCampo ){

					if( context.existeCampo( nomeCampo ) == false )
					{
						throw `O campo ${ nomeCampo } não existe! `;
					}

				});

				//Adiciona a amostra
				context.push(valoresAmostra);
			}

		}
	}

	/**
	* Apaga uma ou mais amostras 
	*
	* Exemplo:
	*   dataset.deletarAmostras([ { fieldA: 'idade', op: 'isEqual', fieldB: '25' } ]);
    * 
	*  Nesse exemplo, isso iria apagar todas as amostras cujo campo "idade" tiver o valor 25
	* 
	*/
	context.deletarAmostras = function( criterios ){
		const pesquisaApagar = context.findSamples(criterios);

		for( let i = 0 ; i < pesquisaApagar.length ; i++ )
		{
			const amostraApagar = pesquisaApagar[i];
			const indiceApagar  = amostraApagar.index;

			//Apaga a amostra amostraApagar
			context.content = context.content.filter(function( amostraAtual ){

				if( amostraAtual.index != indiceApagar ){
					return amostraAtual;
				}

			});

			context.atualizarQuantidadeColunasLinhas();
		}

	}

	/**
	* Substitui os valores(das amostras) numa determinada coluna que bater com uma condiçao
	* Ele varre as amostras, e a coluna TAL dessa amostra, se bater com a condição, ela vai ter seu valor substituido
    *
	* @param { String } nomeCampo - Nome do campo que quero substituir o valor
	* @param { Array } criterios - Os critérios de busca das amostras que terão suas colunas substituidas
	* @param { Function } replaceFunctionOrValue - O valor que as colunas das amotras encontradas deverão ter, ou uma função que retorna esse valor
	*  Se for uma função, ela recebe os seguintes parametros: (objAmostra, indiceAmostra, indiceColuna, valorExistente, contexto )
    *
	* Exemplo:
	*    dataset.substituirValorColuna( 'nome', [{ fieldA: 'nome', op: 'isEqual', fieldB: 'William' }], 'NINGUEM' );
	*
    *  Isso trocaria onde o nome é 'William' na coluna nome para 'NINGUEM'
	*
	*/
	context.substituirValorColuna = function( nomeCampo, criterios, replaceFunctionOrValue ){
		const pesquisaSubstituir         = context.findSamples(criterios);
		const indiceColunaSubstituir = context.getIndiceCampo(nomeCampo);

		for( let i = 0 ; i < pesquisaSubstituir.length ; i++ )
		{
			const amostraSubstituir   = pesquisaSubstituir[i];
			const indiceAtual         = amostraSubstituir.index;
			const valorExistente      = amostraSubstituir[ indiceColunaSubstituir ];

			if( typeof replaceFunctionOrValue == 'function' ){
				//Se for uma função que representa o valor
				context.definirValorLinha( indiceAtual, 
										   indiceColunaSubstituir, 
										   replaceFunctionOrValue.bind(context)( amostraSubstituir, indiceAtual, indiceColunaSubstituir, valorExistente, context ) 
										 );

			}else{
				//Se for um valor
				context.definirValorLinha( indiceAtual, 
										   indiceColunaSubstituir, 
										   replaceFunctionOrValue 
										);
			}
		}

	}

	/**
	* Converte este DataStructure em um Vectorization.Matrix
	* @returns {Matrix} - Um novo objeto Matrix contendo os dados do DataStructure.
	* @returns 
	*/
	context.toMatrix = function(){
		return Vectorization.Matrix( context.raw(), context.parametrosAdicionais );
	}

	/**
	* Converte este DataStructure em um Vectorization.Matrix
	* @returns {Matrix} - Um novo objeto Matrix contendo os dados do DataStructure.
	* @returns 
	*/
	context.exportarMatrix = context.toMatrix;

	/**
	* Obtém um Vectorization.Vector que contém os dados da coluna cujo nome é nomeCampo
	*/
	context.getColunaCampo = function( nomeCampo ){
		return context.extrairValoresColuna( context.getIndiceCampo( nomeCampo ) );
	}

	/**
	* Apaga a coluna de um campo, e retorna um novo DataStructure
	*/
	context.removerColunaCampo = function( nomeCampo ){
		return Analise.DataStructure( context.removerColuna( context.getIndiceCampo( nomeCampo ) ) );
	}

	/**
	* Apaga varias colunas de campo, e retorna um novo DataStructure
	*/
	context.removerColunasCampos = function( nomesCampo ){
		return Analise.DataStructure( context.removerColunas( context.getIndiceCampos( nomesCampo ) ) );
	}

	/**
	* Permite renomear um campo
	* @param {*} nomeCampo 
	* @param {*} novoNomeCampo 
	*/
	context.renomearCampo = function( nomeCampo, novoNomeCampo ){
		const indiceCampo = context.getIndiceCampo( nomeCampo );
		context.nomesCampos[indiceCampo] = novoNomeCampo;
		context.mapearNomes();
		return context;
	}

	/**
	* Exclui um nome de campo 
	*/
	context.desnomearCampo = function( nomeCampo ){
		delete context.mapaCampos[ nomeCampo ];
		context.mapearNomes();
		return context;
	}	

	/**
	* Extrai todos os valores de um campo e retorna um Vectorization.Vector
	*/
	context.extrairValoresCampo = function( nomeCampo ){
		return context.extrairValoresColuna( context.getIndiceCampo(nomeCampo) );
	}

	/**
	* Extrai todos os valores de vários campos e retorna um novo DataStructure
	*/
	context.extrairValoresCampos = function( nomeCampos ){
		return Analise.DataStructure( 
			Vectorization.Matrix( 
				context.extrairValoresColunas( context.getIndiceCampos(nomeCampos) ) 
			).transposta().raw(), 
			{ 
			   campos: nomeCampos,
			   flexibilidade: nomeCampos.map( function( nomeCampoAtual ){ return context.flexibilidade[ context.getIndiceCampo( nomeCampoAtual ) ] } )
			} 
		);
	}

	/**
	* Calcula a correlação entre dois campos 
	*/
	context.correlacaoCampos = function( campo1, campo2 ){
		return Vectorization.Math.correlation( 
			                                   Vectorization.Vector( context.extrairValoresCampo(campo1).rawProfundo() ), 
		                                       Vectorization.Vector( context.extrairValoresCampo(campo2).rawProfundo() ) 
											  );
	}

	/**
	* Extrai todos os valores de vários campos e retorna um novo DataStructure
	*/
	context.selectCampos     = context.extrairValoresCampos;
	context.selecionarCampos = context.extrairValoresCampos;

    /**
    * Extrai as linhas
    * @param {*} linhaInicial 
    * @param {*} linhaFinal 
    * @returns 
    */
    context.lineRange = function(linhaInicial, linhaFinal){
        return context.slice(linhaInicial, linhaFinal);
    }

	/**
	* Extrai as ultimas linhas
	*/
	context.ultimas = function( ultimas_linhas ){
		if(!ultimas_linhas){
			throw 'Voce precisa dizer quantas linhas são!';
		}
		if( context.linhas-ultimas_linhas < 0 ){
			throw `Impossivel voltar ${ ultimas_linhas } linhas sendo que o seu DataStructure possui apenas ${context.linhas} amostras.`;
		}

		return context.lineRange( context.linhas-ultimas_linhas, context.linhas );
	}

	/**
	* Extrai as ultimas linhas
	*/
	context.ultimos = context.ultimas;

	/**
	* Extrai as primeiras linhas
	*/
	context.primeiras = function( primeiras_linhas ){
		if(!primeiras_linhas){
			throw 'Voce precisa dizer quantas linhas são!';
		}
	
		return context.lineRange( 0, primeiras_linhas );
	}

	/**
	* Extrai as primeiras linhas
	*/
	context.primeiros = context.primeiras;

	/*
	Itera sobre cada campo do DataStructure, chamando um callback sincrono theFunction( campo, indiceCampo, valoresCampo, context )
	*/
	context.forEachCampo = function( theFunction ){
		for( let i = 0 ; i < context.nomesCampos.length ; i++ )
		{
			theFunction(context.nomesCampos[i], i, context.extrairValoresCampo(context.nomesCampos[i]).raw(), context);
		}
	}

	/**
	* @override
	* Cria uma nova coluna nesta Vectorization.Matrix
	*/
    context.adicionarColuna = function(valoresNovaColuna, nomeCampo=''){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        let isVetorVectorization = (
            Vectorization.Vector.isVector(valoresNovaColuna || []) == true &&
            Vectorization.Vector.isVectorizationVector(valoresNovaColuna || []) 
        ) == true;
           
        let valoresNovaColuna_Vector = isVetorVectorization == true ? valoresNovaColuna : Vectorization.Vector(valoresNovaColuna || []);
        let tamanhoVetorNovo = valoresNovaColuna_Vector.tamanho();
        let quantidadeLinhasMatrix = context.getRows();

        if( typeof valoresNovaColuna_Vector == 'object' &&
            tamanhoVetorNovo == quantidadeLinhasMatrix
        ){
            //Para cada linha
            Vectorization.Vector({
                valorPreencher: 1,
                elementos: quantidadeLinhasMatrix

            }).paraCadaElemento(function(iLinha){
                let valoresDaLinhaObtidos = context.getLinha(iLinha);

                switch( Vectorization.Vector.isVectorizationVector(valoresDaLinhaObtidos) || 
                        Vectorization.BendableVector.isVectorizationBendableVector(valoresDaLinhaObtidos) 
                ){
                    case true:
                        valoresDaLinhaObtidos.adicionarElemento( valoresNovaColuna[iLinha] );
                        break;

                    case false:
                        let novoVetorVectorization = Vectorization.Vector(valoresDaLinhaObtidos).adicionarElemento( valoresNovaColuna[iLinha] )
                        context._definirValorLinha(iLinha, valoresDaLinhaObtidos.length, [... novoVetorVectorization.valores()] );
                        break;
                }
            });

            //Atualiza a quantidade das colunas
            context.columns = context.calcTamanhos().lerIndice(1);
            context.colunas = context.columns;

			//Cria um nome para o campo
			context.mapaCampos[nomeCampo] = context.colunas + 1;
			context.nomesCampos.push( nomeCampo );
			context.mapearNomes();

        }else{
            throw 'Não da pra adicionar uma nova coluna se a quantidade de elementos não bater com a quantidade de linhas!. Não permitido.';
        }

		return context;
    }

	//Cria uma nova coluna nesta Vectorization.Matrix
	context.adicionarCampo = context.adicionarColuna;
	context.criarColuna    = context.adicionarColuna;

	/**
	* Aplica uma função a uma ou mais colunas e cria uma nova coluna com os resultados.
	* 
	* @param {string[]} camposEntrada - Os nomes das colunas de entrada.
	* @param {function} funcao - A função que será aplicada aos valores das colunas de entrada.
	* @param {string} novoCampo - O nome da nova coluna a ser criada.
    *
	* exemplo:
	*	dataset.criarColunaCalculadaExplicita(['campo1', 'campo2'], (campo1, campo2) => { return campo1 + campo2 }, 'soma' );
	*/
	context.criarColunaCalculadaExplicita = function(camposEntrada, funcao, novoCampo) {
		// Validar se os campos de entrada existem
		const indicesEntrada = context.getIndiceCampos(camposEntrada);

		// Iterar sobre as linhas e aplicar a função
		const novaColuna = context.map((indiceLinha, linha) => {
			const valoresEntrada = indicesEntrada.map(indice => linha[indice]);
			return funcao(...valoresEntrada);
		});


		// Adicionar a nova coluna aos dados
		context.adicionarColuna( novaColuna, novoCampo );

		// Atualizar metadados
		context.nomesCampos.push(novoCampo);
		context.mapearNomes();
	};

	/**
	* Aplica uma função a uma ou mais colunas e cria uma nova coluna com os resultados.
	* 
	* @param {function} funcao - A função que será aplicada aos valores das colunas de entrada.
	* @param {string} novoCampo - O nome da nova coluna a ser criada.
    *
	* exemplo:
	*	dataset.criarColunaCalculada( (indiceAmostra, amostra, contextoDataset) => { return amostra.getCampo('campo1') + amostra.getCampo('campo2') }, 'soma' );
	*/
	context.criarColunaCalculada = function(funcao, novoCampo) {
		// Iterar sobre as linhas e aplicar a função
		const novaColuna = context.map((indiceLinha, linha) => {
			return funcao(indiceLinha, linha);
		});

		// Adicionar a nova coluna aos dados
		context.adicionarColuna( novaColuna, novoCampo );

		// Atualizar metadados
		context.nomesCampos.push(novoCampo);
		context.mapearNomes();
	};

	/*
	Preenche uma determinada coluna com o mesmo valor fixo em todas as amostras
	*/
	context.preencherCampo = function(nomeCampo, valorPreencher){
		context.forEach( function(indiceAmostra, amostra, contextoDataStructure){
			amostra.setCampo(nomeCampo, valorPreencher);
		});
	}

    /*
	Pesquisa amostras usando criterios de busca, e retorna um novo DataStructure.
	
	ex: findSamples([
		{ field: 'Nome', op: 'notNull'},
		{ fieldA: 'Idade', op: 'less', fieldB: '22' },
		{ 
			fieldA: 'Idade', op: 'less', fieldB: '25',
			or: [
				{fieldA: 'Idade', op: 'less', fieldB: '22'},
				{fieldA: 'Idade', op: 'less', fieldB: '22'},
				{fieldA: 'Idade', op: 'less', fieldB: '22'},
				{ 
					fieldA: 'Idade', op: 'less', fieldB: '22',
					or: [
						{fieldA: 'Idade', op: 'less', fieldB: '22'}
					]
				}
			]
		},
		{
			customFn: function(amostra){
				if(amostra.isFake){ return false }else{ return true}
			}
		}

	])

	OU
	ex: findSamples([
		{fieldA: 'Idade', op: 'less', fieldB: '22'}
	]);
	
	*/
	context.findSamples = function(criterios, returnType='datastructure'){
		const newArray = [];

		/*
		Função interna que faz uma comparação logica SE
		*/
		function doComparation(fieldA, operation, valueB, amostra){
			let validationResult = false;
			switch(operation){
				case 'isEqual':
				case 'equ':
					validationResult = (amostra.getCampo(fieldA) == valueB) || (amostra.getCampo(fieldA) === valueB);
					break;

				case 'notEqual':
				case 'neq':
					validationResult = (amostra.getCampo(fieldA) != valueB) && (amostra.getCampo(fieldA) !== valueB);
					break;

				case 'less':
				case 'isLess':
					validationResult = (amostra.getCampo(fieldA) < valueB);
					break;
			}

			return validationResult;
		}

		/*
		Função interna que realiza uma validação simples em cima do amostra, com base em algum campo
		*/
		function basicValidation(validationType, field, amostra){
			let validationResult = false;
			switch(validationType){
				case 'isNull':
					validationResult = amostra.getCampo(field) == null || amostra.getCampo(field) == undefined;
					break;

				case 'notNull':
					validationResult = amostra.getCampo(field) != null && amostra.getCampo(field) != undefined;
					break;

				case 'isEmpty':
					validationResult = String(amostra.getCampo(field)).trim() == '';
					break;

				case 'notEmpty':
					validationResult = String(amostra.getCampo(field)).trim() != '';
					break;
			}

			return validationResult;
		}

		//Função interna que tem como finalidade processar uma condição e retornar true ou false de acordo com a validação efetuada
		//true se for verdade, false caso contrario
		//Um criterio é um bloco de condição
		function processCriterio(criterio, criterioKeys, amostra, datastructure){
			const customFunction    = criterio['customFn'] ? criterio['customFn'] : null;   //se a condiçao for uma função personalizada javascript
			const isNegation        = criterio['isNegate'] ? true : false;                  //Se é uma negação, ou seja, se toda a condição inclusive os ORs serão em sentido negativo
			const isDualKeys        = criterioKeys.length == 2;                             //Se é apenas um campo e uma validação simples
			const isTriKeys         = criterioKeys.length == 3;                             //Se são tres atributos, indicando A, B e operação de checagem
            const haveOr            = criterio['or'] ? true : false;                        //se ele tem o OR envolvido
			const haveNot           = criterio['not'] ? true : false;                       //se ele tem o NOT envolvido, para criar uma condição do tipo AND porém ela é em setido negativo
			const haveExcept        = criterio['except'] ? true : false;                    //se ele tem o criterio EXCEPT, que basicamente é que nem o OR, porém se alguma condição except for TRUE, ele NEGA O RESULTADO DO CRITERIO, INVALIDANDO O CRITERIO TODO

			const isBasicValidation = (criterio['field'] && criterio['op'] && !criterio['fieldA'] && !criterio['fieldB']) ? true : false;
			const isComparation     = (!isBasicValidation && criterio['fieldA'] && criterio['fieldB'] && criterio['op']) ? true : false;
			
			let resultadoCriterio = false;

			//Se for uma função personalizada, usa ela
			if(customFunction){
				return customFunction(amostra);
			}

			if(isBasicValidation){
				resultadoCriterio = basicValidation( criterio['op'], criterio['field'], amostra );
			
			//Uma validação que envolve dois lados A e B
			}else if(isComparation){
				resultadoCriterio = doComparation( criterio['fieldA'], criterio['op'], criterio['fieldB'], amostra)

				//O AND vem primeiro que o OR, então se o AND ja foi TRUE, se DER FALSE no OR NÂO TEM PROBLEMA
				if( resultadoCriterio == false ){
					if( haveOr ){
						const orResults = [];
						for( let c = 0 ; c < criterio['or'].length ; c++ ){
							const condicaoOr = criterio['or'][c];
							const condicaoOrKeys = Object.keys(condicaoOr);
							const resultadoOr = processCriterio( condicaoOr, condicaoOrKeys, amostra, datastructure );
							orResults.push( resultadoOr );
						}
						
						resultadoCriterio = orResults.some(function(orRes){ return orRes == true });
					}
				}

				//Sempre a exceção vem por ultimo
				if( haveExcept ){
					const exceptResults = [];
					for( let c = 0 ; c < criterio['except'].length ; c++ ){
						const condicaoEx = criterio['except'][c];
						const condicaoExKeys = Object.keys(condicaoEx);
						const resultadoEx = processCriterio( condicaoEx, condicaoExKeys, amostra, datastructure );
						exceptResults.push( resultadoEx );
					}
					
					//O except é uma excesão, ou seja, invalida o criterio, caso alguma exceção retorne TRUE
					if( exceptResults.some(function(exRes){ return exRes == true }) ){
						resultadoCriterio = false;
					}
				}
			}

			if( isNegation ){
				return !resultadoCriterio;
			}else{
				return resultadoCriterio;
			}
		}

		//Para cada amostra
		context.forEach(function(indice, amostra, datastructure){
			
			//Para cada criteio faz a validação
			let resultadosCriterios = [];
			for( let i = 0 ; i < criterios.length ; i++ ){
				const criterio = criterios[i];
				const criterioKeys = Object.keys(criterio);
				const isDualKeys       = criterioKeys.length == 2;                             //Se é apenas um campo e uma validação simples
				const isTriKeys        = criterioKeys.length == 3;     

				resultadosCriterios.push( processCriterio(criterio, criterioKeys, amostra, datastructure) );
			}

			if( resultadosCriterios.every(function(resultCriterio){return resultCriterio == true}) ){
				newArray.push( amostra );
			}
		});

		let returnObject = newArray;

		return returnObject;
	}

	/*
	Uma busca mais programatica, retorna um novo datastructure

		ex: filter(function(amostra, rawamostra, datastructure){
			if( amostra.getCampo(FIELDNAME) == VALUE ){
				return true;
			}
		})
	*/
	context.filter = function(fn){
		let newArray = [];

		context.forEach(function(indice, amostra, datastructure){
			const rawamostra = amostra.raw();

			if( fn( amostra, rawamostra, datastructure ) == true ){
				newArray.push(amostra);
			}
		})

		return newArray;
	}

	/*** Metodos de matematica ***/

	/**
	* Somar uma coluna
	* @param {String} columnName 
	* @returns {Number}
	*/
	context.sumColumn = function(columnName){
		let acumulated = 0;
		context.forEach( function(indice, amostra, context){
			acumulated += Number( amostra.getCampo(columnName) );
		});

		return acumulated;
	}

	/**
	* Somar uma coluna
	* @param {String} columnName 
	* @returns {Number}
	*/
	context.somarColuna = context.sumColumn;

	context.meanColumn = function(columnName){
		const somaColuna = context.sumColumn( columnName );
		return somaColuna / context.getLinhas();
	}

	/**
	* Soma todos os números de uma linha 
	*/
	context.somarLinha = function( numeroLinha ){
		const objetoLinha = context.getLinha( numeroLinha );

		let acumulated = 0;
		objetoLinha.forEach( function(indice, valorAtual, contextoLinha){
			if( typeof valorAtual.raw() === 'number' ){
				acumulated += Number( valorAtual );
			}else{
				console.warn( `${ valorAtual } é uma string, e não foi incluido na soma!` );
			}
		});

		return acumulated;
	}

    return context;
}
/* FIM DO ARQUIVO: ../src/DataStructure.js*/
/* ARQUIVO: ../examples/browser/index.js*/
//var dataset = Analise.DataStructure( datasetExemplo );
/*
var dataset = Analise.DataStructure([
    ['William',  1, 2,  3,  4 ],
    ['William',  5, 6,  7,  8 ],
    ['William',  9, 10, 11, 12]

], {
    campos         : ['nome',  'campo1', 'campo2', 'campo3', 'campo4'],
    flexibilidade  : ['texto', 'numero', 'numero', 'numero', 'numero']
});*/

var dataset = Analise.DataStructure([
    { nome: 'William', cf: 27, idade: 42, numero1: 19, numero2: 40, numero3: 40, numero4: 40 },
    { nome: 'Rafael',  cf: 28, idade: 25, numero1: 19, numero2: 40, numero3: 40, numero4: 40 },
    { nome: 'Daniel',  cf: 29, idade: 19, numero1: 19, numero2: 40, numero3: 40, numero4: 40 },
    { nome: 'Danilo',  cf: 30, idade: 32, numero1: 19, numero2: 40, numero3: 40, numero4: 40 }

], {
    flexibilidade  : ['texto', 'numero', 'numero', 'numero', 'numero', 'numero', 'numero']
});

var dataset2 = Analise.DataStructure([
    { nome: 'William', cf: 27, idade: A.IGNORE, cargo: 'DEV',        outro: 45 },
    { nome: 'Rafael',  cf: 28, idade: 2555,     cargo: 'APICULTOR',  outro: 45 },
    { nome: 'NAO SEI', cf: 29, idade: 2555,     cargo: 'DEV',        outro: 45 },
    { nome: 'Danilo',  cf: 30, idade: 2555,     cargo: 'DEV',        outro: 45 },
    { nome: 'Lucas',   cf: 31, idade: 2555,     cargo: 'AGRICULTOR', outro: 48}
], {
    flexibilidade  : ['texto', 'numero', 'numero',  'texto', 'numero']
});
/* FIM DO ARQUIVO: ../examples/browser/index.js*/

window.isbrowser = true;

window.iscompilation = true

// Conteúdo do arquivo: C:\Users\Meu Computador\Desktop\Projetos Pessoais Github\Deep Learning\javascript-grid\src\WGrid.js
if( typeof window === 'undefined' ){
    globalThis.window = {};
}

window.WGrid = {};

window.WGrid.libs = {
    Analise: window.Analise || null,
    Vectorization: ((window.Analise || {}).libs || {}).Vectorization || null
};

window.WGrid.WGrid = class{

    constructor( dadosGrid=[], gridConfig={} ){
        const context = this;

        // Verifica se a instação contém os estilo CSS
        if( ![...document.querySelectorAll('link[rel="stylesheet"]')].some( (link)=>{ return link.href.includes("WGrid.css") } ) ){
            console.warn(`Estilos CSS principal não carregados!. Verifique os arquivos no HTML`);
        }

        this.gridConfig    = gridConfig;
        this.dados         = dadosGrid;

        //Se o dados for um DataStructure do Analise
        if( window.WGrid.libs.Analise != null && this.dados.objectName && this.dados.objectName == 'DataStructure' ){
            this._datastructure_origem = dadosGrid;
            this.dados = dadosGrid.raw();
        }

        this.idElementoPai   = this.gridConfig.elementoPai; 
        this.elementoPai     = document.getElementById( this.idElementoPai ); 
        this.tituloGrid      = this.gridConfig.titulo;
        this.nomesColunas    = this.gridConfig.colunas;
        this.flexibilidade   = this.gridConfig.flexibilidade || [];
        this.statusColunas   = this.gridConfig.status;
        this.callbacks       = this.gridConfig.callbacks || {};
        this.copyOnClick     = this.gridConfig.copyOnClick || false;
        this.selectOnClick   = this.gridConfig.selectOnClick || false;
        this.searchBar       = this.gridConfig.searchBar;
        this.mirrorStructure = this.gridConfig.mirror;

        /**
        * Um mapa em ordem sequencial de todas as colunas editaveis feito assim:
        * INDICE_COLUNA : INDICE_PROXIMA_COLUNA_EDITAVEL 
        */
        this.editableMap = {};
        this.nomesColunas.forEach(function( nomeColuna, indiceColuna ){

            let indiceProximaColuna = context.nomesColunas.reduce(function( nomeColunaAtual, nomeProximaColuna ){
                                            const indiceColunaAtual = context.getIndiceCampo(nomeProximaColuna);

                                            if( indiceColunaAtual > indiceColuna && 
                                                context.getStatusColuna(nomeProximaColuna) != undefined &&
                                                (
                                                  context.getStatusColuna(nomeProximaColuna).editable != undefined && 
                                                  context.getStatusColuna(nomeProximaColuna).editable != null && 
                                                  context.getStatusColuna(nomeProximaColuna).editable != false
                                                )
                                            ){
                                                return indiceColunaAtual;
                                            }
                                      });

            if(indiceProximaColuna)
            {
                context.editableMap[ indiceColuna ] = {
                    nomeColuna: nomeColuna,
                    indiceProximaColuna: indiceProximaColuna,
                    nomeProximaColuna: context.nomesColunas[ indiceProximaColuna ]
                }
            }

        });

        if( this.searchBar == undefined ){
            this.searchBar = true;
        }

        this.buttons       = this.gridConfig.buttons;
        if( this.buttons == undefined ){
            this.buttons = true;
        }

        this.pesquisando   = '';

        //Adiciona uma classe para aplicar estilo padrao
        document.getElementById( this.idElementoPai ).setAttribute('class', document.getElementById( this.idElementoPai ).getAttribute('class')||'' + ' wgrid');

        if(!this.elementoPai){
            throw 'Voce precisa definir onde a grid vai ficar!. Defina "elementoPai" ';
        }

        this.render();
    }
    
    /**
    * Converte este objeto para DataStructure 
    * @returns {Vectorization.DataStructure} 
    */
    toDataStructure(){
        if( window.WGrid.libs.Analise == null ){
            throw Error(`O pacote Analise não está instalado!`);
        }

        return window.Analise.DataStructure(
            this.dados,
            {
                campos: this.colunas,
                flexibilidade: this.flexibilidade
            }
        );
    }

    /**
    * Converte este objeto para Matrix
    * @returns {Vectorization.Matrix} 
    */
    toMatrix(){
        if( window.WGrid.libs.Analise == null ){
            throw Error(`O pacote Analise não está instalado!`);
        }

        return Vectorization.Matrix( this.dados, {flexibilidade: this.flexibilidade} );
    }

    /**
    * Importa os dados de uma Matrix para essa Grid
    * @param {Analise.DataStructure} objDataStructure 
    */
    fromMatrix( objMatrix ){
        if(!objMatrix){
            throw Error('Voce precisa informar a instancia do DataStructure!');
        }
        if( window.WGrid.libs.Analise == null ){
            throw Error(`O pacote Analise não está instalado!`);
        }

        this.dados = [...objMatrix.raw().copyWithin()];
        this.render();
    }

    /**
    * Importa os dados de um Array para essa Grid
    * Semelhante ao fromMatrix, porém usando apenas Arrays do JavaScript
    * @param {Analise.DataStructure} objDataStructure 
    */
    fromArray( objMatrix ){
        if(!objMatrix){
            throw Error('Voce precisa informar a instancia do DataStructure!');
        }
        if( window.WGrid.libs.Analise == null ){
            throw Error(`O pacote Analise não está instalado!`);
        }

        this.dados = [...objMatrix.copyWithin()];
        this.render();
    }

    /**
    * Importa os dados de um DataStructure para essa Grid
    * @param {Analise.DataStructure} objDataStructure 
    */
    fromDataStructure( objDataStructure ){
        if(!objDataStructure){
            throw Error('Voce precisa informar a instancia do DataStructure!');
        }
        if( window.WGrid.libs.Analise == null ){
            throw Error(`O pacote Analise não está instalado!`);
        }

        this.dados = [...objDataStructure.raw().copyWithin()];
        this.render();
    }

    /**
    * Cria uma linha 
    */
    CriarLinha( dados, classeLinha='linha-grid', idLinha='' ) {
        const elementoPai = this.elementoPai;
    
        let htmlColunas = ``;

        /**
        * Cria as DIVs de todas os valores dentro de 'dados'(os dados da linha atual)
        */
        for( let i = 0 ; i < dados.length ; i++ )
        {
            const nomeColunaAtual  = this.getNomeColuna( i );
            const statusColuna     = this.getStatusColuna( nomeColunaAtual );

            const valorColunaAtual =  dados[i]; 

                                            //Se for texto ou número, pega o valor como está
            const valorColunaTratadoBoolean = ( (statusColuna || {}).typeof == 'string' || 
                                                (statusColuna || {}).typeof == 'number'
                                            ) 
                                            ? valorColunaAtual
                                            : 
                                            //Se for booleano, e se os valores forem Sim ou Nao, eles convertem para booleano
                                            (statusColuna || {}).typeof == 'boolean' 
                                                ? valorColunaAtual == 'Sim' 
                                                    ? true 
                                                    :
                                                  valorColunaAtual == 'Nao' 
                                                    ? false
                                                    : false 

                                                :'';

            /**
            * Se a coluna esta visivel ou se, nao existe nenhuma configuracao para a coluna
            */
            if( classeLinha == 'linha-detalhes' || (!statusColuna || statusColuna.visible == true) )
            {
                htmlColunas += `
                    <div class='elemento-linha-grid' name='coluna-${i}-linha${idLinha}-grid-${this.idElementoPai}'>
                        ${ 
                            //idLinha != '_inicio' significa que ele vai ignorar o cabeçalho
                            ( (statusColuna || {}).editable != undefined && (statusColuna || {}).editable != false && classeLinha != 'linha-detalhes' && idLinha != '_inicio') 
                                                          //Se for editavel
                                                          ? (
                                                            //Se for booleano usa checkbox
                                                            (statusColuna || {}).typeof == 'boolean' 
                                                            ? `<input id='input-coluna${i}-linha${idLinha}-grid-${this.idElementoPai}' 
                                                                        type='checkbox'
                                                                        checked=${ valorColunaTratadoBoolean }
                                                                        class='input-coluna-editavel'
                                                                        _linha=${idLinha}
                                                                        _coluna=${i}
                                                                        _grid=${this.idElementoPai}
                                                                />`
                                                            :
                                                            //Se for texto, usa um input normal
                                                            (
                                                                (statusColuna || {}).typeof == 'string' ||
                                                                (statusColuna || {}).typeof == 'number'
                                                            ) 
                                                            ?
                                                                `<input id='input-coluna${i}-linha${idLinha}-grid-${this.idElementoPai}' 
                                                                        value=${valorColunaAtual}
                                                                        class='input-coluna-editavel'
                                                                        _linha=${idLinha}
                                                                        _coluna=${i}
                                                                        _grid=${this.idElementoPai}
                                                                />`
                                                             :
                                                             //Se for uma escolha de texto
                                                             (statusColuna || {}).typeof == 'text-choice'
                                                             ? `<div id='input-coluna${i}-linha${idLinha}-grid-${this.idElementoPai}'>
                                                                    <select id='${nomeColunaAtual}'
                                                                            class='select-coluna-editavel'
                                                                            _linha=${idLinha}
                                                                            _coluna=${i}
                                                                            _grid=${this.idElementoPai}
                                                                    >
                                                                        ${
                                                                            //Para cada possibilidade de escolha
                                                                            (statusColuna || {}).choices
                                                                                .map(function( objChoice ){
                                                                                
                                                                                    const texto = (typeof objChoice == 'object') 
                                                                                                    ? objChoice.id 
                                                                                                    : 

                                                                                                  (typeof objChoice == 'string')
                                                                                                    ? objChoice
                                                                                                    :''

                                                                                    return `
                                                                                        <option value='${ texto }'> ${ texto } </option>
                                                                                    `
                                                                                })
                                                                        }
                                                                    </select>
                                                                </div>`
                                                             :''
                                                            )

                                                          //Se não for editavel
                                                          : valorColunaAtual 
                        }
                    </div>
                `;
            }
        }

        /**
        * Cria a linha
        */
        elementoPai.innerHTML += `
            <div class='${classeLinha} linha-grid' name='linha-${idLinha}-grid-${this.idElementoPai}'>
                ${ htmlColunas }
            </div>
        `;
    }

    /**
    * Obtem o elemento HTML de uma linha 
    */
    getElementoLinha( numeroLinha ){
        return document.getElementsByName(`linha-${numeroLinha}-grid-${this.idElementoPai}`)[0];
    }

    /**
    * Obtem o elemento HTML de uma coluna de uma linha
    */
    getElementoColuna( numeroLinha, numeroColuna ){
        return document.getElementsByName(`coluna-${numeroColuna}-linha${numeroLinha}-grid-${this.idElementoPai}`)[0];
    }

    /**
    * Obtem o valor e o elemento HTML de uma coluna de uma linha
    */
    getPosicao( numeroLinha, numeroColuna ){
        if(!this.dados[numeroLinha]){
            throw Error(`A linha ${numeroLinha} não existe!`);
        }
        if(!this.dados[numeroLinha][numeroColuna]){
            throw Error(`A coluna ${numeroColuna} não existe!`);
        }

        return {
            valor: this.dados[numeroLinha][numeroColuna],
            linha: numeroLinha,
            coluna: numeroColuna,
            grid: this,
            elemento: this.getElementoColuna( numeroLinha, numeroColuna )
        };
    }

    /**
    * Obtem o nome da coluna 
    */
    getNomeColuna( index ){
        return this.nomesColunas[index];
    }

    /**
    * Obtem o indice da coluna 
    */
    getIndiceCampo( nome ){
        return this.nomesColunas.indexOf(nome);
    }

    /**
    * Obtem as configurações da coluna 
    */
    getStatusColuna( nomeColuna ){
        if(this.statusColunas && !this.statusColunas[nomeColuna]){
            throw Error(`A coluna '${nomeColuna}' não existe!`);
        }

        return (this.statusColunas || {})[ nomeColuna ] || null;
    }

    /**
    * Esconder uma coluna 
    */
    ocultarColuna( nomeColuna ){
        this.getStatusColuna( nomeColuna ).visible = false;

        //Se existir o callback onEsconderColuna
        if( this.callbacks.onEsconderColuna ){
            this.callbacks.onEsconderColuna.bind(this)(this, nomeColuna);
        }

        this.render();
    }

    /**
    * Esconder uma coluna 
    */
    esconderColuna = this.ocultarColuna;

    /**
    * Esconde varias colunas
    */
    ocultarColunas( nomeColunas ){
        nomeColunas.forEach((nome)=>{ this.ocultarColuna(nome) });
    }

    /**
    * Esconde varias colunas
    */
    esconderColunas = this.ocultarColunas;

    /**
    * Mostrar uma coluna 
    */
    exibirColuna( nomeColuna ){
        if(!nomeColuna){
            throw Error('Voce precisa passar a coluna!');
        }

        this.getStatusColuna( nomeColuna ).visible = true;

        //Se existir o callback onExibirColuna
        if( this.callbacks.onExibirColuna ){
            this.callbacks.onExibirColuna.bind(this)(this, nomeColuna);
        }

        this.render();
    }

    /**
    * Mostrar uma coluna 
    */
    mostrarColuna = this.exibirColuna;

    /**
    * Mostrar uma coluna 
    */
    exibirColunas( nomeColunas ){
        nomeColunas.forEach((nome)=>{ this.mostrarColuna(nome) });
    }

    /**
    * Mostrar uma coluna 
    */
    mostrarColunas = this.exibirColunas;

    /**
    * Permite renomear todas as colunas
    * @param {String} nomeColunas 
    */
    renomearColunas(nomeColunas){
        const nomesAtuais = this.nomesColunas;
        this.nomesColunas = nomeColunas;

        //Antes de renomear as colunas
        if( this.callbacks.beforeRenomearColunas ){
            this.callbacks.beforeRenomearColunas.bind(this)(this, nomesAtuais, nomeColunas);
        }

        if( this.statusColunas != undefined ){
            this.nomesColunas.forEach((novoNome, indice)=>{
                const colunaAntiga = nomesAtuais[ indice ];

                this.statusColunas[novoNome] = {...this.statusColunas[colunaAntiga]};
                delete this.statusColunas[colunaAntiga]
            })
        }

        //Depois de renomear as colunas
        if( this.callbacks.afterRenomearColunas ){
            this.callbacks.afterRenomearColunas.bind(this)(this, nomesAtuais, nomeColunas);
        }

        this.render();
    }

    /**
    * Permite renomear uma coluna
    * @param {String} colunaAntiga 
    * @param {String} novoNome 
    */
    renomearColuna( colunaAntiga, novoNome ){
        //Antes de renomear a coluna
        if( this.callbacks.beforeRenomearColuna ){
            this.callbacks.beforeRenomearColuna.bind(this)( this, colunaAntiga, novoNome );
        }

        this.nomesColunas = this.nomesColunas.map(( nomeColunaAtual )=>{ return nomeColunaAtual == colunaAntiga ? novoNome : nomeColunaAtual });

        if( this.statusColunas != undefined ){
            this.statusColunas[novoNome] = {...this.statusColunas[colunaAntiga]};
            delete this.statusColunas[colunaAntiga]
        }

        //Depois que renomear a coluna
        if( this.callbacks.afterRenomearColuna ){
            this.callbacks.afterRenomearColuna.bind(this)( this, colunaAntiga, novoNome );
        }

        this.render();
    }

    /**
    * Adiciona uma nova amostra
    * @param {String} colunaAntiga 
    * @param {String} novoNome 
    */
    adicionarAmostra( dadosAmostra ){
        const contexto = this;

        this.dados.push(dadosAmostra);
        this.render();

        //Faz um scroll na grid para a ultima amostra criada
        setTimeout(function(){
            (document)
            .getElementById(contexto.idElementoPai)
            .scrollTo({
                top: (document).getElementById(contexto.idElementoPai).scrollHeight,
                behavior: 'smooth'
              });

        }, 70);
    }

    /**
    * edita o valor de uma coluna de uma amostra
    */
    setColunaAmostra( numAmostra, numColuna, novoValor ){
        this.dados[ numAmostra ][ (typeof numColuna == 'number' ? numColuna : typeof numColuna == 'string' ? this.getIndiceCampo(numColuna) : null) ] = novoValor;
    }

    /**
    * Verifica se o criterio de busca foi atingido para uma amostra
    * @param {String} strBusca 
    * @param {Array} dadosAmostra 
    */
    _criteriosBusca(strBusca, dadosAmostra){
        return dadosAmostra.map(function(caracteristica){
            return String(caracteristica).toLowerCase().indexOf( String(strBusca).toLowerCase() ) != -1 ? true : false

        }).some((resultadoCondicao)=>{ return resultadoCondicao == true }) == true;
    }

    /** Desenha a grid no elemento pai */
    render() {

        //Se estiver usando um 'mirrorStructure', ele vai estar sempre copiando os dados do DataStructure espelhado pra manter a grid atualizada sempre com os dados do DataStructure
        if(  window.WGrid.libs.Analise != null && this.mirrorStructure ){
            this.dados = this.mirrorStructure.raw();
        }
        
        //Roda o callback beforeRender
        if( this.callbacks.beforeRender ){
            this.callbacks.beforeRender.bind(this)( this );
        }

        /**
        * Reseta o que ja foi desenhado anteriormente
        */
        this.elementoPai.innerHTML = ``;

        if( this.tituloGrid != undefined )
        {
            //Adiciona um titulo
            this.CriarLinha([this.tituloGrid], 'linha-detalhes');
        }

        if( this.searchBar ){
            //Adiciona um toolbar para pesquisa
            this.CriarLinha([], 'linha-pesquisa');
        }

        if( this.buttons == true || typeof this.buttons == 'object' ){
            //Adiciona um toolbar para botões
            this.CriarLinha([], 'linha-toolbar');
        }

        /**
        * Identifica algumas coisas importantes que vão afetar a criação das colunas 
        */
        for( let i = 0 ; i < this.nomesColunas.length ; i++ )
        {
            const nomeColunaAtual  = this.getNomeColuna( i );
            const indiceColuna     = this.getIndiceCampo( nomeColunaAtual );
            const statusColuna     = this.getStatusColuna( nomeColunaAtual );
            const isTextChoice     = (statusColuna || {}).typeof == 'text-choice' ? true : false;

            /**
            * Se a coluna for uma escolha de texto
            */
            if( isTextChoice == true ){

                const haveExpand     = (statusColuna || {}).choicesExpand != undefined ? true : false;
                const haveOmissions  = (statusColuna || {}).choicesOmit   != undefined ? true : false;
                    
                //Se não informar propriedade 'choices'
                if( (statusColuna || {}).choices == null || (statusColuna || {}).choices == undefined ){
                    throw Error(`Para criar uma escolha de texto voce precisa dizer quais são as opcões, ou usar uma opção para escolher para voce`);
                }   

                //Se o choices for uma opção interna
                if( typeof (statusColuna || {}).choices == 'string' )
                {
                    switch( (statusColuna || {}).choices )
                    {
                        //Se for identificar as possiblidades de escolha disponiveis no dataset
                        case 'dataset':
                        case 'detect':
                        case 'from-dataset':
                        case 'detect-from-dataset':
                        case 'detect-dataset':     
                            const jaForam = {};

                            //Faz o statusColuna virar um Array
                            (statusColuna || {})._choices = (statusColuna || {}).choices;
                            (statusColuna || {}).choices = [];

                            //Para cada amostra
                            for( let i = 0 ; i < this.dados.length ; i++ )
                            {
                                const dadosAmostra = this.dados[i];
                                const valorColuna  = dadosAmostra[ indiceColuna ];
                                
                                //Se ainda não foi
                                if( jaForam[valorColuna] != true )
                                {
                                    (statusColuna || {}).choices.push( { id: valorColuna } );
                                    jaForam[ valorColuna ] = true;
                                }
                            }

                            break;
                    }
                }

                /**
                * Se tiver alguma expansão, para adicionar novas opções que não estavam presentes no dataset 
                */
                if(haveExpand)
                {
                    (statusColuna || {}).choicesExpand
                    .forEach(function( objChoice ){

                        const texto = (typeof objChoice == 'object') 
                                        ? objChoice.id 
                                        : 

                                      (typeof objChoice == 'string')
                                        ? objChoice
                                        :'';

                        (statusColuna || {}).choices.push( { id: texto } );
                    });
                }

                /**
                * Se tiver alguma omissão, para remover certas opções
                */
                if(haveOmissions)
                {
                    (statusColuna || {}).choicesOmit
                    .forEach(function( objChoice ){

                        const textoOmitir = (typeof objChoice == 'object') 
                                              ? objChoice.id 
                                              : 

                                            (typeof objChoice == 'string')
                                              ? objChoice
                                              :'';

                        (statusColuna || {}).choices = (statusColuna || {}).choices.filter(function( objChoiceExistente ){
                           if( objChoiceExistente.id != textoOmitir ){
                              return objChoiceExistente;
                           } 
                        });
                    });
                }
            }
        }

        /**
        * Cria o cabeçalho 
        */
        const dadosCabecalho = this.nomesColunas || this.dados.at(0);
        this.CriarLinha(dadosCabecalho, '', '_inicio');

        /**
        * Cria as outras linhas 
        * 
        * NOTA: Aqui usei 'this.nomesColunas == undefined ? 1 : 0', por que, se voce passar o nome das colunas via propriedade, então ele precisa começar a pegar as amostras a partir do indice zero 
        */
        const amostras = this.dados.slice( this.nomesColunas == undefined ? 1 : 0, this.dados.length);
        const qtdeAmostras = amostras.length;
        const contexto = this;

        for( let i = 0 ; i < qtdeAmostras; i++ )
        {   
            const indice  = i;
            const amostra = amostras[indice];
        
            //Exibe a amostra SE
            if( 
                //Se não estamos filtrando nada
                !contexto.pesquisando ||

                //Se o usuario estiver pesquisando E o critério for atendido
                (contexto.pesquisando != null && contexto._criteriosBusca(contexto.pesquisando, amostra) == true) 
            ){
                this.CriarLinha(amostra, 'linha-amostra-grid', indice);
            }
        }

        /**
        * Adicionar eventos nas colunas da linhas
        */
        for( let i = 0 ; i < qtdeAmostras ; i++ )
        {
            /**
            * Adicionar eventos na linha 
            */
            const idLinha = i;
            if(document.getElementsByName(`linha-${idLinha}-grid-${contexto.idElementoPai}`)[0])
            {
                document.getElementsByName(`linha-${idLinha}-grid-${contexto.idElementoPai}`)[0].onclick = function(evento){
                    if( contexto.callbacks[ 'onClickLinha' ] ){
                        contexto.callbacks[ 'onClickLinha' ].bind( contexto )( idLinha, evento.target, contexto )
                    }
                }
            
                document.getElementsByName(`linha-${idLinha}-grid-${contexto.idElementoPai}`)[0].addEventListener('mousedown', function(evento){
                    if( contexto.callbacks[ 'onLeftClickLinha' ] ){
                        if( evento.button == 0 ){ contexto.callbacks[ 'onLeftClickLinha' ].bind( contexto )( idLinha, evento.target, contexto ) };
                    }

                    if( contexto.callbacks[ 'onMiddleClickLinha' ] ){
                        if( evento.button == 1 ){ contexto.callbacks[ 'onMiddleClickLinha' ].bind( contexto )( idLinha, evento.target, contexto ) };
                    }

                    if( contexto.callbacks[ 'onRightClickLinha' ] ){
                        if( evento.button == 2 ){ contexto.callbacks[ 'onRightClickLinha' ].bind( contexto )( idLinha, evento.target, contexto ) };
                    }
                });
            }


            for(let e = 0 ; e < this.dados[0].length ; e++)
            {
                const idColuna = e;

                if(document.getElementsByName(`coluna-${idColuna}-linha${i}-grid-${contexto.idElementoPai}`)[0])
                {
                    document.getElementsByName(`coluna-${idColuna}-linha${i}-grid-${contexto.idElementoPai}`)[0].onclick = function(evento){
                        if( contexto.callbacks[ 'onClickColuna' ] ){
                            contexto.callbacks[ 'onClickColuna' ].bind( contexto )( i, e, contexto.getNomeColuna( idColuna ), contexto.getStatusColuna(contexto.getNomeColuna( idColuna )), evento.target, contexto );
                        }

                        //Se a coluna tiver um evento em statusColunas
                        if( contexto.statusColunas != undefined )
                        {
                            if( contexto.statusColunas[ contexto.getNomeColuna( idColuna ) ]['onClick'] ){
                                contexto.statusColunas[ contexto.getNomeColuna( idColuna ) ]['onClick'].bind( contexto )( i, e, contexto.getNomeColuna( idColuna ), contexto.getStatusColuna(contexto.getNomeColuna( idColuna )), evento.target, contexto );
                            }
                        }

                        /**
                        * Outros eventos
                        */

                        //Se pode copiar o texto
                        if( contexto.selectOnClick == true && contexto.getStatusColuna(contexto.getNomeColuna( idColuna )).allowCopy != false ||
                            (
                                contexto.getNomeColuna( idColuna ) != undefined &&
                                contexto.getStatusColuna(contexto.getNomeColuna( idColuna )) != undefined &&
                                contexto.getStatusColuna(contexto.getNomeColuna( idColuna )).copy == true
                            )
                        ){
                            const valorColunaClicando = contexto.getPosicao( idLinha, idColuna ).valor;

                            navigator.clipboard.writeText( valorColunaClicando )
                                            .then(() => alert("Copiado!"))
                                            .catch(err => console.error("Falha ao copiar texto: ", err));
                        }

                        //Se pode selecionar o texto
                        if( contexto.copyOnClick == true && contexto.getStatusColuna(contexto.getNomeColuna( idColuna )).allowSelect != false ||
                            (
                                contexto.getNomeColuna( idColuna ) != undefined &&
                                contexto.getStatusColuna(contexto.getNomeColuna( idColuna )) != undefined &&
                                contexto.getStatusColuna(contexto.getNomeColuna( idColuna )).select == true
                            )    
                        ){
                            if( contexto.getStatusColuna(contexto.getNomeColuna( idColuna )).editable != undefined &&
                                contexto.getStatusColuna(contexto.getNomeColuna( idColuna )).editable != false &&
                                contexto.getStatusColuna(contexto.getNomeColuna( idColuna )).editable != null
                            ){
                                 evento.target.setSelectionRange(0, evento.target.value.length);             
                                 evento.target.focus();

                            }else{
                                // Cria uma seleção de texto
                                const range = document.createRange();
                                range.selectNodeContents(evento.target);
                                const selection = window.getSelection();
                                selection.removeAllRanges(); // Limpa seleções anteriores
                                selection.addRange(range);
                            }
                        }
                    };

                    document.getElementsByName(`coluna-${idColuna}-linha${i}-grid-${contexto.idElementoPai}`)[0].addEventListener('mousedown', function(evento){
                        if( contexto.callbacks[ 'onLeftClickColuna' ] ){
                            if( evento.button == 0 ){ contexto.callbacks[ 'onLeftClickColuna' ].bind( contexto )( i, e, contexto.getNomeColuna( idColuna ), contexto.getStatusColuna(contexto.getNomeColuna( idColuna )), evento.target, contexto ); };
                        }

                        if( contexto.callbacks[ 'onMiddleClickColuna' ] ){
                            if( evento.button == 1 ){ contexto.callbacks[ 'onMiddleClickColuna' ].bind( contexto )( i, e, contexto.getNomeColuna( idColuna ), contexto.getStatusColuna(contexto.getNomeColuna( idColuna )), evento.target, contexto ); };
                        }

                        if( contexto.callbacks[ 'onRightClickColuna' ] ){
                            if( evento.button == 2 ){ contexto.callbacks[ 'onRightClickColuna' ].bind( contexto )( i, e, contexto.getNomeColuna( idColuna ), contexto.getStatusColuna(contexto.getNomeColuna( idColuna )), evento.target, contexto ); };
                        }
                        
                        //Se a coluna tiver um evento em statusColunas
                        if( contexto.statusColunas != undefined )
                        {
                            if( contexto.statusColunas[ contexto.getNomeColuna( idColuna ) ]['onLeftClick'] ){
                                if( evento.button == 0 ){ contexto.statusColunas[ contexto.getNomeColuna( idColuna ) ]['onLeftClick'].bind( contexto )( i, e, contexto.getNomeColuna( idColuna ), contexto.getStatusColuna(contexto.getNomeColuna( idColuna )), evento.target, contexto ); };
                            }
                            if( contexto.statusColunas[ contexto.getNomeColuna( idColuna ) ]['onMiddleClick'] ){
                                if( evento.button == 1 ){ contexto.statusColunas[ contexto.getNomeColuna( idColuna ) ]['onMiddleClick'].bind( contexto )( i, e, contexto.getNomeColuna( idColuna ), contexto.getStatusColuna(contexto.getNomeColuna( idColuna )), evento.target, contexto ); };
                            }
                            if( contexto.statusColunas[ contexto.getNomeColuna( idColuna ) ]['onRightClick'] ){
                                if( evento.button == 2 ){ contexto.statusColunas[ contexto.getNomeColuna( idColuna ) ]['onRightClick'].bind( contexto )( i, e, contexto.getNomeColuna( idColuna ), contexto.getStatusColuna(contexto.getNomeColuna( idColuna )), evento.target, contexto ); };
                            }
                        }
                    })
                }
            }

            /**
            * Cria os eventos de edição das colunas da linha 
            */
            if(document.getElementsByName(`linha-${idLinha}-grid-${contexto.idElementoPai}`)[0])
            {
                //Pega todos os elementos do tipo input e tambem do tipo select em uma "query concatenada"
                [].concat(
                        [
                            //Pega todos os inputs
                            ...
                               (document)
                               .getElementsByName(`linha-${idLinha}-grid-${contexto.idElementoPai}`)[0]
                               .querySelectorAll('input')
                        ]
                    )
                    .concat(
                        [
                            //Pega todos os selects tambem
                            ...
                               (document)
                               .getElementsByName(`linha-${idLinha}-grid-${contexto.idElementoPai}`)[0]
                               .querySelectorAll('select')
                        ]
                )
                //Itera sobre essa concatenação
                .forEach(function( objInput, indiceObjInput ){
                    const idInput      = objInput.id;
                    const numLinha     = Number( objInput.getAttribute('_linha') );
                    const numColuna    = Number( objInput.getAttribute('_coluna') );
                    const nomeColuna   = contexto.getNomeColuna( numColuna );
                    const statusColuna = contexto.getStatusColuna( nomeColuna );
                    const valorAtual   = objInput.value;

                    if( statusColuna.editable != undefined )
                    {
                        objInput.onchange = function(evento){

                            const valorEditado = evento.target.type == 'checkbox' 
                                                    ? evento.target.checked
                                                    : evento.target.value;

                            //Edita o objeto dados interno
                            contexto.setColunaAmostra( numLinha, numColuna, valorEditado );

                            //Se o editable for um JSON, e dentro dele tiver o callback onChange, ele aplica ele com esses parametros
                            if( typeof statusColuna.editable == 'object' &&
                                statusColuna.editable.onChange
                            ){
                                statusColuna.editable.onChange.bind(contexto)( idInput, valorAtual, valorEditado, Number(numLinha), Number(numColuna), nomeColuna, statusColuna, contexto );
                            }
                        }

                        objInput.addEventListener('keydown', function(eventoKeydown){
                            if( eventoKeydown.key == 'Enter' ){
                                
                                const idColuna = eventoKeydown.target.getAttribute('_coluna');

                                setTimeout(()=>{
                                    const idProximaColunaEditavel = (contexto.editableMap[ idColuna ] || {}).indiceProximaColuna;

                                    //Se existe uma proxima coluna editavel
                                    if( idProximaColunaEditavel != undefined ){
                                        document.getElementById(`input-coluna${ idProximaColunaEditavel }-linha${idLinha}-grid-${contexto.idElementoPai}`).click()
                                    
                                    //CASO NÂO EXISTA NENHUMA PROXIMA COLUNA EDITAVEL
                                    }else{
                                        //CRIA UMA NOVA AMOSTRA EM BRANCO
                                        contexto.adicionarAmostra( Array(contexto.dados[0].length).fill('.') );
                                        document.getElementById(`input-coluna${ 0 }-linha${idLinha+1}-grid-${contexto.idElementoPai}`).click()
                                    }
                                
                                }, 100);

                            }
                        });
                    
                    }

                });
            }
        }

        //Roda o callback afterRender
        if( this.callbacks.afterRender ){
            this.callbacks.afterRender.bind(this)( this );
        }

        //Cria alguns botões
        if( this.buttons == true || typeof this.buttons == 'object' )
        {
            document.getElementsByClassName('linha-toolbar')[0].innerHTML += `
                ${ 
                   (
                        //Se eu controlo se vai ter botao de adicionar amostra ou não
                        (
                            typeof this.buttons == 'object' && 
                            this.buttons.new == true
                        )
                        //OU SE EU NÂO ESPECIFICAR NADA, VAI TER POR PADRAO
                        ||
                        (
                            typeof this.buttons == 'boolean'
                        )
                   ) == true
                            ? "<button name='botao-adicionar-amostra' class='elemento-linha-grid'> 🖉 New </button>" 
                            : ""               
                }

                ${
                    (
                        //Se eu controlo se vai ter botao de adicionar amostra ou não
                        (
                            typeof this.buttons == 'object' && 
                            this.buttons.reflesh == true
                        )
                        //OU SE EU NÂO ESPECIFICAR NADA, VAI TER POR PADRAO
                        ||
                        (
                            typeof this.buttons == 'boolean'
                        )
                   ) == true 
                            ? "<button name='botao-recarregar-grid' class='elemento-linha-grid'>🔌Reflesh </button>"
                            : ""
                }
            `;
        }

        if( this.searchBar == true || typeof this.searchBar == 'object' )
        {
            document.getElementsByClassName('linha-pesquisa')[0].innerHTML = `
                <input class='input-pesquisa-grid'
                    placeholder='🔍 Search...' 
                />
            `;
        }

        //Cria os eventos dos botões
        if( this.buttons == true || typeof this.buttons == 'object' )
        {
            (document)
            .getElementById(contexto.idElementoPai)
            .querySelectorAll('button')
            .forEach(function( objBotao, indiceBotao ){

                if( objBotao.name == 'botao-adicionar-amostra' ){
                    objBotao.contexto = contexto;
                    objBotao.onclick = function(evento){
                        contexto.adicionarAmostra( Array(contexto.dados[0].length).fill('.') );
                    }
                }

                if( objBotao.name == 'botao-recarregar-grid' ){
                    objBotao.contexto = contexto;
                    objBotao.onclick = function(evento){
                        contexto.render();
                    }
                }

            });
        }

        if( this.searchBar == true || typeof this.searchBar == 'object' )
        {
            //Cria o evento de pesquisa
            (document)
            .getElementById(contexto.idElementoPai)
            .querySelector('.input-pesquisa-grid')
            .value = contexto.pesquisando;

            (document)
            .getElementById(contexto.idElementoPai)
            .querySelector('.input-pesquisa-grid')
            .onchange = function(evento){
                const valorPesquisa = evento.target ? String(evento.target.value).toLowerCase() : null;

                //Identifica SE e o QUE o usuario está pesquisando na grid
                if( valorPesquisa != '' ){
                    contexto.pesquisando = valorPesquisa;
                }else{
                    contexto.pesquisando = null;
                }

                contexto.render();
            }
        }

    }
}
